#!/usr/bin/perl
use strict;
use warnings;
use POSIX;
#------------------------------------------------------------------------------
# user-configurable default values
#
# all coordinates/box sizes are X Y Z where Y is the vertical dimension

# size of maze (array)
my ($xmazesize, $ymazesize, $zmazesize ) = ( 20, 20, 20 );

# starting position of maze, overridden if starting in room 1
# my ($xmazestart, $ymazestart, $zmazestart ) = ( 0, 0, 0 );
my $ystartlevel = 0;

# maximum room size, overridden by room class array entries
my ($xmaxroom, $ymaxroom, $zmaxroom) = ( 5, 3, 5 );

# minimum room size (sizes below 3x1x3 may not be accessible)
my ($xminroom, $yminroom, $zminroom) = ( 3, 1, 3 );

# maximum number of rooms
my $numrooms = 511;

# number of times it should attempt to place a room before abandoning
my $roomplacetrys = 100;

# set to 0 to allow rooms on X/Y maze edges
# set to 1 to require a hallway between rooms and maze edges
my $roomedgebuffer = 1;

# allow rooms to be adjacent to other rooms (0=disallowed/1=allowed)
my $adjacentrooms = 0;

# flag to invert vertical maze information in levels
# set to 0 for level 0 to be the top level
# set to 1 for level 0 to be the bottom level
# Note: this is no longer fully implemented
my $invertlevels = 0;

# allow up/down ladders and doors (0=disallowed/1=allowed)
my $updowndirs = 0;

# allow vertical room doors (0=disallowed/1=allowed)
# ignored if updowndirs is disabled
my $verticaldoors = 0;

# add passage loops and crossover loops to maze
# 0=off/1=on
my $mazeloops = 1;
my $mazexoloops = 1;

# minimum size of maze loop, if enabled.
my $minmazeloop = 30;

# maximum number of crossover loops to add
my $maxxoloops = 10;

# maximum attempts of finding a valid crossover start location
my $maxxoattempts = 100;

# enable dungeon mode (0=off/1=on)
# this will override all multi-level access methods and build a
# traditional one entrance/exit per level dungeon.  Distance
# metrics will accumulate between levels.
my $dungeonmode = 0;

# flag to make room 1 the starting location (0=off/1=on)
# overrides starting position specified above
my $startinroom = 0;

# default name of file prefix.  files written will be {prefix}.txt,
# {prefix}.raw and {prefix}.diag, if enabled below.  prefix can be
# overridden by specifying it as the first argument when running this script.
my $fileprefix = "maze";

# enable diagnostic/raw/txt file output (0=disabled/1=enabled)
my $diagout = 1;
my $rawout = 1;
my $txtout = 1;
my $mceout = 1;

# minecraft schematic template and dungeon generation - array cell to minecraft coordinate scale
my ( $mc_hscale, $mc_vscale ) = ( 12, 12 );

# mce dungeon generation - minecraft coordinate offset
# my ( $mc_xoffset, $mc_yoffset, $mc_zoffset ) = ( 140, 127, 980 );
my ( $mc_xoffset, $mc_yoffset, $mc_zoffset ) = ( 0, 245, 0 );
my $mc_dim_dungeon = "overworld";
my $mc_log_dungeon = 100;

# template building/importing/exporting - minecraft coordinate offset
# my ( $mc_xtoffset, $mc_ytoffset, $mc_ztoffset ) = ( 140, 32, 720 );
# my ( $mc_xtoffset, $mc_ytoffset, $mc_ztoffset ) = ( 0, 8, 0 );
# my $mc_dim_template = "hell";
my ( $mc_xtoffset, $mc_ytoffset, $mc_ztoffset ) = ( 250, 6, 0 );
my $mc_dim_template = "overworld";
my $mc_log_template = 100;

# room template building - minecraft coordinate offset
# my ( $mc_xrtoffset, $mc_yrtoffset, $mc_zrtoffset ) = ( 360, 32, 320 );
# my $mc_dim_rtemplate = "hell";
my ( $mc_xrtoffset, $mc_yrtoffset, $mc_zrtoffset ) = ( 0, 6, 400 );
my $mc_dim_rtemplate = "overworld";
my $mc_log_rtemplate = 100;

# minecraft schematic set root directory
my $mc_schemroot = "./maze-schematics/$mc_hscale" . "x" . "$mc_vscale";

# template importing/exporting - minecraft maze schematic sub-directory to use
my $defaultset = "utility-sb";

# add a FEV offset when building a template
my $buildfev = 0;

# place template in alternate subdirectory
my $buildalt = 0;

# output mce files for building, importing, and exporting schematics
# it is very useful to specify the mc_xtoffset/mc_ytoffset/mc_ztoffset coordinate offset
# and mc_hscale/mc_vscale/mc_hscale options with -buildtempl
my $buildtempl = 0;

# flags for mirroring bitmap rooms across X/Y/Z axis or adding horizontal rotation.
my ( $bmxswap, $bmyswap, $bmzswap, $bmhrotate ) = ( 0,0,0,0 );

# allow path crossovers
my $crossovers = 1;

# maximum span of crossovers
my $maxcrossspan = 8;

# allow room passthrus
my $passthrus = 1;

# allow dynamic stairs
my $dynstairs = 1;

# show floor/ceiling effects on ascii map (0=no/1=yes)
my $showfceffect = 1;

# allow floor/ceiling effects (0=no/1=yes)
my $allowfeffects = 1;
my $allowceffects = 1;

# dense packing of rooms
my $denseroompacking = 0;

# corner choice method for dense room packing
# 0 = choose random corner, 1 = choose nearest corner
my $choosecorner = 1;

# startfceffect - percent odds of starting a new floor/ceiling effect
my $startfceffect = 5;

# allow random pit traps (0=no/1=yes)
my $pittraps = 1;

# allow deep pit traps (0=no/1=yes)
my $deeppittraps = 1;

# show pit traps on ascii map
my $showtraps = 1;

# trap percentage odds
my $trapodds = 2;
my $pittrapodds = 2;
my $deeppittrapodds = 2;

# enable debugging output
my $debug = 0;
my $debug1 = 0;
my $debug2 = 0;
my $debug3 = 0;

# deadend removal passes
my $deadendrmlength = 0;
my $deadendrmdoors = 1;

# prioritize room-to-room doors over room-to-hallway doors.
my $room2roompriority = 1;

# density of huts for sparsely populated village rooms.
my $hutdensity = 10;

# canal internal room size and spacing
my ( $canalxroom, $canalzroom, $canalxspace, $canalzspace) = ( 3,3,4,4);

# enable vertical hallway extensions
my $vhe_enabled = 1;

# enable floor elevation variance
my $fev_enabled = 1;

# set the divisors for the architectural and treasure object thresholds
my $aobj_div = 100;
my $tobj_div = 200;

# set the random multiplier for the architectural and treasure object thresholds
my $aobj_rmult = 4;
my $tobj_rmult = 8;

# provide a random seed.  (0=auto-generated/non-zero=random seed value)
my $seed = time();

#------------------------------------------------------------------------------
# non-user-configurable global variables

# mazegrid bit allocation
my ($vhemask, $vheshft)			= ( 0x00000007, 0 );
my ($cellusemask, $celluseshft)		= ( 0x00000008, 3 );
my ($backmask, $backshft)		= ( 0x000001f0, 4 );
my ($thrumask, $thrushft)		= ( 0x00000200, 9 );
my ($othrumask, $othrushft)		= ( 0x00000400, 10 );
my ($odoormask, $odoorshft)		= ( 0x00000800, 11 );
my ($fevmask, $fevshft)			= ( 0x00007000, 12 );
my ($gstylemask, $gstyleshft)		= ( 0x00038000, 15 );
my ($lstylemask, $lstyleshft)		= ( 0x000c0000, 18 );
my ($pathmask, $pathshft)		= ( 0x03f00000, 20 );
my ($doormask, $doorshft)		= ( 0x04000000, 26 );
my ($diagpathmask, $diagpathshft)	= ( 0x08000000, 27 );
my ($doorgpmask, $doorgpshft)		= ( 0xf0000000, 28 );

# auxmazegrid bit allocation
my ($segmentmask, $segmentshft)		= ( 0x0000003f, 0 );
my ($roomidmask, $roomidshft)		= ( 0x0000ffc0, 6 );
my ($hallidmask,$hallidshft)		= ( 0x00ff0000, 16 );
my ($cellspcmask,$cellspcshft)		= ( 0xff000000, 24 );

# distmazegrid bit allocation
my ($distmask, $distshft)		= ( 0x0000ffff, 0 );
my ($fetypemask, $fetypeshft)		= ( 0x000f0000, 16 );
my ($felevlmask, $felevlshft)		= ( 0x00700000, 20 );
my ($fesprdmask, $fesprdshft)		= ( 0x00800000, 23 );
my ($cetypemask, $cetypeshft)		= ( 0x0f000000, 24 );
my ($celevlmask, $celevlshft)		= ( 0x70000000, 28 );
my ($cesprdmask, $cesprdshft)		= ( 0x80000000, 31 );

# adjmazegrid bit allocation
my ($adjmask, $adjshft)			= ( 0x07ffffff, 0 );
my ($pillarmask, $pillarshft)		= ( 0x08000000, 27 );
my ($pridoormask,$pridoorshft)		= ( 0x10000000, 28 );
my ($unminedmask, $unminedshft)		= ( 0x20000000, 29 );
my ($ledgemask, $ledgeshft)		= ( 0x40000000, 30 );
my ($noroommask, $noroomshft)		= ( 0x80000000, 31 );

# thrmazegrid bit allocation
my ($threadmask, $threadshft)		= ( 0xffffffff, 0 );

# objmazegrid bit allocation
my ($objindexmask, $objindexshft)	= ( 0x00000fff, 0 );
my ($objcountmask, $objcountshft)	= ( 0x0000f000, 12 );
my ($aobjthrmask, $aobjthrshft)		= ( 0x00ff0000, 16 );
my ($tobjthrmask, $tobjthrshft)		= ( 0xff000000, 24 );

# randgrid bit allocation
my ($randgridmask, $randgridshft)	= ( 0xffffffff, 0 );

my @roominfo;
my @doorinfo;
my @hallinfo;
my @levelinfo;
my @looplist;
my @deadendlist;
my $deadendcount = 0;
my @halldeadendlist;
my @halldeadendctr;
my @mazegrid;
my @distmazegrid;
my @auxmazegrid;
my @randgrid;
my @objmazegrid;
my @objindex;
my $max_objidx = 0;
my $total_aobj = 0;
my $total_tobj = 0;
my $total_atobj = 0;
my @adjmazegrid;
my @thrmazegrid;
my @threadinfo;
my $totalthreads = 0;
my @asciigrid;
my @colorgrid;
my @dynstairlist;
my $dsindex = 0;
my $maxdsspan = 10;
my @doorlist;
my @pridoorlist;
my @roombitmaps;
my $maxroombitmap = 0;
my @bmrooms;
my @bmstagegrid;
my @roomcoordlist;
my $roomcoordcount = 0;
my @setrooms;
my @norooms;
my @feffectclass;
my $maxfeffectclass;
my @ceffectclass;
my $maxceffectclass;
my @roomclass;
my $maxroomclass;
my @interiorclass;
my $maxinteriorclass;
my @intclassqty;
my @intvarindex;
my @towerclass;
my $maxtowerclass;
my @doorclass;
my $maxdoorclass = 50;
my @levelclass;
my $maxlevelclass;
my @hallclass;
my $maxhallclass = 50;
my @datasetclass;
my $maxdatasetclass = 50;
my @objectclass;
my $maxobjectclass;
my $totalrooms = 0;
my $totaldoors = 0;
my $totalhalls = 0;
my $totalobjects = 0;
my $distrightshift = 0;
my $loops = 0;
my $bmroomcount = 0;
my $setroomcount = 0;
my $noroomcount = 0;
my $roomtemplate = 0;
my @pillarlist;
my $pillarcount = 0;
my $labyrinth = -1;
my $cached_hv_match = '';
my $cached_hv_num = 0;
my @hallclasstotalloc;
# my ( $ximazestart, $yimazestart, $zimazestart ) =
# 	($xmazestart, $ymazestart, $zmazestart);
my ( $highdistval, $xhighdist, $yhighdist, $zhighdist ) = ( 0,0,0,0 );

setfeffectclasses();
setceffectclasses();
setlevelclasses();
setroomclasses();
setinteriorclasses();
sethallclasses();
setdoorclasses();
settowerclasses();
setdatasetclasses();

#------------------------------------------------------------------------------
# usage - print usage

sub usage() {
       print STDERR << "EOF";

usage: $0 [-[no]flag-option | -string-option="string" | -numeric-option=number ]...

  options:

     flag options:

      diagout		write out maze diagnostics file
      rawout		write out maze raw file
      txtout		write out ascii and ansi maze files
      roomedgebuffer	require border between room and outer maze edge
      adjacentrooms	allow rooms to be adjacent to other rooms
      invertlevels	invert up/down indicators on ascii maze output
      updowndirs	allow up/down ladders in maze
      verticaldoors	allow vertical exit directions from rooms
      mazeloops		selectively create long maze loops by removing walls
      mazexoloops	selectively create maze loops by adding crossovers
      dungeonmode	limit vertical level access to one entrance per level
      startinroom	move maze starting position to room 1
      bmxswap		invert room bitmap on X axis
      bmyswap		invert room bitmap on Y axis
      bmzswap		invert room bitmap on Z axis
      bmhrotate		rotate room bitmap horizontally (1=90,2=180,3=270 degree)
      crossovers	allow hallways crossing paths over other hallways
      passthrus		allow hallways crossing through rooms
      dynstairs		allow dynamic stairs to be used in hallways
      allowfeffects	allow floor effects in hallways and rooms
      allowceffects	allow ceiling effects in hallways and rooms
      showfceffect	show floor/ceiling effects on ascii/ansi map output
      pittraps		allow pit trap generation
      showtraps		show traps on ascii/ansi map output
      deadendrmdoors	remove dead-end doors with path
      room2roompriority	prioritize room-to-room paths over room-to-hall paths
      denseroompacking	attempt to densely pack rooms on maze
      choosecorner	choose nearest corner for dense room packing movement
      debug		specify one or more times for increased verbose output

     string options:

      prefix="name"
			override default "maze" file prefix for output files
      bitmaproom="X,Y,Z,bitmap[,room-class]"
			add bitmap room at specified coordinates
      placeroom="X,Y,Z,XS,YS,ZS,room-class"
			add room of specified class and size at coordinates
      placelevel="Y,room-class"
			add a level-size room with specified class on level 'Y'
      levelclass="Y,level-class"
			adjust the level class of level 'Y'
      noroomblock="X,Y,Z,XS,YS,ZS"
			prevent random rooms from being built in specified area
      mc_schemroot="path"
			set the path to the schematic sets

     integer numeric options:

      seed		specify a random seed
      xmazesize		size of maze array X dimension
      ymazesize		size of maze array Y dimension
      zmazesize		size of maze array Z dimension
      xmaxroom		default maximum size of room, X dimension
      ymaxroom		default maximum size of room, Y dimension
      zmaxroom		default maximum size of room, Z dimension
      xminroom		default minimum size of room, X dimension
      yminroom		default minimum size of room, Y dimension
      zminroom		default minimum size of room, Z dimension
      numrooms		maximum number of rooms
      roomplacetrys	number of attempts to place random room
      minmazeloop	minimum size to consider for creating a maze loop
      deadendrmlength	length of path to remove from each dead-end
      roomtemplate	build a room template file of the room number specified
      labyrinth		set level as a labyrinth and all upper levels as tower

     floating numeric options:

      startfceffect	percentage odds of starting floor/ceiling effects
      trapodds		percentage odds of adding a non-pit trap
      pittrapodds	percentage odds of adding a pit trap
      deeppittrapodds	percentage odds of adding a deep pit trap

      see variable section in $0 for more detailed information

  examples: $0 -ymazesize=10 -dungeonmode -prefix="10leveldungeon"
	    $0 -ymazesize=1 -nocrossovers -numrooms=0 -prefix="simple2Dmaze"
	    $0 -bitmaproom="6,1,6,Arena"

EOF
	exit;
};
#------------------------------------------------------------------------------
# process arguments

use Getopt::Long;
GetOptions(
	"debug!"=> sub{ $debug += 1 },
	"diagout!"=>\$diagout,
	"rawout!"=>\$rawout,
	"txtout!"=>\$txtout,
	"mceout!"=>\$mceout,
	"roomedgebuffer!"=>\$roomedgebuffer,
	"adjacentrooms!"=>\$adjacentrooms,
	"invertlevels!"=>\$invertlevels,
	"updowndirs!"=>\$updowndirs,
	"verticaldoors!"=>\$verticaldoors,
	"mazeloops!"=>\$mazeloops,
	"mazexoloops!"=>\$mazexoloops,
	"dungeonmode!"=>\$dungeonmode,
	"startinroom!"=>\$startinroom,
	"buildtempl!"=>\$buildtempl,
	"bmxswap!"=>\$bmxswap,
	"bmyswap!"=>\$bmyswap,
	"bmzswap!"=>\$bmzswap,
	"crossovers!"=>\$crossovers,
	"passthrus!"=>\$passthrus,
	"dynstairs!"=>\$dynstairs,
	"showfceffect!"=>\$showfceffect,
	"allowfeffects!"=>\$allowfeffects,
	"allowceffects!"=>\$allowceffects,
	"pittraps!"=>\$pittraps,
	"showtraps!"=>\$showtraps,
	"deadendrmdoors!"=>\$deadendrmdoors,
	"denseroompacking!"=>\$denseroompacking,
	"choosecorner!"=>\$choosecorner,
	"room2roompriority!"=>\$room2roompriority,
	"prefix:s",\$fileprefix,
	"mc_schemroot:s",\$mc_schemroot,
	"seed=i"=>\$seed,
	"xmazesize=i"=>\$xmazesize,
	"ymazesize=i"=>\$ymazesize,
	"zmazesize=i"=>\$zmazesize,
	"xmaxroom=i"=>\$xmaxroom,
	"ymaxroom=i"=>\$ymaxroom,
	"zmaxroom=i"=>\$zmaxroom,
	"xminroom=i"=>\$xminroom,
	"yminroom=i"=>\$yminroom,
	"zminroom=i"=>\$zminroom,
	"numrooms:i"=>\$numrooms,
	"roomplacetrys=i"=>\$roomplacetrys,
	"minmazeloop=i"=>\$minmazeloop,
	"mc_hscale=i"=>\$mc_hscale,
	"mc_vscale=i"=>\$mc_vscale,
	"mc_xtoffset=i"=>\$mc_xtoffset,
	"mc_ytoffset=i"=>\$mc_ytoffset,
	"mc_ztoffset=i"=>\$mc_ztoffset,
	"mc_xoffset=i"=>\$mc_xoffset,
	"mc_yoffset=i"=>\$mc_yoffset,
	"mc_zoffset=i"=>\$mc_zoffset,
	"deadendrmlength=i"=>\$deadendrmlength,
	"roomtemplate=i"=>\$roomtemplate,
	"labyrinth=i"=>\$labyrinth,
	"bmhrotate=i"=>\$bmhrotate,
	"startfceffect=f"=>\$startfceffect,
	"trapodds=f"=>\$trapodds,
	"pittrapodds=f"=>\$pittrapodds,
	"deeppittrapodds=f"=>\$deeppittrapodds,
	"bitmaproom=s"=> sub{ &parsebmroomopt },
	"placeroom=s"=> sub{ &parsesetroomopt },
	"placelevel=s"=> sub{ &parsesetlevelopt },
	"levelclass=s"=> sub{ &parselevelclassopt },
	"noroomblock=s"=> sub{ &parsenoroomopt },
	) or usage();

#==============================================================================
# buildmaze - main maze-building routine

sub buildmaze {

	my @dirlist;
	my $stopflag;
	my $backtrackflag;
	my $end;
	my $livethreads = 1;

	# reset end flag and set starting point for each thread.
	# each thread represents an independant path through the maze.
	foreach my $thread ( 1 .. $totalthreads ) {

		# permanently skip this thread if it had reached a dungeon end.
		next if ( $threadinfo[$thread][16] );

		$threadinfo[$thread][12] = 0;
		$threadinfo[$thread][ 1] = $threadinfo[$thread][ 5];
		$threadinfo[$thread][ 2] = $threadinfo[$thread][ 6];
		$threadinfo[$thread][ 3] = $threadinfo[$thread][ 7];

		setcelluse( $threadinfo[$thread][1], $threadinfo[$thread][2], $threadinfo[$thread][3] );
	};

	print "buildmaze started\n" if $debug1;

	# generate maze
	do {
	  # track whether we still have active threads
	  $livethreads = 0;

	  # randomize the order in which we process the threads
	  my @threadlist = &randomnumberlist($totalthreads );

	  # process each thread
	  foreach my $thread ( @threadlist ) {

	    # lookup the thread information
	    my ( $xmazepoint, $ymazepoint, $zmazepoint, $distance, $end ) = getthread( $thread );

	    # skip this thread if it is no longer an active thread
	    next if $end;

	    print "resuming thread $thread\n" if $debug2;

	    # flag that we still have active threads
	    $livethreads = 1;

	    # track whether we should break out of current thread
	    my $breakthread = 0;

	    # start maze path creation loop
	    do {
		print "thread $thread loop $xmazepoint $ymazepoint $zmazepoint\n" if $debug2;

		# grab current cell attributes
		my ( $cc_valid, $cc_celluse, $cc_paths, $cc_backdir, $cc_segment, $cc_roomid, $cc_dist,
			$cc_feffectlvl, $cc_feffecttype, $cc_ceffectlvl, $cc_ceffecttype ) =
			getcellinfo( $xmazepoint, $ymazepoint, $zmazepoint );
		my $hallid = gethallid( $xmazepoint, $ymazepoint, $zmazepoint );
		my $hclass = gethallinfo( $xmazepoint, $ymazepoint, $zmazepoint, 0, 0 );
		my ( $hallgstyle, $halllstyle ) = gethallstyle( $xmazepoint, $ymazepoint, $zmazepoint );
		$hclass = 0 if ( ! $hclass );

		my ( $cc_aobjthr, $cc_tobjthr, $cc_objidx, $cc_objct ) = getobjvals( $xmazepoint, $ymazepoint, $zmazepoint );

		$stopflag=0;
		$backtrackflag=1;
		my $hipridir=0;
		my $lopridir=0;
		my $dirfound=0;
		my $crossover=0;
		my $passthru=0;
		my $dynstair=0;

		if ( $cc_roomid == 0 ) {
		    # cell is in a hallway.

		    print "hallway cell at $xmazepoint $ymazepoint $zmazepoint\n" if $debug2;
		    
		    # try to find a path to move to.
		    ( $dirfound, $crossover, $passthru, $dynstair ) = checkforhallpath( $xmazepoint, $ymazepoint, $zmazepoint );
		    
		    if ( $dirfound ) {
			# we found a direction to go.
			
			my ( $XI, $YI, $ZI ) = ( 0, 0, 0 );
			if ( $dynstair ) {
				# get the relative start/end movement through the dynamic stair cells
                		$XI = ($dynstairlist[$dsindex][1]-$dynstairlist[1][1]);
                		$YI = ($dynstairlist[$dsindex][2]-$dynstairlist[1][2]);
                		$ZI = ($dynstairlist[$dsindex][3]-$dynstairlist[1][3]);
			} else {
				# get the relative XYZ direction of the path
				( $XI, $YI, $ZI ) = getmazedirection($dirfound);
			};

			# if this is a crossover or passthru, we are jumping multiple horizontal spaces
			if ( $crossover ) {
				$XI = ( ( $XI * $crossover ) + $XI );
				$ZI = ( ( $ZI * $crossover ) + $ZI );
			} elsif ( $passthru ) {
				$XI = ( ( $XI * $passthru ) + $XI );
				$ZI = ( ( $ZI * $passthru ) + $ZI );
			};
			
			# determine if floor/ceiling effects start, increase, or decrease
			my ($new_feffectlvl, $new_feffecttype, $new_ceffectlvl, $new_ceffecttype) =
				( geteffectodds( $cc_feffectlvl, $cc_feffecttype, $cc_ceffectlvl, $cc_ceffecttype, 0 ));

			# determine if we need to place an object
			my ($new_aobjthr, $new_tobjthr, $new_objidx, $new_objct, $obj_match) =
				( getobjodds( $cc_aobjthr, $cc_tobjthr, $cc_objidx, $cc_objct, 0 ));

			setobjidx( $xmazepoint, $ymazepoint, $zmazepoint, $new_objidx, $new_objct ) if $obj_match;

			# get the vertical hallway extension flag of the current cell
			my $cc_vhe = getvhe( $xmazepoint, $ymazepoint, $zmazepoint);

			# get the floor elevation variance value of the current cell
			my $cc_fev = getfev( $xmazepoint, $ymazepoint, $zmazepoint);

			# determine if current extension should change
			my ($vhe_upexp, $vhe_downexp, $cc_upexp, $cc_downexp ) = getvheodds( $xmazepoint, $ymazepoint, $zmazepoint );

			# determine if current floor elevation variance should change
			my $fev = getfevodds( $xmazepoint, $ymazepoint, $zmazepoint );

			if ( $fev ) {
				# clear the FEV value if we are moving into a room which does not allow it
				my $fev_roomid = getroomid( $xmazepoint+$XI, $ymazepoint+$YI, $zmazepoint+$ZI );
				my $fev_roomspc = getroomspc( $fev_roomid );
				my ( $valid_b36, $roomspc_b36) = getroomspcflag( $fev_roomspc, 36 );
				$fev = 0 if ( $fev_roomid && ! $roomspc_b36 );

				# clear the FEV value if we are entering a dynamic stair
				$fev = 0 if ( $dynstair );
			};

			# check if the odds and cell usage allow upward expansion of the new cell
			my $upexp = 0;
			if ( $YI == 0 && $crossover == 0 && $passthru == 0 ) {
			    if ( $vhe_upexp ) {
				my $roomid = getroomid( $xmazepoint+$XI, $ymazepoint, $zmazepoint+$ZI );
				$vhe_upexp = 0 if $roomid;
			    }
			    if ( $vhe_upexp >= 1 ) {
				my $bounds = checkbounds( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI );
				my $celluse = getcelluse( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI );
				my $eroomid = getroomid( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI );

				$upexp = 1 if ( $bounds == 1 && $eroomid == 0 && $celluse == 0 );
			    };
			    if ( $vhe_upexp >= 2 && $upexp == 1 ) {
				my $bounds = checkbounds( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI );
				my $celluse = getcelluse( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI );
				my $eroomid = getroomid( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI );

				$upexp = 2 if ( $bounds == 1 && $eroomid == 0 && $celluse == 0 );
			    };
			    if ( $vhe_upexp == 3 && $upexp == 2 ) {
				my $bounds = checkbounds( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI );
				my $celluse = getcelluse( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI );
				my $eroomid = getroomid( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI );

				$upexp = 3 if ( $bounds == 1 && $eroomid == 0 && $celluse == 0 );
			    };
			};

			# check if the odds and cell usage allow downward expansion of the new cell
			my $downexp = 0;
			if ( $YI == 0 && $crossover == 0 && $passthru == 0 ) {
			    if ( $vhe_downexp ) {
				my $roomid = getroomid( $xmazepoint+$XI, $ymazepoint, $zmazepoint+$ZI );
				$vhe_downexp = 0 if $roomid;
			    };
			    if ( $vhe_downexp >= 1 ) {
				my $bounds = checkbounds( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI );
				my $celluse = getcelluse( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI );
				my $eroomid = getroomid( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI );

				$downexp = 1 if ( $bounds == 1 && $eroomid == 0 && $celluse == 0 );
			    };
			    if ( $vhe_downexp >= 2 && $downexp == 1 ) {
				my $bounds = checkbounds( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI );
				my $celluse = getcelluse( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI );
				my $eroomid = getroomid( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI );

				$downexp = 2 if ( $bounds == 1 && $eroomid == 0 && $celluse == 0 );
			    };
			    if ( $vhe_downexp == 3 && $downexp == 2) {
				my $bounds = checkbounds( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI );
				my $celluse = getcelluse( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI );
				my $eroomid = getroomid( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI );

				$downexp = 3 if ( $bounds == 1 && $eroomid == 0 && $celluse == 0 );
			    };
			}

			# clear the fev value if we have a vhe expansion and the hallway type disallows combined vhe/fev
			if ( $fev ) {
				my ($hfound_b12, $hflag_b12) = gethallflag( $xmazepoint, $ymazepoint, $zmazepoint, 12 );
				my ($hfound_b13, $hflag_b13) = gethallflag( $xmazepoint, $ymazepoint, $zmazepoint, 13 );
				$fev = 0 if ( $upexp && ! $hflag_b12 );
				$fev = 0 if ( $downexp && ! $hflag_b13 );
			};

			# clear the backtrack flag because we found a forward path
			$backtrackflag=0;
			
			# increment distance
			$distance += 1;
			
			# open up the vertically-extended ceiling or floor
			if ( $upexp ) {
				sethallid( $xmazepoint+$XI, $ymazepoint+0, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint+0, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint+0, $zmazepoint+$ZI, 0b100 );
			};
			if ( $upexp >= 1 ) {
				sethallid( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI, 0b011 );
				setuseflag( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI );
				openpath( $xmazepoint+$XI, $ymazepoint, $zmazepoint+$ZI, 5,1,0 );
				setcelldist ($xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI, $distance, $thread );
				setfev( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI, $fev );
			};
			if ( $upexp >= 2 ) {
				sethallid( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI, 0b010 );
				setuseflag( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI );
				openpath( $xmazepoint+$XI, $ymazepoint-1, $zmazepoint+$ZI, 5,1,0 );
				setcelldist ($xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI, $distance, $thread );
				setfev( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI, $fev );
			};
			if ( $upexp == 3 ) {
				sethallid( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI, 0b001 );
				setuseflag( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI );
				openpath( $xmazepoint+$XI, $ymazepoint-2, $zmazepoint+$ZI, 5,1,0 );
				setcelldist ($xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI, $distance, $thread );
				setfev( $xmazepoint+$XI, $ymazepoint-3, $zmazepoint+$ZI, $fev );
			};
			if ( $downexp ) {
				sethallid( $xmazepoint+$XI, $ymazepoint+0, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint+0, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint+0, $zmazepoint+$ZI, 0b100 );
			};
			if ( $downexp >= 1 ) {
				sethallid( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI, 0b101 );
				setuseflag( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI );
				openpath( $xmazepoint+$XI, $ymazepoint, $zmazepoint+$ZI, 6,1,0 );
				setcelldist ($xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI, $distance, $thread );
				setfev( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI, $fev );
			};
			if ( $downexp >= 2 ) {
				sethallid( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI, 0b110 );
				setuseflag( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI );
				openpath( $xmazepoint+$XI, $ymazepoint+1, $zmazepoint+$ZI, 6,1,0 );
				setcelldist ($xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI, $distance, $thread );
				setfev( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI, $fev );
			};
			if ( $downexp == 3 ) {
				sethallid( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI, $hallid, 0, 1 );
				sethallgstyle( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI, $hallgstyle );
				setvhe( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI, 0b111 );
				setuseflag( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI );
				openpath( $xmazepoint+$XI, $ymazepoint+2, $zmazepoint+$ZI, 6,1,0 );
				setcelldist ($xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI, $distance, $thread );
				setfev( $xmazepoint+$XI, $ymazepoint+3, $zmazepoint+$ZI, $fev );
			};

			# open the cells between upper-extended hallways

			openpath( $xmazepoint, $ymazepoint-1, $zmazepoint, $dirfound,1,0 ) if ( $upexp >= 1 && $cc_upexp >= 1 );
			openpath( $xmazepoint, $ymazepoint-2, $zmazepoint, $dirfound,1,0 ) if ( $upexp >= 2 && $cc_upexp >= 2 );
			openpath( $xmazepoint, $ymazepoint-3, $zmazepoint, $dirfound,1,0 ) if ( $upexp >= 3 && $cc_upexp >= 3 );

			# open the cells between lower-extended hallways
			openpath( $xmazepoint, $ymazepoint+1, $zmazepoint, $dirfound,1,0 ) if ( $downexp >= 1 && $cc_downexp >= 1 );
			openpath( $xmazepoint, $ymazepoint+2, $zmazepoint, $dirfound,1,0 ) if ( $downexp >= 2 && $cc_downexp >= 2 );
			openpath( $xmazepoint, $ymazepoint+3, $zmazepoint, $dirfound,1,0 ) if ( $downexp >= 3 && $cc_downexp >= 3 );

			# open the maze path
			if ( $crossover != 0 ) {
				print "calling openpath for $xmazepoint $ymazepoint $zmazepoint mode 2 for crossover $crossover\n" if $debug3;
				openpath( $xmazepoint, $ymazepoint, $zmazepoint, $dirfound, 2, $crossover );
			} elsif ( $passthru != 0 ) {
				print "calling openpath for $xmazepoint $ymazepoint $zmazepoint mode 6 for passthru $passthru\n" if $debug3;
				openpath( $xmazepoint, $ymazepoint, $zmazepoint, $dirfound, 6, $passthru );
			} elsif ( $dynstair != 0 ) {
				print "calling openpath for $xmazepoint $ymazepoint $zmazepoint mode 8 for dynstair\n" if $debug3;
				openpath( $xmazepoint, $ymazepoint, $zmazepoint, $dirfound, 8, $dynstair );
			} else {
				print "calling openpath for $xmazepoint $ymazepoint $zmazepoint mode 0 for co $crossover pt $passthru\n" if $debug3;
				openpath( $xmazepoint, $ymazepoint, $zmazepoint, $dirfound, 0, 0 );
			};

			# move to the new location
			$xmazepoint += $XI;
			$ymazepoint += $YI;
			$zmazepoint += $ZI;

			print "move to $xmazepoint $ymazepoint $zmazepoint via dir $dirfound\n" if $debug2;

			# set distance/thread attribute on new cell
			setcelldist ($xmazepoint, $ymazepoint, $zmazepoint, $distance, $thread );

			# set hallway id on new cell
			sethallid( $xmazepoint, $ymazepoint, $zmazepoint, $hallid, 0, 0 );

			sethallgstyle( $xmazepoint, $ymazepoint, $zmazepoint, $hallgstyle );

			# set floor/ceiling effect information on cell
			setfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, $new_feffectlvl, $new_feffecttype );
			setceffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, $new_ceffectlvl, $new_ceffecttype );

			# set the floor elevation variance
			setfev( $xmazepoint, $ymazepoint, $zmazepoint, $fev );

			# set object threshold counters on cell
			setobjvals( $xmazepoint, $ymazepoint, $zmazepoint, $new_aobjthr, $new_tobjthr );
		    }
		} else {
			# cell is in a room.
			print "room cell at $xmazepoint $ymazepoint $zmazepoint\n" if $debug2;

			# get the room class
			my $cc_roomspc = getroomspc( $cc_roomid );

			# get room flags from room class array
			my ( $valid_b4, $roomspc_b4) = getroomspcflag( $cc_roomspc, 4 );

			# initialize room upon first contact.  Limit init to just clearing the
			# entry door flag and updating distance if room special flag bit 4 is set.
			if ( $roominfo[$cc_roomid][9] == 0 && ! $roomspc_b4 ) {
				initroom( $xmazepoint, $ymazepoint, $zmazepoint, $cc_roomid, $cc_backdir, $distance, $thread );
				$breakthread = 1;
			} else {
				cleardoorgroup( $xmazepoint, $ymazepoint, $zmazepoint, 1 );
			};
			updateroomdist( $cc_roomid, $distance, $thread );
			
			# determine if we are at an existing door
			my ($doorfound, $locdoor ) = lookupdoor( $xmazepoint, $ymazepoint, $zmazepoint );
			my ($srcx, $srcy, $srcz, $srcroom, $srcdoornum, $srcdir, $from, $did, $valid, $doorclass ) = getdoorinfo( $locdoor ) if $doorfound;

			my ( $found, $xloc, $yloc, $zloc, $checkdir, $XDI, $YDI, $ZDI );
			if ( ! $doorfound ) {

				# add a new door if the coordinates are not registered as a door
				my $doorclass = getdoortype( $cc_roomid, $xmazepoint, $ymazepoint, $zmazepoint, $cc_backdir );
				my $doornum = addtodoorlist( $cc_roomid, $xmazepoint, $ymazepoint, $zmazepoint, $cc_backdir, 1, $doorclass, 0 );

				# get the non-floor-effect flag for the door class, and clear any floor effects if the door does not allow it
				my ( $dvalid_b2, $doorspc_b2) = getdoorspcflag( $doorclass, 2 );
				setfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, 0, 0 ) if $doorspc_b2;

				# Set root attributes if floor/ceiling effect is active for room
				my ($feffectlvl, $feffecttype) = getfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint );
				my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xmazepoint, $ymazepoint, $zmazepoint );
				setroomattrib( $cc_roomid, 14 ) if ( $feffectlvl );
				setroomattrib( $cc_roomid, 15 ) if ( $ceffectlvl );

				# increment the door counter and decrement the cell counter for the hallid assigned to the new door

				my $dctr = gethallinfo( $xmazepoint, $ymazepoint, $zmazepoint, 0, 4 ) + 1;
				sethallinfo( $xmazepoint, $ymazepoint, $zmazepoint, 0, 4, $dctr );
				my $cctr = gethallinfo( $xmazepoint, $ymazepoint, $zmazepoint, 0, 5 ) - 1;
				sethallinfo( $xmazepoint, $ymazepoint, $zmazepoint, 0, 5, $cctr );

				# perform any remaining door initialization steps
				setprimarydoor( $cc_roomid, $xmazepoint, $ymazepoint, $zmazepoint, $doornum );
				spcroomadjust( $cc_roomid, $xmazepoint, $ymazepoint, $zmazepoint );
				cleardoorgroup( $xmazepoint, $ymazepoint, $zmazepoint );
				$from = 0;
				$did = $doornum;
				print "added new primary door for room $cc_roomid at $xmazepoint $ymazepoint $zmazepoint, doornum $doornum\n" if $debug2;
			};

			if ( $from == 0 ) {
				# we are at the primary room entrance, scan for an exit door
				print "located at room $cc_roomid, door $did, scan for new exit door\n" if $debug2;
				# scan room for a possible exit door.
				( $xloc, $yloc, $zloc, $found, $checkdir ) =
					scanfordoor( $cc_roomid, $xmazepoint, $ymazepoint, $zmazepoint );
					( $XDI, $YDI, $ZDI ) = getmazedirection( $checkdir );
			} else {
				# we are at a secondary room entrance, backtrack to primary door
				print "located at secondary door $did, skipping new door selection\n" if $debug2;

				# increment distance to counteract the backtrack distance decrement below
				$distance += 1;

				$found = 0;
			};
			
			if ( $found == 1 ) {
				# we can move forward, clear the backtrack flag
				$backtrackflag = 0;

				# open path to new room exit
				openpath( $xloc, $yloc, $zloc, $checkdir, 0, 0 );
				cleardoorgroup( $xloc, $yloc, $zloc, 1 );
				
				# add the door to the door list
				my $doorclass = getdoortype( $cc_roomid, $xloc, $yloc, $zloc, $checkdir );
				my $doornum = addtodoorlist( $cc_roomid, $xloc, $yloc, $zloc, $checkdir, 0, $doorclass, $did );
				print "added secondary door for room $cc_roomid at $xloc $yloc $zloc, doornum $doornum did $did\n" if $debug2;

				# update the floor/ceiling effect odds for the exit door location
				# my ($new_feffectlvl, $new_feffecttype) = ( geteffectodds( $cc_feffectlvl, $cc_feffecttype, 1 ));
				my ($new_feffectlvl, $new_feffecttype) = ( $cc_feffectlvl, $cc_feffecttype );
				my ($new_ceffectlvl, $new_ceffecttype) = ( $cc_ceffectlvl, $cc_ceffecttype );

				# update object thresholds for cell
				# setobjidx( $xmazepoint, $ymazepoint, $zmazepoint, $cc_objidx, $cc_objct );
				setobjvals( $xmazepoint, $ymazepoint, $zmazepoint, $cc_aobjthr, $cc_tobjthr );

				# get "door seal" value for door class
				my $doorseal = $doorclass[$doorclass][9];
				$doorseal = 0 if ( ! $doorseal );

				# get the non-feffectable flag for the door class and level class
				my ( $dvalid_b2, $doorspc_b2) = getdoorspcflag( $doorclass, 2 );

				# adjust floor effect level by door seal factor and non-feffectable flag settings
				if ( $doorspc_b2 ) {
					($new_feffectlvl, $new_feffecttype) = (0, 0);
					setfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, 0, 0 );
				} elsif ( $doorseal >= $cc_feffectlvl && $cc_feffectlvl != 0 ) {
					( $new_feffectlvl, $new_feffecttype ) = ( 0,0 );
					setfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, 0, 0 );
				} elsif ( $doorseal < $cc_feffectlvl && $doorseal != 0 ) {
					$new_feffectlvl = ( $cc_feffectlvl - $doorseal );
					# setfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, $new_feffectlvl, $new_feffecttype );
				};

				# set the maze point to the new location
				$xmazepoint = $xloc + $XDI;
				$ymazepoint = $yloc + $YDI;
				$zmazepoint = $zloc + $ZDI;

				# do not set a new hallid if we are opening a room-to-room passage
				my $room2id = getroomid( $xmazepoint, $ymazepoint, $zmazepoint );
				if ( ! $room2id ) {
					my $hallclass = gethalltype( $xloc, $yloc, $zloc, $checkdir );
					$hallid = addtohalllist( $hallclass, $xloc, $yloc, $zloc );

					# set hallway id on the old and new cells
					sethallid( $xloc, $yloc, $zloc, $hallid, 1, 0 );
					sethallid( $xmazepoint, $ymazepoint, $zmazepoint, $hallid, 0, 0 );

					$hallgstyle = genhallstyle( $xloc, $yloc, $zloc, $checkdir, 0 );
					sethallgstyle( $xloc, $yloc, $zloc, $hallgstyle );
					sethallgstyle( $xmazepoint, $ymazepoint, $zmazepoint, $hallgstyle );
				};

				# set distance attribute on new cell
				$distance += 1;
				setcelldist ($xmazepoint, $ymazepoint, $zmazepoint, $distance, $thread );

				# set floor/ceiling effect information on cell
				setfeffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, $new_feffectlvl, $new_feffecttype );
				setceffectlvl( $xmazepoint, $ymazepoint, $zmazepoint, $new_ceffectlvl, $new_ceffecttype );

				# determine if we need to place an object
				my ($new_aobjthr, $new_tobjthr, $new_objidx, $new_objct, $obj_match) =
					( getobjodds( $cc_aobjthr, $cc_tobjthr, $cc_objidx, $cc_objct, $cc_roomid ));

				# update object thresholds for cell
				setobjidx( $xmazepoint, $ymazepoint, $zmazepoint, $new_objidx, $new_objct ) if $obj_match;
				setobjvals( $xmazepoint, $ymazepoint, $zmazepoint, $new_aobjthr, $new_tobjthr );
			};
		};

		# check if we have to backtrack (first 1/2 of the backtrack routine)
		if ( $backtrackflag == 1) {

			print "backtrack at $xmazepoint $ymazepoint $zmazepoint\n" if $debug2;
			
			# decrement distance
			$distance -= 1;

			if ( $cc_roomid != 0 ) {
				# we are in a room.

				# check if we are backtracking from a secondary door
				my ($doorfound, $locdoor ) = lookupdoor( $xmazepoint, $ymazepoint, $zmazepoint );
				my ($srcx, $srcy, $srcz, $srcroom, $srcdoornum, $srcdir, $from, $did, $srcvalid, $srcclass ) =
					getdoorinfo( $locdoor ) if $doorfound;
				my ($XBL, $YBL, $ZBL, $priroom, $pridoornum, $pridir, $prifrom, $pridid, $privalid, $priclass ) =
					getdoorinfo( $from ) if $from;

				# backtrack to primary door
				if ( $from != 0 ) {
					print "backtrack from secondary door\n" if $debug2;
					
					# clear the backtrack field to prevent endless looping
					clearbacktrack( $xmazepoint, $ymazepoint, $zmazepoint );

					# move coordinates to primary room entrance.
					$xmazepoint = $XBL;
					$ymazepoint = $YBL;
					$zmazepoint = $ZBL;

					$hallid = gethallid( $xmazepoint, $ymazepoint, $zmazepoint );
					( $hallgstyle, $halllstyle ) = gethallstyle( $xmazepoint, $ymazepoint, $zmazepoint );
					
					# get backtrack direction field for primary entrance.
					$cc_backdir = getbacktrack( $xmazepoint, $ymazepoint, $zmazepoint );

					print "get backtrack $xmazepoint $ymazepoint $zmazepoint = $cc_backdir\n" if $debug2;

					# bypass the rest of the backtrack function and re-loop
					$backtrackflag = 0;
				};
			} else {
				# we are in a hallway.

				# record a dead-end, if applicable
				my $paths = 63 - ( $cc_paths & 63 );
				if ( $hallid && ( $paths == 1 || $paths == 2 || $paths == 4 || $paths == 8 || $paths == 16 || $paths == 32 )) {
					my $halldcount = $halldeadendctr[$hallid];
					print "recording hallid $hallid dead-end #$halldcount at $xmazepoint $ymazepoint $zmazepoint\n" if $debug2;
					$halldeadendlist[$hallid][$halldcount][0] = $xmazepoint;
					$halldeadendlist[$hallid][$halldcount][1] = $ymazepoint;
					$halldeadendlist[$hallid][$halldcount][2] = $zmazepoint;
					$halldeadendlist[$hallid][$halldcount][3] = 0;
					$halldeadendctr[$hallid] += 1;
				};

				# open the array cell
				openpath( $xmazepoint, $ymazepoint, $zmazepoint, 0, 3, 0 );

				# add traps as we backtrack through hallways.
				if ( $pittraps ) {
				    my $trap = gettrapodds();
				    settrap($xmazepoint, $ymazepoint, $zmazepoint, $trap, $distance, $thread);
				};
			};
		};

		# check if we have to backtrack (second 1/2 of the backtrack routine)
		if ( $backtrackflag == 1) {
			
			# get direction for backtrack
			my ( $XB, $YB, $ZB ) = getmazedirection($cc_backdir);
			print "backtrack direction $cc_backdir\n" if $debug2;

			# grab hallway special flag for this cell.
			my $ch_cellspc = getcellspc( $xmazepoint, $ymazepoint, $zmazepoint );

			# backtrack increases in distance if we are on a crossover or passthru point
			if ( $ch_cellspc >= 4 && $ch_cellspc <= 7 && ($ch_cellspc - $cc_backdir) == 3) {
				my $crossover = getcrossspan( $xmazepoint, $ymazepoint, $zmazepoint, $cc_backdir );
				$XB = ( ( $XB * $crossover ) + $XB );
				$ZB = ( ( $ZB * $crossover ) + $ZB );
			} elsif ( $ch_cellspc >= 36 && $ch_cellspc <= 39 && ($ch_cellspc - $cc_backdir) == 35) {
				my $passthru = getthruspan( $xmazepoint, $ymazepoint, $zmazepoint, $cc_backdir );
				$XB = ( ( $XB * $passthru ) + $XB );
				$ZB = ( ( $ZB * $passthru ) + $ZB );
			} elsif ( $ch_cellspc >= 44 && $ch_cellspc <= 47 ) {
				my ( $valid, $xendpt, $yendpt, $zendpt, $dynstair ) = getdsspan( $xmazepoint, $ymazepoint, $zmazepoint );
				$XB = ( $xendpt - $xmazepoint );
				$YB = ( $yendpt - $ymazepoint );
				$ZB = ( $zendpt - $zmazepoint );

				$cc_backdir = -1;
			};

			# clear the backtrack field to prevent endless looping
			clearbacktrack( $xmazepoint, $ymazepoint, $zmazepoint );

			# determine if we are backtracking from one room to another
			my $from_roomid = getroomid( $xmazepoint, $ymazepoint, $zmazepoint );
			my $to_roomid = getroomid( $xmazepoint+$XB, $ymazepoint+$YB, $zmazepoint+$ZB );

			# move point to backtrack location
			$xmazepoint += $XB;
			$ymazepoint += $YB;
			$zmazepoint += $ZB;

			#room-to-room backtrack - disable secondary door because it is redundant
			disabledoor( $xmazepoint, $ymazepoint, $zmazepoint ) if ( $from_roomid && $to_roomid && $from_roomid != $to_roomid);

			# if we backtrack from a hallway into a room, check if auto-removal of dead-ends is necessary for the hallway
			my ($hfound_b6, $hflag_b6) = gethallflag( $xmazepoint, $ymazepoint, $zmazepoint, 6 );
			my $halldcount = $halldeadendctr[$hallid];
			if ( $from_roomid == 0 && $to_roomid != 0 && $halldcount && $hflag_b6 ) {
				print "deadend removal for $hallid of $halldcount dead-ends\n" if $debug2;
				removedeadends( $hallid, $thread, 0 );
			};
			
			#check if we are back at the beginning of the maze, and set the stop flag if so.
			if ( $cc_backdir == 0 ) {
				$stopflag=1;
				setcelldist( $xmazepoint, $ymazepoint, $zmazepoint, $distance + 1, $thread );

				# print a warning if thread ended prematurely.
				my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) =
					getthreadinfo( $thread );
				if ( ( $xmazepoint != $OSTX ) || ( $ymazepoint != $OSTY ) || ( $zmazepoint != $OSTZ ) ) {
					print "Incomplete maze for thread $thread, ends at $xmazepoint $ymazepoint $zmazepoint";
					print " instead of $OSTX $OSTY $OSTZ\n";
				};
			};
		}
	    } while ( (!$stopflag) && (!$breakthread) );

	    # update current thread information
	    setthread( $thread, $xmazepoint, $ymazepoint, $zmazepoint, $distance, $stopflag );

	  print "End thread $thread at $xmazepoint $ymazepoint $zmazepoint\n" if $debug1;
	  }
	} while ( $livethreads );
};

#==============================================================================
# buildlabyrinth - labyrinth-building front-end for buildmaze

sub buildlabyrinth {

	my @prevdir;

	foreach my $ylevel ( 0..$ymazesize - 1 ) {
		my ( $valid_b12, $levelspc_b12) = getlevelflag( $ylevel, 12 );
		next if ! $levelspc_b12;

		# build maze for the labyrinth level
		buildmaze;

		# add dungeon-style gateways to the exit points of the labyrinth
		foreach my $thread ( 1 .. $totalthreads ) {
	
			my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) = getthreadinfo( $thread );
			$prevdir[$thread] = adddungeongate( $Y, 0, $thread ) if ( $Y == $ylevel );
		}

		# continue building the regular maze below the labyrinth
		buildmaze;

		# correct the doors on the dungeon gateways previously added on the labyrinth level
		foreach my $thread ( 1 .. $totalthreads ) {

			my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) = getthreadinfo( $thread );
			print "thread $thread $X $Y $Z st $STX $STY $STZ h $HDX $HDY $HDZ $HDST\n" if $debug2;

			# correct the door direction for the previous level
			if ( $prevdir[$thread] ) {

				my $odir = $prevdir[$thread];
				my ($dfound, $locdoor ) = lookupdoor( $X, $Y, $Z);
				$doorinfo[$locdoor][5]=$prevdir[$thread] if $dfound;
	
				my ( $XI, $YI, $ZI ) = getmazedirection($odir);
				setpath( $X, $Y, $Z, $odir );
				setipath( $X+$XI, $Y+$YI, $Z+$ZI, $odir );
			
			}
		}

		last;
	}
};

#==============================================================================
# builddungeon - dungeon-building front-end for buildmaze

sub builddungeon {

	my @prevdir;
	addrooms( 0, $ymazesize-1 );
	foreach my $ylevel ( $ystartlevel .. $ymazesize - 1 ) {

		# build maze for this dungeon level
		buildmaze;

		foreach my $thread ( 1 .. $totalthreads ) {
			my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) = getthreadinfo( $thread );
			print "thread $thread c $X $Y $Z st $STX $STY $STZ o $OSTX $OSTY $OSTZ\n" if ( $debug2 );

			# correct the door direction for the previous level
			if ( $prevdir[$thread] ) {
				my ($dfound, $locdoor ) = lookupdoor( $X, $Y, $Z);
				$doorinfo[$locdoor][5]=$prevdir[$thread] if $dfound;
				$prevdir[$thread] = 0;
			}
			next if $DEND;

			$prevdir[$thread] = adddungeongate( $ylevel, 0, $thread );
		}

	};
};

#==============================================================================
# secondary subroutines

#------------------------------------------------------------------------------
# adddungeongate - add dungeon gateway to level

sub adddungeongate {
	my ($ylevel, $extgate, $thread) = @_;

	$extgate = 0 if ! $extgate;
	$thread = 0 if ! $thread;

	print "adddungeongate called for Y $ylevel extgate $extgate thread $thread\n" if $debug1;

	# lookup the dungeon inter-level gateway and end room class types
	my ( $found_ilg, $ilgroom ) = scanforroomflag( 11 );
	my ( $found_der, $derroom ) = scanforroomflag( 12 );

	print "builddungeon: cannot locate dungeon gateway/end rooms\n" if ( ! $found_ilg || ! $found_der );
	return 0 if ( ! $found_ilg || ! $found_der );

	# initially set end point to high-distance location for thread.
	# my ( $highdistval, $xend, $yend, $zend ) = getthreadhighdist( $thread );
	my ( $highdistval, $xend, $yend, $zend ) = ( 0, 0, 0, 0);

	# find the farthest dead-end from the start to use as a gateway location
	# we could just use the x/y/zhighdist values, but they might be in a room
	my $deadendcount = getdeadends(2,$thread);
	my $found = 0;
	my ( $TX, $TY, $TZ, $distance, $end, $dend ) = getthread( $thread );
	
	$distance = 0;

	# keep track of the farthest dead-end from the start
	my ( $uxend, $uyend, $uzend, $udistance ) = ( 0, 0, 0, 0 );;

	foreach my $deadend ( 0..$deadendcount-1 ) {

		if ($deadendlist[$deadend][3] > $udistance) {
			# record the dead-end if it is the farthest
			$uxend = $deadendlist[$deadend][0];
			$uyend = $deadendlist[$deadend][1];
			$uzend = $deadendlist[$deadend][2];
			$udistance = $deadendlist[$deadend][3];
		}

		if ($deadendlist[$deadend][3] > $distance) {

			# skip checking the dead-end if it is on another level
			next if $deadendlist[$deadend][1] != $ylevel;

			# record the dead-end if it is the farthest on the same Y level
			$xend = $deadendlist[$deadend][0];
			$yend = $deadendlist[$deadend][1];
			$zend = $deadendlist[$deadend][2];
			$distance = $deadendlist[$deadend][3];
			$found = 1;
		}
	}

	if ( ! $found ) {
		# go back and use the farthest dead-end if we never found one on the same Y level
		$xend = $uxend;
		$yend = $uyend;
		$zend = $uzend;
		$distance = $udistance;

		# $TX = $uxend;
		# $TY = $uyend;
		# $TZ = $uzend;
	};

	# an optional second arg can be used to set the gate depth
	my $depth = 2;
	$depth = $extgate if ($extgate);

	# track the direction of the entry door
	my $prevdir = 0;

	if ( $ylevel < $ymazesize - 1 && $found ) {

		# grab the horizontal wall pattern of the ending cell so we can replace the door
		my $ilgpath = (getpathflags( $xend, $yend, $zend ) & 15);

		# add inter-level gateway room
		my $room = addrooment( $xend, $yend, $zend, 1, $depth, 1, $ilgroom );
		buildroom( $room, $ilgroom ) if ($room);

		# re-open the doorway into the top level of the inter-level gateway room
		for my $opendir ( 0..3 ) {
			my $dirbit = (($ilgpath >> $opendir)&1);
			openpath( $xend, $yend, $zend, ($opendir+1), 1, 0 ) if ! $dirbit;
			$prevdir = ( $opendir + 1) if ! $dirbit;
		}

		print "ilgpath $ilgpath prevdir $prevdir\n" if $debug2;

		# reset start coordinates to new location
		$startinroom = 0;

		# reset the distance if we couldn't find a deadend and are using x/y/zhighdist
		if ( ! $found ) {
			$distance = $highdistval;

			# if we are blocked from adding another gateway, add an ending.
			my $lowercelluse = getcelluse( $TX, $TY + 1, $TZ );

			if ( $lowercelluse ) {
				adddungeonend( $thread, $TX, $TY, $TZ, $distance, 1 );
			};
		}

		$threadinfo[$thread][ 4] = $distance;
		$threadinfo[$thread][ 5] = $xend;
		$threadinfo[$thread][ 6] = $yend;
		$threadinfo[$thread][ 7] = $zend;
	} else {
		adddungeonend( $thread, $TX, $TY, $TZ, $xend, $yend, $zend, $distance, $end );

		# grab the horizontal wall pattern of the ending cell so we can replace the door
		# my $epath = (getpathflags( $xend, $yend, $zend ) & 15);

		# add in the ending room.
		# my $room = addrooment( $xend, $yend, $zend, 1, 1, 1, $derroom );
		# buildroom( $room, $derroom ) if ( $room );

		# set the thread as non-live.
		# setthread ( $thread, $TX, $TY, $TZ, $distance, $end, 1 );

		# re-open the doorway into the top level of the inter-level gateway room
		# for my $opendir ( 0..3 ) {
		# 	my $dirbit = (($epath >> $opendir)&1);
		# 	next if $dirbit;
		# 	openpath( $xend, $yend, $zend, ($opendir+1), 1, 0 );
		# 	my $doorclass = getdoortype( $room, $xend, $yend, $zend, ($opendir+1) );
		# 	my $door = addtodoorlist( $room, $xend, $yend, $zend, ($opendir+1), 1, $doorclass, 0 );
		# 	setprimarydoor( $room, $xend, $yend, $zend, $door );
		# }
	}

	return( $prevdir );
};

#------------------------------------------------------------------------------
# adddungeonend - add dungeon end to level

sub adddungeonend {

	my ( $thread, $TX, $TY, $TZ, $xend, $yend, $zend, $distance, $end ) = @_;

	my ( $found_der, $derroom ) = scanforroomflag( 12 );

	# my ( $highdistval, $xend, $yend, $zend ) = getthreadhighdist( $thread );


	# grab the horizontal wall pattern of the ending cell so we can replace the door
	my $epath = (getpathflags( $xend, $yend, $zend ) & 15);

	# add in the ending room.
	my $room = addrooment( $xend, $yend, $zend, 1, 1, 1, $derroom );
	buildroom( $room, $derroom ) if ( $room );

	# set the thread as non-live.
	setthread ( $thread, $TX, $TY, $TZ, $distance, $end, 1 );

	# re-open the doorway into the top level of the inter-level gateway room
	for my $opendir ( 0..3 ) {
		my $dirbit = (($epath >> $opendir)&1);
		next if $dirbit;
		openpath( $xend, $yend, $zend, ($opendir+1), 1, 0 );
		my $doorclass = getdoortype( $room, $xend, $yend, $zend, ($opendir+1) );
		my $door = addtodoorlist( $room, $xend, $yend, $zend, ($opendir+1), 1, $doorclass, 0 );
		setprimarydoor( $room, $xend, $yend, $zend, $door );
	}
}

#------------------------------------------------------------------------------
# addinteriors - add random room interiors to rooms which allow it

sub addinteriors {

	# set the door-related room attribute bits
	if ( $totaldoors > 0 ) {
	    foreach my $door ( 1 .. $totaldoors ) {
		my ($X, $Y, $Z, $roomid, $doornum, $backdir, $from, $did, $valid, $dclass ) = getdoorinfo( $door );
		next if !$valid;

		# skip hall-to-hall doorways
		# next if ( ! $roomid );

		my $iroomid = getroomid( $X, $Y, $Z );

		my ( $XI, $YI, $ZI ) = getmazedirection( $backdir );
		my $oroomid = getroomid( $X+$XI, $Y+$YI, $Z+$ZI );

		# check both sides of the door
		for my $pass ( 1 .. 2 ) {

			my $roomid = $iroomid;
			my ( $XN, $YN, $ZN ) = ( $X, $Y, $Z );
			my ( $XR, $YR, $ZR ) = ( $X+$XI, $Y+$YI, $Z+$ZI );

			if ( $pass == 2 ) {
				$roomid = $oroomid;
				( $XN, $YN, $ZN, $XR, $YR, $ZR ) = ( $XR, $YR, $ZR, $XN, $YN, $ZN );
			};

			# skip if this side of door is not inside a room
			next if ( ! $roomid );

			# get the door attributes
			my ( $dvalid_b13, $doorspc_b13) = getdoorspcflag( $dclass, 13 );
			my ( $dvalid_b14, $doorspc_b14) = getdoorspcflag( $dclass, 14 );
			my ( $dvalid_b15, $doorspc_b15) = getdoorspcflag( $dclass, 15 );
			my ( $dvalid_b16, $doorspc_b16) = getdoorspcflag( $dclass, 16 );
			my ( $dvalid_b19, $doorspc_b19) = getdoorspcflag( $dclass, 19 );
			my ( $dvalid_b20, $doorspc_b20) = getdoorspcflag( $dclass, 20 );
	
			# get hallway/cell/room attributes
			my $segment = getsegment( $XN, $YN, $ZN );
			my $roomspc = getroomspc( $roomid );
			my $hallid = gethallid( $XN, $YN, $ZN );
			my ( $valid_b29, $hallspc_b29 ) = gethallflag( $XN, $YN, $ZN, 29 );
			my ( $valid_b47, $hallspc_b47 ) = gethallflag( $XN, $YN, $ZN, 47 );
	        	my ( $valid_b63, $roomspc_b63) = getroomspcflag( $roomspc, 63 );

			# set room attribute bits based on the cell attributes
			setroomattrib( $roomid, 16 ) if ( $segment & 32 );
			setroomattrib( $roomid, 17 ) if ( ( $segment & 32 ) == 0 );
	
			print "addinteriors pass $pass / $XN $YN $ZN room $roomid hallid $hallid\n" if ( $debug3 );
	
			if ( $roomspc_b63 && $doorspc_b20 && $hallspc_b29 && $hallspc_b47 ) {
				setcellspc( $XN, $YN, $ZN, 64 );
			} elsif ( $roomspc_b63 && $doorspc_b20 && $hallspc_b29 ) {
				setcellspc( $XN, $YN, $ZN, 65 );
			};
	
			my $halltype = gethallinfo( $XN, $YN, $ZN, 1, 41 );
			my $floor = ( $segment & 32 );
	
			# set room attribute bits based the door attribute bits
			setroomattrib( $roomid, 18 ) if ( $doorspc_b13 );
			setroomattrib( $roomid, 19 ) if ( $doorspc_b16 );
			if ( $floor ) {
				setroomattrib( $roomid, 32 ) if ( $doorspc_b14 );
				setroomattrib( $roomid, 33 ) if ( $doorspc_b15 );
				setroomattrib( $roomid, 34 ) if ( $doorspc_b20 );
				setroomattrib( $roomid, 35 ) if ( $doorspc_b19 || $doorspc_b13 );
			} else {
				setroomattrib( $roomid, 36 ) if ( $doorspc_b14 );
				setroomattrib( $roomid, 37 ) if ( $doorspc_b15 );
				setroomattrib( $roomid, 38 ) if ( $doorspc_b20 );
				setroomattrib( $roomid, 39 ) if ( $doorspc_b19 || $doorspc_b13 );
			};
	
			# set room attribute bits based on the hallway attribute bits
			setroomattrib( $roomid, 24 ) if ( $halltype == 2 );
			setroomattrib( $roomid, 25 ) if ( $halltype == 3 );
			setroomattrib( $roomid, 26 ) if ( $halltype == 1 );
			setroomattrib( $roomid, 27 ) if ( $halltype == 4 );
			setroomattrib( $roomid, 40 ) if ( $doorspc_b20 && $hallspc_b29 && ( ! $hallspc_b47 ) && ( $segment & 32 ) );
			setroomattrib( $roomid, 41 ) if ( $doorspc_b20 && $hallspc_b29 && ( ! $hallspc_b47 ) && (( $segment & 32 ) == 0 ) );
			setroomattrib( $roomid, 42 ) if ( $doorspc_b20 && $hallspc_b29 && $hallspc_b47 && ( $segment & 32 ) );
			setroomattrib( $roomid, 43 ) if ( $doorspc_b20 && $hallspc_b29 && $hallspc_b47 && (( $segment & 32 ) == 0 ) );
	    	};
	    };
	};
	
	if ( $totalrooms > 0 ) {
	    foreach my $room ( 1..$totalrooms ) {
	        my $roomspc = getroomspc( $room );

		# check the room flag indicating that we want to use interiors
	        my ( $valid_b63, $roomspc_b63) = getroomspcflag( $roomspc, 63 );
		next if ( ! $roomspc_b63 );

		my $class = getinteriortype( $room );

		# set room name to match interior name
		$roominfo[$room][16]=$interiorclass[$class][0] if ( $class );

		# set interior class for room
		$roominfo[$room][17]=$class if ( $class );
	    };
	};
};

#------------------------------------------------------------------------------
# mazecleanup - perform any post-construction cleanup routines

sub mazecleanup {
	print "mazecleanup started\n" if $debug1;

	# convert bit 38-flagged rooms to hallways
	if ( $totalrooms > 0 ) {
	    foreach my $room ( 1..$totalrooms ) {
	        my $roomspc = getroomspc( $room );
	        my ( $valid_b38, $roomspc_b38) = getroomspcflag( $roomspc, 38 );
		next if ( ! $roomspc_b38 );

		print "converting room $room to hallway\n";

		# get the bounding box of the room
		my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $room );

		my $xfc=( $xc+$xs-1 );
		my $yfc=( $yc+$ys-1 );
		my $zfc=( $zc+$zs-1 );

		# get the conversion hall class name
		my $reqhqname = $roomclass[ $roomspc ][20];
		print "reqhqname for roomspc $roomspc is $reqhqname\n";

		my $hallid = 0;
		my $hallclass = 0;
		
		foreach my $hclassnum ( 0..$maxhallclass ) {

		    # skip this class if it is not valid
		    next if ! $hallclass[$hclassnum][0][0];

		    # skip this class if we do not have a name match
		    next if ( "$reqhqname" ne "$hallclass[$hclassnum][0][0]" );

		    $hallclass = $hclassnum;
		    last;
		};

		# create a new hallway ID to use for this room
		$hallid = addtohalllist( $hallclass, $xe, $ye, $ze ) if ( ! $hallid );

		# abort this change if we couldn't allocate a valid hallway ID
		last if ( ! $hallid );

		# clear room flag and set hallid for each room cell
          	foreach my $yinc ($yc .. $yfc) {
          	    foreach my $xinc ($xc .. $xfc) {
            		foreach my $zinc ($zc .. $zfc) {
				next if ( $room != getroomid( $xinc, $yinc, $zinc ));

				sethallid( $xinc, $yinc, $zinc, $hallid, 0, 0 );
				setroomid( $xinc, $yinc, $zinc, 0 );
			}
		    }
		}

		# clear the room flag on any doors associated with this room
		foreach my $door ( 1 .. $totaldoors ) {
			my ($x, $y, $z, $roomnum, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );
			next if !$valid;
			next if ( $roomnum != $room );
			$doorinfo[$door][0]=0;
		};
	    };
	};

	# clear all door flags
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yinc ( 0..$ymazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {
			cleardoorflag( $xinc, $yinc, $zinc, 0 );
		}
	    }
	}

	# re-enable the door flags for enabled doors listed in door list, if any, and open segments for bit-20 enabled doors.
	if ( $totaldoors > 0 ) {
		foreach my $door ( 1 .. $totaldoors ) {
			my ($x, $y, $z, $roomnum, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );
			next if !$valid;

			my ( $dvalid_b20, $doorspc_b20) = getdoorspcflag( $doorclass, 20 );
			if ( $doorspc_b20 ) {
				# my ( $iroomclass, $ihallclass, $oroomclass, $ohallclass ) = ( 0,0,0,0 );
				my ( $isegment, $osegment, $isetname, $osetname );
				my ( $ihallid, $ohallid );

				# get the inside-door room/hall class and dataset name
				if ( ! $roomnum ) {
					# $ihallclass = gethallinfo( $x, $y, $z, 0, 0);
					$isegment = getsegment( $x, $y, $z );
					$isetname = gethallinfo( $x, $y, $z, 1, 18);
					$isetname = '' if ( ! $isetname );
					$ihallid = gethallid( $x, $y, $z );
				}

				# get the outside-door room/hall class and dataset name
				my ( $XI, $YI, $ZI ) = getmazedirection( $dir );

				# neutralize strange diagonal lookups for the outside of doors
				$YI = 0 if $dir >= 8;

				my $oroomnum = getroomid( $x + $XI, $y + $YI, $z + $ZI );
				if ( ! $oroomnum ) {
					# $ohallclass = gethallinfo( $x+$XI, $y+$YI, $z+$ZI, 0, 0);
					$osegment = getsegment( $x+$XI, $y+$YI, $z+$ZI );
					$osetname = gethallinfo( $x+$XI, $y+$YI, $z+$ZI, 1, 18);
					$osetname = '' if ( ! $osetname );
					$ohallid = gethallid( $x+$XI, $y+$YI, $z+$ZI );
				};

				# clear the segments if either side is a hallway
				my ( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($dir);
				setsegment( $x, $y, $z, ( $isegment | $sfdirmask ) ^ $sfdirmask ) if ( $ihallid );
				setsegment( $x+$XI, $y+$YI, $z+$ZI, ( $osegment | $srdirmask ) ^ $srdirmask ) if ( $ohallid );
				my $ifev = getfev( $x, $y, $z );
				my $ofev = getfev( $x+$XI, $y+$YI, $z+$ZI );
				print "ohw at $x $y $z, hallset $isetname ifev $ifev ofev $ofev\n" if ( $ihallid && $debug2 );
				print "ohw at $x $y $z dir $dir, hallset $osetname ifev $ifev ofev $ofev\n" if ( $ohallid && $debug2 );
			};

			$mazegrid[$x][$y][$z] = ($mazegrid[$x][$y][$z] | $doormask);
		};
	};

	# update the ledge bitmap to indicate cells below door entrances in rooms.
	if ( $totalrooms > 0 ) {
	    foreach my $room ( 1 .. $totalrooms ) {
		my ($xc, $yc, $zc, $xs, $ys, $zs) = getroompos( $room );
		
		# skip the room if it is only single-level
		next if $ys == 1 ;
		
		my $xfc=( $xc+$xs-1 );
		my $yfc=( $yc+$ys-1 );
		my $zfc=( $zc+$zs-1 );
          	foreach my $xinc ($xc .. $xfc) {
            	    foreach my $zinc ($zc .. $zfc) {
			my $ledge = 0;
			foreach my $yinc (0 .. $ys-1) {
				next if ( $room != getroomid( $xinc, $yinc, $zinc ));
				my $yiinc = $yinc;
				$yiinc = ( $yfc - $yinc ) if ( $invertlevels );
				
				setledgeflag ( $xinc, $yiinc, $zinc ) if $ledge == 1;
				clearledgeflag ( $xinc, $yiinc, $zinc ) if $ledge == 0;
				my $doorflag = getdoorflag ( $xinc, $yiinc, $zinc );
				$ledge = 1 if $doorflag == 1;
			};
		    };
		};
	    };
	};

	# update room floor/ceiling effects
	if ( $totalrooms > 0 ) {
		foreach my $room ( 1 .. $totalrooms ) {
		    my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $room );
		    my ($feffectlvl, $feffecttype) = getfeffectlvl( $xe, $ye, $ze );
		    my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xe, $ye, $ze );

		    my $xfc=( $xc+$xs-1 );
		    my $yfc=( $yc+$ys-1 );
		    my $zfc=( $zc+$zs-1 );

		    # clear f/c effect cells in room
          	    foreach my $yinc ($yc .. $yfc) {
          		foreach my $xinc ($xc .. $xfc) {
            		    foreach my $zinc ($zc .. $zfc) {
				next if ( $room != getroomid( $xinc, $yinc, $zinc ));
				setfeffectlvl( $xinc, $yinc, $zinc, 0, 0 );
				setceffectlvl( $xinc, $yinc, $zinc, 0, 0 );
			    }
			}
		    }

		    # skip room if it does not have a floor effect
		    next if !$feffectlvl;

		    # skip room if it is not allowed to have a floor effect
		    my $roomspc = getroomspc( $room );
		    my ( $valid_b6, $roomspc_b6) = getroomspcflag( $roomspc, 6 );
		    next if $roomspc_b6;

		    # set floor/ceiling effect cells for room locations with floor/ceiling segments
		    foreach my $yinc ($yc .. $yfc) {
          		foreach my $xinc ($xc .. $xfc) {
            		    foreach my $zinc ($zc .. $zfc) {
				next if ( $room != getroomid( $xinc, $yinc, $zinc ));
				my $segment = getsegment( $xinc, $yinc, $zinc );
				setfeffectlvl( $xinc, $yinc, $zinc, $feffectlvl, $feffecttype ) if ( $segment & 32 );
				setceffectlvl( $xinc, $yinc, $zinc, $ceffectlvl, $ceffecttype ) if ( $segment & 16 );
			    }
			}
		    }
		}
	}

	# process hallways with bit 25 open upper cell or bit 26 open lower cell flag enabled
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yrinc ( 1..$ymazesize ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {
			my $yinc = ( $ymazesize - $yrinc );

			# get information about this cell
			my ( $valid_b25, $hallspc_b25 ) = gethallflag( $xinc, $yinc, $zinc, 25 );
			my ( $valid_b31, $hallspc_b31 ) = gethallflag( $xinc, $yinc, $zinc, 31 );

			# skip this cell if flag is not enabled
			next if ( ! $hallspc_b25 );

			# skip this cell if it belongs to a room
			my $roomid = getroomid( $xinc, $yinc, $zinc );
			next if ( $roomid );

			# skip this cell if it has a cellspc flag set
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			next if ( $cellspc );

			my $hallid = gethallid( $xinc, $yinc, $zinc );
			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $segment = getsegment( $xinc, $yinc, $zinc );
			my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
			$hallid = $hclass if ( $hallspc_b31 );

			next if ( ! checkbounds( $xinc, $yinc-1, $zinc ));

			# skip this cell if it already has an open ceiling
			next if (( $segment & 16 ) == 0 );

			# skip this cell if upper cell is in a room
			my $roomid2 = getroomid( $xinc, $yinc-1, $zinc );
			next if ( $roomid2 );

			# skip this cell if it has a cellspc flag set
			my $cellspc2 = getcellspc( $xinc, $yinc-1, $zinc );
			next if ( $cellspc2 );

			# skip this cell if upper cell is a different hall id.
			my $hallid2 = gethallid( $xinc, $yinc-1, $zinc );
			my $hclass2 = gethallinfo( $xinc, $yinc-1, $zinc, 0, 0);
			$hallid2 = $hclass2 if ( $hallspc_b31 );
			next if ( $hallid2 != $hallid );

			# skip this cell if upper cell already has a VHE setting.
			my $vheflags2 = getvhe( $xinc, $yinc-1, $zinc );
			next if ( $vheflags2 );

			# skip this cell if it is already a maxxed-out upper VHE
			next if ( $vheflags == 0b001 );

			# open upper segment
			openpath( $xinc, $yinc, $zinc, 5, 1, 0 );

			my $newseg = getsegment( $xinc, $yinc, $zinc );
			print "b25 on $xinc $yinc $zinc segment $segment -> $newseg\n" if (( $segment == $newseg ) && $debug2 );

			# adjust the VHE flags
			if ( $vheflags ) {
				setvhe( $xinc, $yinc-1, $zinc, $vheflags - 1 );
			} else {
				setvhe( $xinc, $yinc, $zinc, 0b100 );
				setvhe( $xinc, $yinc-1, $zinc, 0b011 );
			};
		};
	    };
	};

	# process hallways with bit 26 open lower cell flag enabled
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yinc ( 0..$ymazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {

			# get information about this cell
			my ( $valid_b26, $hallspc_b26 ) = gethallflag( $xinc, $yinc, $zinc, 26 );
			my ( $valid_b31, $hallspc_b31 ) = gethallflag( $xinc, $yinc, $zinc, 31 );

			# skip this cell if neither flag is enabled
			next if ( ! $hallspc_b26 );

			# skip this cell if it belongs to a room
			my $roomid = getroomid( $xinc, $yinc, $zinc );
			next if ( $roomid );

			# skip this cell if it has a cellspc flag set
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			next if ( $cellspc );

			my $hallid = gethallid( $xinc, $yinc, $zinc );
			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $segment = getsegment( $xinc, $yinc, $zinc );
			my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);

			next if ( ! checkbounds( $xinc, $yinc+1, $zinc ));

			# skip this cell if it already has an open floor
			next if (( $segment & 32 ) == 0 );

			# skip this cell if lower cell is in a room
			my $roomid2 = getroomid( $xinc, $yinc+1, $zinc );
			next if ( $roomid2 );

			# skip this cell if it has a cellspc flag set
			my $cellspc2 = getcellspc( $xinc, $yinc+1, $zinc );
			next if ( $cellspc2 );

			# skip this cell if lower cell is a different hall id.
			my $hallid2 = gethallid( $xinc, $yinc+1, $zinc );
			my $hclass2 = gethallinfo( $xinc, $yinc+1, $zinc, 0, 0);
			$hallid2 = $hclass2 if ( $hallspc_b31 );
			next if ( $hallid2 != $hallid );

			# skip this cell if lower cell already has a VHE setting.
			my $vheflags2 = getvhe( $xinc, $yinc+1, $zinc );
			next if ( $vheflags2 );

			# skip this cell if it is already a maxxed-out lower VHE
			next if ( $vheflags == 0b111 );

			# open lower segment
			openpath( $xinc, $yinc, $zinc, 6, 1, 0 );

			my $newseg = getsegment( $xinc, $yinc, $zinc );
			print "b26 on $xinc $yinc $zinc segment $segment -> $newseg\n" if (( $segment == $newseg ) && $debug2 );

			# adjust the VHE flags
			if ( $vheflags ) {
				setvhe( $xinc, $yinc+1, $zinc, $vheflags + 1 );
			} else {
				setvhe( $xinc, $yinc, $zinc, 0b100 );
				setvhe( $xinc, $yinc+1, $zinc, 0b101 );
			};
		};
	    };
	};

	# perform hallway cell replacement for unmined areas
	removedeadends( 0, 0, 1 );

	# process hallways with bit 7 open adjacent cell flag or unmined flag enabled
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yinc ( 0..$ymazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {

			# get information about this cell
			my $hallid = gethallid( $xinc, $yinc, $zinc );
			my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
			my ( $valid_b7, $hallspc_b7 ) = gethallflag( $xinc, $yinc, $zinc, 7 );
			my ( $valid_b31, $hallspc_b31 ) = gethallflag( $xinc, $yinc, $zinc, 31 );
			my $umflag = getumflag( $xinc, $yinc, $zinc );
			my $segment = getsegment( $xinc, $yinc, $zinc );
			my $roomid = getroomid( $xinc, $yinc, $zinc );
			$hallid = $hclass if ( $hallspc_b31 );
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );

			# skip this cell if it doesn't have hall class special bit 7 or the umflag set.
			next if ( ! $hallspc_b7 && ! $umflag );

			# skip this cell if it belongs to a room
			next if ( $roomid );

			# skip this cell if it belongs to a dynamic stair
			next if ( ( $cellspc >= 40 ) && ( $cellspc <= 63 ) );

			my ( $adjhclass, $adjhallid, $adjroomid, $valid, $hseg, $vseg, $adjvseg, $adjcellspc );

			# open walls between this hallways adjacent cells
			for my $dir ( 1, 2, 4, 8 ) {

				my $pathval = $dir;
				$pathval = 3 if $dir == 4;
				$pathval = 4 if $dir == 8;

				my ( $adjx, $adjz ) = ( $xinc, $zinc );
				$adjx -= 1 if ( $dir == 1 );
				$adjx += 1 if ( $dir == 2 );
				$adjz -= 1 if ( $dir == 4 );
				$adjz += 1 if ( $dir == 8 );

				if ( $segment & $dir ) {
					$valid = checkbounds( $adjx, $yinc, $adjz );
					if ( $valid ) {
						$adjhallid = gethallid( $adjx, $yinc, $adjz );
						$adjhclass = gethallinfo( $adjx, $yinc, $adjz, 0, 0);
						$adjroomid = getroomid( $adjx, $yinc, $adjz );
						my $adjumflag = getumflag( $adjx, $yinc, $adjz );
						$adjhallid = $adjhclass if ( $hallspc_b31 );
						$adjcellspc = getcellspc( $adjx, $yinc, $adjz );

						# skip this adjacent cell if it is part of a dynamic stair
						next if ( ( $adjcellspc >= 40 ) && ( $adjcellspc <= 63 ) );
	
						if ( $umflag ) {
							if ( $adjumflag ) {
								openpath( $xinc, $yinc, $zinc, $pathval, 1, 0 );
							};
						} elsif ( $adjhallid == $hallid && $adjroomid == 0 ) {
							openpath( $xinc, $yinc, $zinc, $pathval, 1, 0 );
	
							# look for any adjacent open floors/ceilings which need walls opened
							for my $yrext ( 1 .. 3 ) {
								my $yext = $yinc - $yrext;
								last if ( $yext < 0 );
								$vseg = getsegment( $xinc, $yext, $zinc ) & 32;
								$adjvseg = getsegment( $adjx, $yext, $adjz ) & 32;
								$hseg = getsegment( $xinc, $yext, $zinc ) & $dir;
								next if ! $hseg;
								last if ($vseg || $adjvseg );
								openpath( $xinc, $yext, $zinc, $pathval, 1, 0 );
								print "mazecleanup: open upper path at $xinc $yext $zinc dir $pathval\n" if $debug2;
							};
							for my $yext ( $yinc+1 .. $yinc+3 ) {
								last if ( $yext >= $ymazesize );
								$vseg = getsegment( $xinc, $yext, $zinc ) & 16;
								$adjvseg = getsegment( $adjx, $yext, $adjz ) & 16;
								$hseg = getsegment( $xinc, $yext, $zinc ) & $dir;
								next if ! $hseg;
								last if ( $vseg || $adjvseg );
								openpath( $xinc, $yext, $zinc, $pathval, 1, 0 );
								print "mazecleanup: open lower path at $xinc $yext $zinc dir $pathval\n" if $debug2;
							};
						};
					}
				};
			}
		}
	    }
	}

	# correct any wall inconsistencies between one horizontal pair of walls versus the pair above or below it
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yinc ( 0..$ymazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {

			# get information about this cell
			my $hallid = gethallid( $xinc, $yinc, $zinc );
			my $segment = getsegment( $xinc, $yinc, $zinc );
			my $roomid = getroomid( $xinc, $yinc, $zinc );
			# my ( $valid_b7, $hallspc_b7 ) = gethallflag( $xinc, $yinc, $zinc, 7 );

			# only bit 7-enabled hallways will have issues requiring this check
			# next if ( ! $hallspc_b7 );

			# skip this cell if it belongs to a room
			next if ( $roomid );

			# check adjacent cells
			for my $dir ( 1, 2, 4, 8 ) {

				my $pathval = $dir;
				$pathval = 3 if $dir == 4;
				$pathval = 4 if $dir == 8;

				my ( $adjx, $adjz ) = ( $xinc, $zinc );
				$adjx -= 1 if ( $dir == 1 );
				$adjx += 1 if ( $dir == 2 );
				$adjz -= 1 if ( $dir == 4 );
				$adjz += 1 if ( $dir == 8 );

				if (! ( $segment & $dir )) {
					my $valid = checkbounds( $adjx, $yinc, $adjz );
					if ( $valid ) {
						my $adjhallid = gethallid( $adjx, $yinc, $adjz );
						my $adjroomid = getroomid( $adjx, $yinc, $adjz );
						my $adjsegment = getsegment( $adjx, $yinc, $adjz );
						my $usegment = getsegment( $xinc, $yinc-1, $zinc );
						my $dsegment = getsegment( $xinc, $yinc+1, $zinc );
	
						if ( $adjhallid == $hallid && $adjroomid == 0 ) {
							if ( ( ($segment & 16) == 0 ) && ( ($adjsegment & 16 ) == 0 ) ) {
								if ( $usegment & $dir ) {
									print "usegment openpath for $xinc $yinc $zinc dir $pathval\n" if $debug2;
									openpath( $xinc, $yinc-1, $zinc, $pathval, 1, 0 );
								};
							};
							if ( ( ($segment & 32) == 0 ) && ( ($adjsegment & 32 ) == 0 ) ) {
								if ( $dsegment & $dir ) {
									print "dsegment openpath for $xinc $yinc $zinc dir $pathval\n" if $debug2;
									openpath( $xinc, $yinc+1, $zinc, $pathval, 1, 0 );
								};
							};
						};
					};
				};
			};
		};
	    };
	};

	# correct any diagonal path bits for VHE cells
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yinc ( 0..$ymazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {
			my ( $diagvalid, $diagpath ) = getdiagpath( $xinc, $yinc, $zinc );
			next if ( ! $diagvalid || ! $diagpath );

			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $segment = getsegment( $xinc, $yinc, $zinc );

			if ( $vheflags && (($segment & 32) == 0 )) {
				cleardiagpath( $xinc, $yinc, $zinc );
				setdiagpath( $xinc, $yinc + 1, $zinc );
			};
		}
	    }
	};
			

	# look for 'pillars' to use for potential architectural enhancements.
	foreach my $xinc ( 0..$xmazesize-2 ) {
	    foreach my $zinc ( 0..$zmazesize-2 ) {
		foreach my $yrinc ( 1..$ymazesize ) {
			# start from the bottom level and work straight upwards
			my $yinc = ( $ymazesize - $yrinc );

			# get information about this cell
			my ( $valid_b31, $hallspc_b31 ) = gethallflag( $xinc, $yinc, $zinc, 31 );

			# skip this cell if it doesn't have hall class special bit 7 set.
			my ( $valid_b7, $hallspc_b7 ) = gethallflag( $xinc, $yinc, $zinc, 7 );
			next if ( ! $hallspc_b7 );

			# skip this cell if it belongs to a room
			my $roomid_nw = getroomid( $xinc, $yinc, $zinc );
			next if ( $roomid_nw );

			# verify that pillar is clear on all sides
			my $segment_nw = getsegment( $xinc, $yinc, $zinc );
			my $segment_ne = getsegment( $xinc+1, $yinc, $zinc );
			my $segment_sw = getsegment( $xinc, $yinc, $zinc+1 );
			my $segment_se = getsegment( $xinc+1, $yinc, $zinc+1 );
			next if ( $segment_nw & 10 || $segment_se & 5 );

			my ( $cmp_nw, $cmp_ne, $cmp_sw, $cmp_se );
			if ( $hallspc_b31 ) {
				# use hall class for comparison if bit 31 is set.
				$cmp_nw = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				$cmp_ne = gethallinfo( $xinc+1, $yinc, $zinc, 0, 0);
				$cmp_sw = gethallinfo( $xinc, $yinc, $zinc+1, 0, 0);
				$cmp_se = gethallinfo( $xinc+1, $yinc, $zinc+1, 0, 0);
			} else {
				# use hallid for comparison if bit 31 is not set.
				$cmp_nw = gethallid( $xinc, $yinc, $zinc );
				$cmp_ne = gethallid( $xinc+1, $yinc, $zinc );
				$cmp_sw = gethallid( $xinc, $yinc, $zinc+1 );
				$cmp_se = gethallid( $xinc+1, $yinc, $zinc+1 );
			};

			# skip if one or more adjacent cells are a different hall id
			next if ( $cmp_ne != $cmp_nw || $cmp_sw != $cmp_nw || $cmp_se != $cmp_nw );

			# skip if one or more adjacent cells are part of a room
			my $roomid_ne = getroomid( $xinc+1, $yinc, $zinc );
			my $roomid_sw = getroomid( $xinc, $yinc, $zinc+1 );
			my $roomid_se = getroomid( $xinc+1, $yinc, $zinc+1 );
			next if ( $roomid_ne || $roomid_sw || $roomid_se );

			# skip if one or more adjacent cells are vhe extensions (which will not produce true pillars)
			my $vheflags_ne = getvhe( $xinc+1, $yinc, $zinc );
			my $vheflags_sw = getvhe( $xinc, $yinc, $zinc+1 );
			my $vheflags_se = getvhe( $xinc+1, $yinc, $zinc+1 );

			# get the surrounding floor/ceiling effect info
			my ($feffectlvl_nw, $feffecttype_nw) = getfeffectlvl( $xinc, $yinc, $zinc );
			my ($feffectlvl_ne, $feffecttype_ne) = getfeffectlvl( $xinc+1, $yinc, $zinc );
			my ($feffectlvl_sw, $feffecttype_sw) = getfeffectlvl( $xinc, $yinc, $zinc+1 );
			my ($feffectlvl_se, $feffecttype_se) = getfeffectlvl( $xinc+1, $yinc, $zinc+1 );

			# determine which vhe extensions are common across all four quadrants.
			# my $vheflags_all = ( $vheflags_nw & $vheflags_ne & $vheflags_sw & $vheflags_se );

			# determine if we can remove the pillar
			# my $vheflags_any = ( $vheflags_nw | $vheflags_ne | $vheflags_sw | $vheflags_se );
			my ( $valid_b20, $hallspc_b20 ) = gethallflag( $xinc, $yinc, $zinc, 20 );

			# build a bit pattern of floor/ceiling openings
			my $opattern = 0;
			$opattern = $opattern | 0x01 if (($segment_nw & 16) == 0);
			$opattern = $opattern | 0x02 if (($segment_ne & 16) == 0);
			$opattern = $opattern | 0x04 if (($segment_sw & 16) == 0);
			$opattern = $opattern | 0x08 if (($segment_se & 16) == 0);
			$opattern = $opattern | 0x10 if (($segment_nw & 32) == 0);
			$opattern = $opattern | 0x20 if (($segment_ne & 32) == 0);
			$opattern = $opattern | 0x40 if (($segment_sw & 32) == 0);
			$opattern = $opattern | 0x80 if (($segment_se & 32) == 0);

			$feffectlvl_nw = 0 if ( $opattern && 0x01 != 0x01 );
			$feffectlvl_ne = 0 if ( $opattern && 0x02 != 0x02 );
			$feffectlvl_sw = 0 if ( $opattern && 0x04 != 0x04 );
			$feffectlvl_se = 0 if ( $opattern && 0x08 != 0x08 );

			# determine if a floor effect should extend into the clear pillar area
			# identify which cells around the pillar have a floor effect
			my ( $feffecttype, $quad ) = (-1, 0 );
			if ( $feffectlvl_nw && $feffectlvl_ne && ($feffecttype_nw == $feffecttype_ne )) {
				$feffecttype = $feffecttype_nw;
				$quad = 0x3;
				$quad = $quad | 0x4 if ( $feffectlvl_sw && $feffecttype_nw == $feffecttype_sw );
				$quad = $quad | 0x8 if ( $feffectlvl_se && $feffecttype_nw == $feffecttype_se );
			} elsif ( $feffectlvl_nw && $feffectlvl_sw && ($feffecttype_nw == $feffecttype_sw )) {
				$feffecttype = $feffecttype_nw;
				$quad = 0x5;
				$quad = $quad | 0x2 if ( $feffectlvl_ne && $feffecttype_nw == $feffecttype_ne );
				$quad = $quad | 0x8 if ( $feffectlvl_se && $feffecttype_nw == $feffecttype_se );
			} elsif ( $feffectlvl_ne && $feffectlvl_se && ($feffecttype_ne == $feffecttype_se )) {
				$feffecttype = $feffecttype_ne;
				$quad = 0xa;
				$quad = $quad | 0x1 if ( $feffectlvl_nw && $feffecttype_ne == $feffecttype_nw );
				$quad = $quad | 0x4 if ( $feffectlvl_sw && $feffecttype_ne == $feffecttype_sw );
			} elsif ( $feffectlvl_sw && $feffectlvl_se && ($feffecttype_sw == $feffecttype_se )) {
				$feffecttype = $feffecttype_sw;
				$quad = 0xc;
				$quad = $quad | 0x1 if ( $feffectlvl_nw && $feffecttype_sw == $feffecttype_nw );
				$quad = $quad | 0x2 if ( $feffectlvl_ne && $feffecttype_sw == $feffecttype_ne );
			};

			# check if we are extending the previous pillar
			if ((($opattern & 0xf0 ) == 0xf0 ) && $pillarlist[$pillarcount][1] ) {
				if ( $xinc == $pillarlist[$pillarcount][0] && $zinc == $pillarlist[$pillarcount][2] &&
					$yinc == ($pillarlist[$pillarcount][1] - $pillarlist[$pillarcount][10])) {

					# increment the recorded height of the lower pillar 
					$pillarlist[$pillarcount][10] += 1;
					my $pillarhgt = $pillarlist[$pillarcount][10];

					# correct the opattern ceiling bit value of the extended pillar
					$pillarlist[$pillarcount][6] = ( ( $pillarlist[$pillarcount][6] & 0xf0 ) | ( $opattern & 0x0f ) );

					# skip adding this pillar as a new pillar
					next;
				};
			};
		
			# record pillar
			$pillarcount += 1;
			$pillarlist[$pillarcount][0] = $xinc;
			$pillarlist[$pillarcount][1] = $yinc;
			$pillarlist[$pillarcount][2] = $zinc;
			$pillarlist[$pillarcount][3] = 0;
			$pillarlist[$pillarcount][4] = gethallinfo( $xinc, $yinc, $zinc, 0, 0 );
			$pillarlist[$pillarcount][5] = 0;
			$pillarlist[$pillarcount][6] = $opattern;
			$pillarlist[$pillarcount][7] = $feffecttype;
			$pillarlist[$pillarcount][8] = $quad;
			$pillarlist[$pillarcount][9] = 0;
			$pillarlist[$pillarcount][10] = 1;
			setpillarflag( $xinc, $yinc, $zinc );

			print "record pillar at $xinc $yinc $zinc\n" if $debug1;
		}
	    }
	}

	# correct passthru flagged cells to be inside of rooms, so that cells are rendered properly. 
	foreach my $xinc ( 0..$xmazesize-1 ) {
	    foreach my $yinc ( 0..$ymazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {

			# skip this cell if it is not a passthru endpoint.
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			next if ( $cellspc < 36 || $cellspc > 39 );

			# skip this cell if it is assigned to a room.
			my $roomid = getroomid( $xinc, $yinc, $zinc );
			next if ( $roomid );

			# determine direction of passthru endpoint.
			my ( $XI, $ZI ) = ( 0, 0 );
			$XI = -1 if ( $cellspc == 36 );
			$XI = 1 if ( $cellspc == 37 );
			$ZI = -1 if ( $cellspc == 38 );
			$ZI = 1 if ( $cellspc == 39 );

			# skip this cell if adjacent cell is not in a room
			my $nroomid = getroomid( $xinc + $XI, $yinc, $zinc + $ZI );
			next if ( ! $nroomid );

			# try to detect "short" passthrus which are processed differently.
			my $midcellspc = getcellspc( ($xinc+$XI),$yinc,($zinc+$ZI) );
			if ( $midcellspc != 32 && $midcellspc != 33 ) {
				# set the current cellspc value to the proper cell
				setcellspc( $xinc+$XI, $yinc, $zinc+$ZI, $cellspc );
			};
			# reset old cell from the 36-39 range to the 12-15 range.
			setcellspc( $xinc, $yinc, $zinc, ( $cellspc ^ 0x28 ) );
		};
	    };
	};
};

#------------------------------------------------------------------------------
# addxoloops - add rare crossover loops to completed maze

sub addxoloops {
	foreach my $loopnum ( 1 .. $maxxoloops ) {
	    my ( $X, $Y, $Z, $dirfound, $crossover );
	    foreach my $attempt ( 1 .. $maxxoattempts ) {
		$X = int(rand($xmazesize+1)) if $xmazesize > 1;
		$Y = int(rand($ymazesize+1)) if $ymazesize > 1;
		$Z = int(rand($zmazesize+1)) if $zmazesize > 1;

		# verify our random location is a valid start location
		my ( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
			$ch_dist, $ch_feffectlvl, $cd_feffecttype, $cd_ceffectlvl, $cd_ceffecttype ) = getcellinfo( $X, $Y, $Z );
		my $ch_cellspc = getcellspc( $X, $Y, $Z );
		my $ch_hallid = gethallid( $X, $Y, $Z );

		# look up if we allow crossovers on this level.
		my ( $valid_b2, $levelspc_b2) = getlevelflag( $Y, 2 );

		# determine if hall class spec allows crossovers
		my ( $hvalid_b8, $hallspc_b8) = gethallflag( $X, $Y, $Z, 8 );

		# skip this location if it is not valid, not marked as used, used by a room, or has a cell special flag or no hall id.
		next if ( ! $ch_valid );
		next if ( ! $ch_celluse );
		next if ( $ch_roomid );
		next if ( $ch_cellspc );
		next if ( ! $ch_hallid );

		# skip this location if the level or hall class does not allow crossovers.
		next if ( $levelspc_b2 );
		next if ( $hallspc_b8 );

		# see if we can build a crossover from this location
		my @dirlist = &randomdirectionlist($ch_roomid, $X, $Y, $Z);
		foreach my $checkdir ( @dirlist ) {
		    $crossover = checkcrossover( $X, $Y, $Z, $checkdir, $ch_hallid, 1 );
		    $dirfound = $checkdir if ( $crossover );
		    last if $dirfound;
		};

		last if $dirfound;
	    };
	    last if ! $dirfound;

	    print "addxoloops: loop $loopnum dir $dirfound loc $X $Y $Z hops $crossover\n" if $debug2;
	    openpath( $X, $Y, $Z, $dirfound, 5, $crossover );
 	};
};
#------------------------------------------------------------------------------
# addloops - add rare passage loops to completed maze

sub addloops {

	print "addloops started\n" if $debug1;
	getdeadends(0);

	# for each recorded dead-end cell, compare distance field with surrounding cells
	my @deadends = &randomnumberlist($deadendcount-1);
	foreach my $deadend ( @deadends ) {
		my $X = $deadendlist[$deadend][0];
		my $Y = $deadendlist[$deadend][1];
		my $Z = $deadendlist[$deadend][2];
		my $refdist = getcelldist( $X, $Y, $Z );
		my ( $ldist, $ldist2, $ldir, $LXI, $LYI, $LZI ) = (0,0,0,0,0,0);

		# skip this cell if it is vertically-extended
		my $vheflags = getvhe( $X, $Y, $Z );
		next if $vheflags;

		# skip this cell if it is a dynamic stair
		my $cellspc = getcellspc( $X, $Y, $Z );
		next if ( $cellspc >= 40 && $cellspc <= 63 );

		my $delta = 0;
		my @dirlist = &randomnumberlist(4);
		foreach my $dir ( @dirlist ) {
			my ( $XI, $YI, $ZI ) = getmazedirection( $dir );
			next if ( ! checkbounds( $X+$XI, $Y+$YI, $Z+$ZI ));

			# skip this direction if it leads into a room
			my $roomid = getroomid( ($X+$XI), ($Y+$YI), ($Z+$ZI) );
			next if ( $roomid != 0 );

			# skip this direction if it leads into a vhe segment
			my $vheflags = getvhe( $X+$XI, $Y+$YI, $Z+$ZI );
			next if $vheflags;

			# skip this direction if it leads into a cell with a special flag
			my $cellspc2 = getcellspc( $X+$XI, $Y+$YI, $Z+$ZI );
			next if $cellspc2;

			my $cmpdist = getcelldist( ($X+$XI), ($Y+$YI), ($Z+$ZI));
			$delta = ( $refdist - $cmpdist ) if ( $refdist >= $cmpdist );
			$delta = ( $cmpdist - $refdist ) if ( $refdist < $cmpdist );
			
			if ( ($delta > $minmazeloop) && ( $ldist < $delta )) {
				$ldir = $dir;
				$ldist = $refdist;
				$ldist2 = $cmpdist;
				$LXI = $XI;
				$LYI = $YI;
				$LZI = $ZI;
			};
		};

		# also compare cell distance with distances of previously-created loops
		my $confloop = 0;
		foreach my $loopnum ( 1..$loops ) {
			my $lldist = $looplist[$loopnum][0];
			my $lldist2 = $looplist[$loopnum][1];
			$delta = ( $ldist - $lldist ) if ( $ldist >= $lldist );
			$delta = ( $lldist - $ldist ) if ( $lldist < $ldist );
			$ldir = 0 if ($delta < $minmazeloop);
			$delta = ( $ldist2 - $lldist ) if ( $ldist2 >= $lldist );
			$delta = ( $lldist - $ldist2 ) if ( $lldist < $ldist2 );
			$ldir = 0 if ($delta < $minmazeloop);
			$delta = ( $ldist - $lldist2 ) if ( $ldist >= $lldist2 );
			$delta = ( $lldist2 - $ldist ) if ( $lldist2 < $ldist );
			$ldir = 0 if ($delta < $minmazeloop);
			$delta = ( $ldist2 - $lldist2 ) if ( $ldist2 >= $lldist2 );
			$delta = ( $lldist2 - $ldist2 ) if ( $lldist2 < $ldist2 );
			$ldir = 0 if ($delta < $minmazeloop);
		};

		# if the compared distances exceed the minimum loop size, create the new loop
		if ( $ldir != 0 ) {
			$loops += 1;

			my ( $XI, $YI, $ZI ) = getmazedirection( $ldir );
			my $hall = gethallid( $X, $Y, $Z );
			my $hall2 = gethallid( $X+$XI, $Y+$YI, $Z+$ZI );
			my $hclass = gethallinfo( $X, $Y, $Z, 0, 0);
			my $hclass2 = gethallinfo( $X+$XI, $Y+$YI, $Z+$ZI, 0, 0);
			my $fevok = 1;
			my $fev = getfev( $X, $Y, $Z );
			my $fev2 = getfev( $X+$XI, $Y+$YI, $Z+$ZI );

			if ( $hclass == $hclass2 && $fev != $fev2 ) {
				# determine if fev difference is compatible with hallway type
				my $fevdiff = $fev - $fev2;
				$fevdiff = 0 - $fevdiff if ( $fevdiff < 0 );

				# switch to using a doorway transition if fev transition would be infeasible
				my ($rfevfound, $rfevflag) = gethallflag( $X, $Y, $Z, 23 );
				$fevok = 0 if ( $fevdiff > 1 && ! $rfevflag );
			} else {
				$fevok = 0;
			};

			if ( ! $fevok ) {

				# if the hallway types are different, add a doorway

				# open the path in the arrays
				openpath( $X, $Y, $Z, $ldir, 4, 0 );

				# add a hall-to-hall doorway
				my $doorclass = 18;
				my $doornum = addtodoorlist( 0, $X, $Y, $Z, $ldir, 1, $doorclass, 0 );

				# increment door counter for first hallid
				my $dctr = gethallinfo( $X, $Y, $Z, 0, 4 ) + 1;
				sethallinfo( $X, $Y, $Z, 0, 4, $dctr );

				# increment door counter for second hallid if it is a different hallid
				if ( $hall != $hall2 ) {
					my $dctr = gethallinfo( $X+$XI, $Y+$YI, $Z+$ZI, 0, 4 ) + 1;
					sethallinfo( $X+$XI, $Y+$YI, $Z+$ZI, 0, 4, $dctr );
				};

				print "addloop at $X $Y $Z direction $ldir door $doornum class $doorclass\n" if $debug2;

			} else {
				# if the hallway types are identical, open up the hallway
				openpath( $X, $Y, $Z, $ldir, 1, 0);

				print "addloop at $X $Y $Z direction $ldir direct passage\n" if $debug2;
			};

			# add the new loop to the loop list.
			$looplist[$loops][0]=$ldist;
			$looplist[$loops][1]=$ldist2;
			$looplist[$loops][2]=$ldir;
			$looplist[$loops][3]=$X;
			$looplist[$loops][4]=$Y;
			$looplist[$loops][5]=$Z;
		};
	};
};

#------------------------------------------------------------------------------
# scanroomforhallid - scan room for cells belonging to a specified hallway ID

sub scanroomforhallid {
	my ( $chk_roomid, $chk_hallid ) = @_;

	print "scanroomforhallid for room $chk_roomid and hallway $chk_hallid\n" if $debug3;

	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos($chk_roomid);
	my $xfc = ( $xc + $xs - 1 );
	my $yfc = ( $yc + $ys - 1 );
	my $zfc = ( $zc + $zs - 1 );
	my ( $xloc, $yloc, $zloc ) = ( 0, 0, 0 );

	my $match = 0;
	foreach $xloc ( $xc .. $xfc ) {
	    foreach $yloc ( $yc .. $yfc ) {
		foreach $zloc ( $zc .. $yfc ) {
			my $valid = checkbounds( $xloc, $yloc, $zloc );
			next if ! $valid;
			my $roomid = getroomid( $xloc, $yloc, $zloc );
			next if ( $roomid != $chk_roomid );
			my $hallid = gethallid( $xloc, $yloc, $zloc );
			next if ( $hallid != $chk_hallid );

			$match = 1;
			last
		};
		last if $match;
	    };
	    last if $match;
	};

	print "scanroomforhallid match at $xloc $yloc $zloc for room $chk_roomid and hallway $chk_hallid\n" if ( $debug3 && $match );
	print "scanroomforhallid no match for room $chk_roomid and hallway $chk_hallid\n" if ( $debug3 && ( ! $match ) );
	
	return( $match );
};

#------------------------------------------------------------------------------
# scanfordoor - scan room for a possible exit door

sub scanfordoor {
	my ( $cc_roomid, $xmp, $ymp, $zmp ) = @_;

	print "scanfordoor input room $cc_roomid at $xmp $ymp $zmp\n" if $debug2;

	my ($dfound, $locdoor ) = lookupdoor( $xmp, $ymp, $zmp );
	my ($srcx, $srcy, $srcz, $srcroom, $srcdoornum, $srcdir, $from, $did, $valid, $doorclass ) = getdoorinfo( $locdoor );
	print "scanfordoor return 0 due to fromdoor != 0 for door $locdoor\n" if ( $from != 0 && $debug2 );
	return( 0,0,0,0,0) if ( $from != 0 );


	# get room information
	my $roomspc = getroomspc( $cc_roomid );
	my $roomdoors = $roominfo[$cc_roomid][10];
	my ($xloc, $yloc, $zloc, $found, $checkdir) = ( 0,0,0,0,0);
	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos($cc_roomid);
	my $xfc = ( $xc + $xs - 1 );
	my $yfc = ( $yc + $ys - 1 );
	my $zfc = ( $zc + $zs - 1 );


	# special room flag bit 9 - try to pick the door location on the opposing wall
	my ( $valid_b9, $roomspc_b9) = getroomspcflag( $roomspc, 9 );
	if ( $roomspc_b9) {
		( $xloc, $yloc, $zloc ) = ( $xmp, $ymp, $zmp );
		$xloc = $xfc if $xloc == $xc;
		$xloc = $xc if $xloc == $xfc;
		$zloc = $zfc if $zloc == $zc;
		$zloc = $zc if $zloc == $zfc;
		( $found, $checkdir ) = checkforroompath( $xloc, $yloc, $zloc );

		# skip using this if it does not have a door flag set.
		my $oppdoorflag = getdoorflag( $xloc, $yloc, $zloc );
		$found = 0 if ! $oppdoorflag;
	};

	if ( $found == 0 ) {
		# get a list of potential areas to scan for an available exit
		my ($doorcount, $pridoorcount) = getdoorlist( $cc_roomid );
				
		# look for a useable location for a door

		# first scan the priority door list for an available door
		my @pridoors = &randomnumberlist($pridoorcount);

		my $extroom;

		foreach my $pass ( 1..2 ) {
		    foreach my $door ( @pridoors ) {
			$xloc = $pridoorlist[$door][0];
			$yloc = $pridoorlist[$door][1];
			$zloc = $pridoorlist[$door][2];

			# look around cell for free space to move to
			( $found, $checkdir, $extroom ) = checkforroompath($xloc, $yloc, $zloc);

			# skip door selection if a special room type has a max door count specified that we have exceeded.
			$found = 0 if ($roomclass[$roomspc][3] && $roomdoors >= $roomclass[$roomspc][3]);

			# prioritize room-to-room doors if we are making a first pass and room2roompriority option is enabled.
			$found = 0 if ($room2roompriority && $pass == 1 && ! $extroom);

			last if ( $found == 1 );
		    };
		    last if ( $found == 1 );
		};
		# if no priority door was found, scan the regular door list
		if ( $found == 0 ) {
	    	    my @doors = &randomnumberlist($doorcount);
		    foreach my $pass ( 1..2 ) {
	    		foreach my $door ( @doors ) {
				$xloc = $doorlist[$door][0];
				$yloc = $doorlist[$door][1];
				$zloc = $doorlist[$door][2];

				# look around cell for free space to move to
				( $found, $checkdir, $extroom ) = checkforroompath($xloc, $yloc, $zloc);

				# skip door selection if a special room type has a max door count specified that we have exceeded.
				$found = 0 if ($roomclass[$roomspc][3] && $roomdoors >= $roomclass[$roomspc][3]);

				# prioritize room-to-room doors if we are making a first pass and room2roompriority option is enabled.
				$found = 0 if ($room2roompriority && $pass == 1 && ! $extroom);

				if ( $found == 1 ) {
					last;
				} else {
					# cell is not useable as a door, clear its flag.
					cleardoorflag( $xloc, $yloc, $zloc, 1 ) if $pass == 2;
				};
	    		};
		        last if ( $found == 1 );
		    };
		};
	};

	# we do not allow overlapping doors on a single cell
	$found = 0 if ( $xmp == $xloc && $ymp == $yloc && $zmp == $zloc );

	if ( $found ) {
		print "scanfordoor output $xloc $yloc $zloc dir $checkdir\n" if $debug2;
		return ($xloc, $yloc, $zloc, $found, $checkdir );
	} else {
		print "scanfordoor return zero\n" if $debug2;
		return ( 0, 0, 0, 0, 0 );
	};
};

#------------------------------------------------------------------------------
# getdeadends - scan maze for dead-ends and record a list of them.

sub getdeadends {
	my ($mode, $thread) = @_;
	# mode 0 - get all horizontal dead-ends (for addloops)
	# mode 1 - check all directions when locating dead-ends. (dead-end removal)
	# mode 2 - get dead-ends with no room below them (dungeon mode)
	# mode 3 - get dead-ends with no room two levels below them (dungeon mode w/level pass-thru)

	$thread = 0 if ( ! $thread );
	print "getdeadends mode $mode started for thread $thread\n" if $debug1;
	$deadendcount = 0;
	my $YI=1;
	$YI=-1 if $invertlevels;
	foreach my $yinc ( 0..$ymazesize-1 ) {
	    foreach my $xinc ( 0..$xmazesize-1 ) {
		foreach my $zinc ( 0..$zmazesize-1 ) {
			my $roomid = getroomid( $xinc, $yinc, $zinc );
			my $paths = getpathflags( $xinc, $yinc, $zinc );
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			my $threadbit = (( $thrmazegrid[$xinc][$yinc][$zinc] >> ( $thread - 1 )) & 1) if $thread;
			my $subroomid = 0;

			next if ( $thread && ! $threadbit );

			# by default, limit checks to horizontal paths
			$paths = 15 - ( $paths & 15 ) if $mode != 1;

			# mode 1 checks all paths
			$paths = 63 - ( $paths & 63 ) if $mode == 1;

			# skip cells with rooms underneath them (modes 2 and 3)
			if ( $mode == 2 ) {
				# check for room one cell below, for standard dungeon gateway placement
				my $valid = checkbounds( $xinc, $yinc+$YI, $zinc );
				$subroomid = getroomid( $xinc, $yinc+$YI, $zinc ) if $valid;
			} elsif ( $mode == 3 ) {
				# check for room two cells below, for special dungeon gateway placement
				my $valid = checkbounds( $xinc, $yinc+$YI+$YI, $zinc );
				$subroomid = getroomid( $xinc, $yinc+$YI+$YI, $zinc ) if $valid;
			};

			next if ( $roomid != 0 || $subroomid != 0 );

			# skip recording this dead end if it is just the pit of a pit trap.
			next if ( $cellspc == 11 );

			# check for the dead-end auto-remove flag on the hall class.
			# my ($valid_b6, $hallspc_b6) = gethallflag( $xinc, $yinc, $zinc, 6 );
			# next if ( $automatic && ( ! $hallspc_b6 ));

			# record location in dead-end list if it fits our requirements
			if ( $paths == 1 || $paths == 2 || $paths == 4 || $paths == 8 || $paths == 16 || $paths == 32 ) {
				print "getdeadends recording dead-end $xinc $yinc $zinc as dead-end $deadendcount thread $thread\n" if $debug2;
				$deadendlist[$deadendcount][0] = $xinc;
				$deadendlist[$deadendcount][1] = $yinc;
				$deadendlist[$deadendcount][2] = $zinc;
				$deadendlist[$deadendcount][3] = getcelldist( $xinc, $yinc, $zinc );
				$deadendcount += 1;
			};
		}
	    }
	}
	print "getdeadends found $deadendcount dead-ends for mode $mode thread $thread\n" if $debug1;
	return( $deadendcount );
};

#------------------------------------------------------------------------------
# removedeadends - remove dead ends back to nearest intersection or room

sub removedeadends {
	my ( $hallid, $thread, $unrefflag ) = @_;

	return 0 if ((! $deadendrmlength) && ( ! $hallid ) && ( ! $unrefflag ));


	my $deadendcount = 0;

	# if a hallway was specified, we limit our dead-end removal to just that hallway
	if ( $hallid ) {
		$deadendcount = $halldeadendctr[$hallid];
	} else {
		$deadendcount = getdeadends(1);
	};

	my $removelen = 0;

	print "removedeadends processing $deadendcount dead-ends\n" if $debug1;

	# examine each dead-end location
	foreach my $deadend ( 0..$deadendcount-1 ) {
		my ( $X, $Y, $Z );
		if ( $hallid ) {
			$X = $halldeadendlist[$hallid][$deadend][0];
			$Y = $halldeadendlist[$hallid][$deadend][1];
			$Z = $halldeadendlist[$hallid][$deadend][2];

			my ( $highdistval, $xhighdist, $yhighdist, $zhighdist ) = getthreadhighdist( $thread );
			next if ( $xhighdist == $X && $yhighdist == $Y && $zhighdist == $Z );
	
		} else {
			$X = $deadendlist[$deadend][0];
			$Y = $deadendlist[$deadend][1];
			$Z = $deadendlist[$deadend][2];
		}

		# set the dead-end removal length
		$removelen = gethallinfo( $X, $Y, $Z, 1, 35 );
		$removelen = 0 if ( ! $removelen );
		$removelen = $deadendrmlength if ( $deadendrmlength > $removelen );
		$removelen = 1000 if ( ! $removelen );

		my $cellspc = getcellspc( $X, $Y, $Z );

		# skip any hallway types that open up the adjacent walls
		my ( $valid_b7, $hallspc_b7 ) = gethallflag( $X, $Y, $Z, 7 );
		next if $hallspc_b7;

		# limit removal to hall types with bit 30 flag enabled if we specified the unref flag.
		my ( $valid_b30, $hallspc_b30 ) = gethallflag( $X, $Y, $Z, 30 );
		next if ( $unrefflag && ! $hallspc_b30 );

		# keep dead end if it is the starting or ending point of the maze
		next if ( $cellspc == 1 );

		# skip dead end if it is an upper or lower vhe segment
		my $vheflags = getvhe( $X, $Y, $Z );
		next if ( $vheflags && ( $vheflags != 0b100 ));

		my $endpath;
		my $length = 0;

		# mark dead end as removed in the hallway dead-end list
		$halldeadendlist[$hallid][$deadend][3]=1 if $hallid;

		my ( $umx, $umy, $umz, $umdir );

		# start processing a dead-end for removal
		do {
			$endpath = 1;

			# get cell information
			print "removedeadends $deadend checking $X $Y $Z\n" if $debug2;

			my $umbits = 0;

			if ( $unrefflag ) {
				my $umflag1 = ( getumflag( $X-1, $Y, $Z ) << 0 );
				my $umflag2 = ( getumflag( $X+1, $Y, $Z ) << 1 );
				my $umflag3 = ( getumflag( $X, $Y, $Z-1 ) << 2 );
				my $umflag4 = ( getumflag( $X, $Y, $Z+1 ) << 3 );
				my $umflag5 = ( getumflag( $X, $Y-1, $Z ) << 4 );
				my $umflag6 = ( getumflag( $X, $Y+1, $Z ) << 5 );
				$umbits = ( $umflag1 | $umflag2 | $umflag3 | $umflag4 | $umflag5 | $umflag6 );
			};

			my $opath = ( 63 - ( getpathflags( $X, $Y, $Z ) | $umbits ));
			my $roomid = getroomid( $X, $Y, $Z );
			my $cellspc = getcellspc( $X, $Y, $Z );
			my $vheflags = getvhe( $X, $Y, $Z );

			# end processing if we hit a room or crossover
			$endpath = 0 if $roomid;
			$endpath = 0 if ( $cellspc >= 2 && $cellspc <= 7 );

			# convert path bits to directions
			my $odir = 0;
			$odir = 1 if $opath == 1;
			$odir = 2 if $opath == 2;
			$odir = 3 if $opath == 4;
			$odir = 4 if $opath == 8;
			$odir = 5 if $opath == 16;
			$odir = 6 if $opath == 32;

			$endpath = 0 if ! $odir;

			# ignore up/down directions if we are on a VHE cell
			$endpath = 0 if ( $odir == 5 && $vheflags );
			$endpath = 0 if ( $odir == 6 && $vheflags );

			# get cell info of upstream cell
			my ( $fdirmask, $rdirmask ) = getdirmasks($odir);
			my ( $XI, $YI, $ZI ) = getmazedirection($odir);
			$roomid = getroomid( $X+$XI, $Y+$YI, $Z+$ZI );
			$cellspc = getcellspc( $X+$XI, $Y+$YI, $Z+$ZI );

			# remove path
			if ( $endpath ) {

				print "removedeadends $deadend removing $X $Y $Z dir $odir\n" if $debug2;

				setpath( $X, $Y, $Z, $odir ) if ( ! $unrefflag );
				setipath( $X+$XI, $Y+$YI, $Z+$ZI, $odir ) if ( ! $unrefflag );
				setcellspc( $X, $Y, $Z, 0 );
				disabledoor( $X+$XI, $Y+$YI, $Z+$ZI ) if $roomid;
				setcelldist( $X, $Y, $Z, 0, 0 );
				clearcelluse( $X, $Y, $Z );
				clearfeffecttype ( $X, $Y, $Z );
				clearfeffectlvl ( $X, $Y, $Z );
				clearvhe( $X, $Y, $Z );
				clearfev( $X, $Y, $Z );

				if ( $unrefflag ) {
					# set the unmined flag on the cleared cell.
					setumflag( $X, $Y, $Z );
					setcelluse ( $X, $Y, $Z );
				};

				$X += $XI;
				$Y += $YI;
				$Z += $ZI;

				( $umx, $umy, $umz, $umdir ) = ( $X, $Y, $Z, $odir );
			};

			# end processing this dead-end path if we have met the maximum remove length
			$length += 1;
			$endpath = 0 if $length >= $removelen;

		} while ( $endpath );

		if ( $umdir ) {
			# re-open path into unmined area.
			openpath( $umx, $umy, $umz, ((($umdir-1)^1)+1), 1, 0 );
			print "removedeadends um end $umx $umy $umz direction $umdir\n" if $debug2;
		};

		print "removedeadends removed $length segments from deadend $deadend maxrmlen $removelen\n" if $debug1;
	}
}

#------------------------------------------------------------------------------
# initroom - initialize room settings after we step into it for the first time

sub initroom {
	my ($X, $Y, $Z, $room, $backdir, $distance, $thread) = @_;

	my $spc = getroomspc( $room );

	# mark room as initialized
	$roominfo[$room][9] = 1;
				
	# mark all room cells as used and update distance
	lockroom( $room, $distance, $thread );

	# clear door flag for entrance door.
	cleardoorgroup( $X, $Y, $Z, 1 );
};

#------------------------------------------------------------------------------
# openpath - open the path between two cells on the array

sub openpath {
	my ( $X, $Y, $Z, $DIR, $MODE, $crossover ) = @_;

	my ( $XI, $YI, $ZI ) = getmazedirection( $DIR );

	if ( $DIR >= 8 ) {
		# indicate these cells have diagonal path movement
		setdiagpath( $X, $Y, $Z );
		# setdiagpath( $X+$XI, $Y+$YI, $Z+$ZI );

		print "Y/YI changed from $Y/$YI " if $debug3;
		$Y += $YI;
		$YI = 0;
		print "to $Y/$YI\n" if $debug3;
	};

	my ( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = ( 0, 0, 0, 0 );
	( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($DIR) if ( $DIR > 0 );

	my $idoor = getdoorflag( $X, $Y, $Z);
	my $edoor = getdoorflag( $X+$XI, $Y+$YI, $Z+$ZI);
	my $door = ( $idoor | $edoor );
	my $vheflags = getvhe( $X, $Y, $Z );
	my $vhe2flags = getvhe( $X+$XI, $Y+$YI, $Z+$ZI );

	# find a better door indicator than the door flags
	my $segment = getsegment( $X, $Y, $Z );
	my $wall = getpathflags( $X, $Y, $Z );
	my $doors = ( $segment ^ $wall );
	$doors = ( $doors & 0x01 ) if ( $XI == -1 );
	$doors = ( $doors & 0x02 ) if ( $XI ==  1 );
	$doors = ( $doors & 0x04 ) if ( $ZI == -1 );
	$doors = ( $doors & 0x08 ) if ( $ZI ==  1 );
	$doors = 0 if ( ! $XI && ! $ZI );

	my $iroomid = getroomid( $X, $Y, $Z);
	my $eroomid = getroomid( $X+$XI, $Y+$YI, $Z+$ZI);
	my $room = ( $iroomid | $eroomid );

	my $RDIR = ((($DIR-1)^1)+1);
	$RDIR = ( $DIR ^ 0b10101 ) if ( $DIR >= 8 );
	$RDIR = ( $DIR ^ 0b00101 ) if ( $DIR >= 16 && $DIR <= 23 );
	$RDIR = 0 if ( ! $DIR );

	print "openpath mode $MODE on $X $Y $Z dir $DIR room $room door $door doors $doors\n" if $debug3;
	if ( $MODE == 0 ) {
		# mode 0 - general maze generator movement

		my $oldval = $mazegrid[$X][$Y][$Z];
		my $oldaval = $auxmazegrid[$X][$Y][$Z];
		printf "fdirmask %032b $sfdirmask %032b\n", $fdirmask, $sfdirmask if $debug3;
		printf "rdirmask %032b $srdirmask %032b\n", $rdirmask, $srdirmask if $debug3;
		printf "old mazegrid %032b aux %032b\n", $oldval, $oldaval if $debug3;

		# clear the forward wall flag and set the use flag on the current cell
		$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask | $cellusemask ) ^ $fdirmask );

		# open the segment if neither side of the opening is a room
		$auxmazegrid[$X][$Y][$Z] = (( $auxmazegrid[$X][$Y][$Z] | $sfdirmask ) ^ $sfdirmask ) if ( ! $room );
		$auxmazegrid[$X+$XI][$Y+$YI][$Z+$ZI] = (( $auxmazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $srdirmask ) ^ $srdirmask ) if ( ! $room );

		# clear the reverse wall flag, set a backtrack direction and use flag on the new cell
		$mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] =
			(( $mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $rdirmask | $cellusemask ) ^ $rdirmask ) |
			(($RDIR<<$backshft) & $backmask);

		my $newval = $mazegrid[$X][$Y][$Z];
		my $newaval = $auxmazegrid[$X][$Y][$Z];
		printf "new mazegrid %032b aux %032b\n", $newval, $newaval if $debug3;

	} elsif ( $MODE == 1 ) {
		# mode 1 - simply open cells without movement or entering a backtrack direction 
		# clear the forward wall flag
		$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask ) ^ $fdirmask );

		# open the segment if neither side of the opening is a room
		$auxmazegrid[$X][$Y][$Z] = (( $auxmazegrid[$X][$Y][$Z] | $sfdirmask ) ^ $sfdirmask ) if ( ! $room );
		$auxmazegrid[$X+$XI][$Y+$YI][$Z+$ZI] = (( $auxmazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $srdirmask ) ^ $srdirmask ) if ( ! $room );

		# clear the reverse wall flag
		$mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] = (( $mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $rdirmask ) ^ $rdirmask );
	} elsif ( $MODE == 2 || $MODE == 5 ) {
		# mode 2 - open up a crossover during maze generation
		# mode 5 - open up a crossover after maze generation is complete

		my ( $l_cellusemask, $l_backmask ) = ( $cellusemask, $backmask );
		( $l_cellusemask, $l_backmask ) = ( 0, 0 ) if ( $MODE == 5 );

		# clear the forward wall and segment flags of the first cell
		$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask | $l_cellusemask ) ^ $fdirmask );
		$auxmazegrid[$X][$Y][$Z] = (( $auxmazegrid[$X][$Y][$Z] | $sfdirmask ) ^ $sfdirmask );

		# clear the forward and reverse wall/segment flags of the middle cell(s)
		foreach my $crossnum ( 1..$crossover ) {
			$mazegrid[$X+($XI*$crossnum)][$Y+$YI][$Z+($ZI*$crossnum)] =
				(( $mazegrid[$X+($XI*$crossnum)][$Y+$YI][$Z+($ZI*$crossnum)] |
				$rdirmask | $fdirmask | $l_cellusemask )^($rdirmask | $fdirmask));

			$auxmazegrid[$X+($XI*$crossnum)][$Y+$YI][$Z+($ZI*$crossnum)] =
				(( $auxmazegrid[$X+($XI*$crossnum)][$Y+$YI][$Z+($ZI*$crossnum)] |
				$srdirmask | $sfdirmask  )^($srdirmask | $sfdirmask));

			# mark middle cell(s) as a crossover midpoint hallway type
			setcellspc( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), 2 ) if $XI;
			setcellspc( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), 3 ) if $ZI;

			# get room ID of the cell and set the room attribute bits for passthrus
			my $roomid = getroomid( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum) );
			my $segment = getsegment( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum) );
			setroomattrib( $roomid, 20 ) if ( $roomid && ( $segment & 32 ) );
			setroomattrib( $roomid, 21 ) if ( $roomid && ( ( $segment & 32 ) == 0 ) );
		};

		# clear the reverse wall/segment flag of the last cell and set a backtrack direction
		$mazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] =
			(( $mazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] |
			$rdirmask | $l_cellusemask ) ^ $rdirmask ) | (($RDIR<<$backshft) & $l_backmask);
		$auxmazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] =
			(( $auxmazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] |
			$srdirmask ) ^ $srdirmask );

		# mark the two ends as crossover endpoint hallway types of the appropriate direction
		
		my $ctype = ( $DIR + 3 );
		$ctype = ( $DIR - 4 ) if ( $DIR >= 8 );
		$ctype = ( $DIR - 8 ) if ( $DIR >= 12 );

		setcellspc( $X, $Y, $Z, ( $ctype ));
		setcellspc( $X+($XI*$crossover)+$XI, $Y+$YI, $Z+($ZI*$crossover)+$ZI, ( $ctype ^ 1 ));
	} elsif ( $MODE == 6 || $MODE == 7 ) {
		# mode 6 - open up a passthru during maze generation
		# mode 7 - not tested - open up a passthru after maze generation is complete

		my ( $l_cellusemask, $l_backmask, $l_doormask ) = ( $cellusemask, $backmask, $doormask );
		( $l_cellusemask, $l_backmask, $l_doormask ) = ( 0, 0, 0 ) if ( $MODE == 7 );

		# clear the forward wall and segment flags of the first cell
		$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask | $l_cellusemask ) ^ $fdirmask );
		$auxmazegrid[$X][$Y][$Z] = (( $auxmazegrid[$X][$Y][$Z] | $sfdirmask ) ^ $sfdirmask );

		# get the hallid of the starting cell
		my $hallid = gethallid( $X, $Y, $Z );
		my ( $hallgstyle, $halllstyle ) = gethallstyle( $X, $Y, $Z );
		$halllstyle = genhallstyle( $X, $Y, $Z, $DIR, 1 );

		print "passthru $X $Y $Z span $crossover I $XI $YI $ZI hallid $hallid\n" if $debug3;

		# clear the forward and reverse wall flags of the middle cell(s), and set the use flag and clear the door flag
		foreach my $crossnum ( 1..($crossover) ) {
			$mazegrid[$X+($XI*$crossnum)][$Y+$YI][$Z+($ZI*$crossnum)] =
				(( $mazegrid[$X+($XI*$crossnum)][$Y+$YI][$Z+($ZI*$crossnum)] |
				$rdirmask | $fdirmask | $l_cellusemask | $l_doormask)^($rdirmask | $fdirmask | $l_doormask));

			# mark middle cell(s) as a crossover midpoint hallway type
			setcellspc( $X+$XI, $Y+$YI, $Z+$ZI, 32 + 0 ) if ( $XI && ( $crossover == 1 ) );
			setcellspc( $X+$XI, $Y+$YI, $Z+$ZI, 32 + 1 ) if ( $ZI && ( $crossover == 1 ) );
			setcellspc( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), 32 + 2 ) if ( $XI && ( $crossover > 1 ) );
			setcellspc( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), 32 + 3 ) if ( $ZI && ( $crossover > 1 ) );

			# set the hallway ID of the middle cells
			sethallid( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), $hallid, 0, 0 ) if $hallid;
			sethallgstyle( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), $hallgstyle ) if $hallid;
			sethalllstyle( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum), $halllstyle ) if $hallid;
		};

		# clear the reverse wall/segment flag of the last cell and set a backtrack direction
		$mazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] =
			(( $mazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] |
			$rdirmask | $l_cellusemask ) ^ $rdirmask ) | (($RDIR<<$backshft) & $l_backmask);
		$auxmazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] =
			(( $auxmazegrid[$X+($XI*$crossover)+$XI][$Y+$YI][$Z+($ZI*$crossover)+$ZI] |
			$srdirmask ) ^ $srdirmask );

		# mark the two ends as passthru endpoint hallway types of the appropriate direction
		my $ctype = 32 + ( $DIR + 3 );
		$ctype = 32 + ( $DIR - 4 ) if ( $DIR >= 8 );
		$ctype = 32 + ( $DIR - 8 ) if ( $DIR >= 12 );

		setcellspc( $X, $Y, $Z, ( $ctype ));
		setcellspc( $X+($XI*$crossover)+$XI, $Y+$YI, $Z+($ZI*$crossover)+$ZI, ( $ctype ^ 1 ));
		sethalllstyle( $X, $Y, $Z, $halllstyle );
		sethalllstyle( $X+($XI*$crossover)+$XI, $Y+$YI, $Z+($ZI*$crossover)+$ZI, $halllstyle );

		# clear any passthru flags adjacent to the side of this passthru
		my $ptroomid = getroomid( $X+$XI, $Y+$YI, $Z+$ZI );
		foreach my $crossnum ( 1..($crossover) ) {
			if ( $DIR == 1 || $DIR == 2 ) {
				my $adjroomid1 = getroomid( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum)-1);
				my $adjroomid2 = getroomid( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum)+1);
				clearthruflag( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum)-1, 0) if ( $adjroomid1 == $ptroomid );
				clearthruflag( $X+($XI*$crossnum), $Y+$YI, $Z+($ZI*$crossnum)+1, 0) if ( $adjroomid2 == $ptroomid );
				print "clearadjpassthru of $X $Y $Z I $XI $ZI ptroomid $ptroomid ar1 $adjroomid1 ar2 $adjroomid2\n" if ( $debug3 );
			} elsif ( $DIR == 3 || $DIR == 4 ) {
				my $adjroomid1 = getroomid( $X+($XI*$crossnum)-1, $Y+$YI, $Z+($ZI*$crossnum));
				my $adjroomid2 = getroomid( $X+($XI*$crossnum)+1, $Y+$YI, $Z+($ZI*$crossnum));
				clearthruflag( $X+($XI*$crossnum)-1, $Y+$YI, $Z+($ZI*$crossnum), 0) if ( $adjroomid1 == $ptroomid );
				clearthruflag( $X+($XI*$crossnum)+1, $Y+$YI, $Z+($ZI*$crossnum), 0) if ( $adjroomid2 == $ptroomid );
				print "clearadjpassthru of $X $Y $Z I $XI $ZI ptroomid $ptroomid ar1 $adjroomid1 ar2 $adjroomid2\n" if ( $debug3 );
			};
		};
		
	} elsif ( $MODE == 8 ) {
		# mode 8 - open up a dynamic stair segment during maze generation

		# obtain information about the starting point
		my $dir = $dynstairlist[1][5];
		( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($dir);
		( $XI, $YI, $ZI ) = getmazedirection($dir);
		my $hallid = gethallid( $X, $Y, $Z );
		my ( $hallgstyle, $halllstyle ) = gethallstyle( $X, $Y, $Z );
		$halllstyle = genhallstyle( $X, $Y, $Z, $DIR, 2 );

		# clear the forward and reverse wall segments at the starting point
		$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask ) ^ $fdirmask );
		$mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] = (( $mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $rdirmask ) ^ $rdirmask );
		$auxmazegrid[$X][$Y][$Z] = (( $auxmazegrid[$X][$Y][$Z] | $sfdirmask ) ^ $sfdirmask );
		$auxmazegrid[$X+$XI][$Y+$YI][$Z+$ZI] = (( $auxmazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $srdirmask ) ^ $srdirmask );

		# set the cellspc of the starting cell
		setcellspc( $X, $Y, $Z, 40 + (( $dir - 1 ) & 3 ) );
		sethalllstyle( $X, $Y, $Z, $halllstyle );

		# process the intermediate segments
		foreach my $index ( 2 .. ($dsindex - 1) ) {
			my $start = $dynstairlist[$index][0];
			my $xpos = $dynstairlist[$index][1];
			my $ypos = $dynstairlist[$index][2];
			my $zpos = $dynstairlist[$index][3];
			my $slope = $dynstairlist[$index][4];
			my $end = $dynstairlist[$index][5];
			my $angle = $dynstairlist[$index][6];

			( $XI, $YI, $ZI ) = getmazedirection($slope);
			( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($slope);

			# set the various info on the intermediate cell
			setcelluse( $xpos, $ypos, $zpos );
			sethallid( $xpos, $ypos, $zpos, $hallid, 0, 0 );
			sethallgstyle( $xpos, $ypos, $zpos, $hallgstyle );
			sethalllstyle( $xpos, $ypos, $zpos, $halllstyle );

			# determine forward/reverse cellspc values
			my ( $ucellspc, $lcellspc ) = (0, 0 );
			if ( $start != -1 && $start != -2 ) {
				$ucellspc = ( 48 + ( ( $start - 1 ) ^ 1 ) + ( ( $slope - 1 ) * 4 ) ) if ( $start > 0 && $slope > 0 );
				$lcellspc = ( 48 + ( ( $slope - 1 ) ^ 1 ) + ( ( $end - 1 ) * 4 ) ) if ( $start < 0 && $slope > 0 && $end > 0 );

				print "$xpos $ypos $zpos ucellspc $ucellspc lcellspc $lcellspc\n" if ( $debug2 );
			};


			if ( $start == -1 ) {
				setcellspc( $xpos, $ypos, $zpos, 48 );
			} elsif ( $start == -2 ) {
				setcellspc( $xpos, $ypos, $zpos, 53 );
			} elsif ( $start == -3 ) {
				setcellspc( $xpos, $ypos, $zpos, $lcellspc );

				# open up the floor/ceiling at the stair landing cell pair
				( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks(5);
				$mazegrid[$xpos][$ypos][$zpos] = (( $mazegrid[$xpos][$ypos][$zpos] | $fdirmask ) ^ $fdirmask );
				$mazegrid[$xpos][$ypos-1][$zpos] = (( $mazegrid[$xpos][$ypos-1][$zpos] | $rdirmask ) ^ $rdirmask );
				$auxmazegrid[$xpos][$ypos][$zpos] = (( $auxmazegrid[$xpos][$ypos][$zpos] | $sfdirmask ) ^ $sfdirmask );
				$auxmazegrid[$xpos][$ypos-1][$zpos] = (( $auxmazegrid[$xpos][$ypos-1][$zpos] | $srdirmask ) ^ $srdirmask );

				# open up the horizontal path into the next cell
				( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($end);
				( $XI, $YI, $ZI ) = getmazedirection($end);
				$mazegrid[$xpos][$ypos][$zpos] = (( $mazegrid[$xpos][$ypos][$zpos] | $fdirmask ) ^ $fdirmask );
				$mazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] = (( $mazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] | $rdirmask ) ^ $rdirmask );
				$auxmazegrid[$xpos][$ypos][$zpos] = (( $auxmazegrid[$xpos][$ypos][$zpos] | $sfdirmask ) ^ $sfdirmask );
				$auxmazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] = (( $auxmazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] | $srdirmask ) ^ $srdirmask );
			} elsif ( $start == -4 ) {
				setcellspc( $xpos, $ypos, $zpos, $lcellspc );
				# open up the horizontal path into the next cell
				( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($end);
				( $XI, $YI, $ZI ) = getmazedirection($end);
				$mazegrid[$xpos][$ypos][$zpos] = (( $mazegrid[$xpos][$ypos][$zpos] | $fdirmask ) ^ $fdirmask );
				$mazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] = (( $mazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] | $rdirmask ) ^ $rdirmask );
				$auxmazegrid[$xpos][$ypos][$zpos] = (( $auxmazegrid[$xpos][$ypos][$zpos] | $sfdirmask ) ^ $sfdirmask );
				$auxmazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] = (( $auxmazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] | $srdirmask ) ^ $srdirmask );
			} else {
				setcellspc( $xpos, $ypos, $zpos, $ucellspc );
				# open up the horizontal walls between the upper half of the cell pairs
				$mazegrid[$xpos][$ypos][$zpos] = (( $mazegrid[$xpos][$ypos][$zpos] | $fdirmask ) ^ $fdirmask );
				$mazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] = (( $mazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] | $rdirmask ) ^ $rdirmask );
				$auxmazegrid[$xpos][$ypos][$zpos] = (( $auxmazegrid[$xpos][$ypos][$zpos] | $sfdirmask ) ^ $sfdirmask );
				$auxmazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] = (( $auxmazegrid[$xpos+$XI][$ypos+$YI][$zpos+$ZI] | $srdirmask ) ^ $srdirmask );
			};
		};

		# obtain information about the ending point
		my $edir = $dynstairlist[$dsindex][0];
		my $xpos = $dynstairlist[$dsindex][1];
		my $ypos = $dynstairlist[$dsindex][2];
		my $zpos = $dynstairlist[$dsindex][3];
		my $eval = 44 + (( ( $edir - 1 ) ^ 1 ) & 3 );

		# set the various info on the ending cell
		setcelluse( $xpos, $ypos, $zpos );
		setcellspc( $xpos, $ypos, $zpos, 44 + (( ( $edir - 1 ) ^ 1 ) & 3 ) );
		sethallid( $xpos, $ypos, $zpos, $hallid, 0, 0 );
		sethallgstyle( $xpos, $ypos, $zpos, $hallgstyle );
		sethalllstyle( $xpos, $ypos, $zpos, $halllstyle );

	} elsif ( $MODE == 4 ) {
		# mode 4 - open up a path between hallways (addloops)

		# clear the forward wall flag
		$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask ) ^ $fdirmask );

		# clear the reverse wall flag
		$mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] = (( $mazegrid[$X+$XI][$Y+$YI][$Z+$ZI] | $rdirmask ) ^ $rdirmask );
	};

	# obtain and output debugging info, if requested
	if ($debug3) {
		my $bt = getbacktrack( $X+$XI, $Y+$YI, $Z+$ZI );
		my $xbt = ( $X + $XI );
		my $ybt = ( $Y + $YI );
		my $zbt = ( $Z + $ZI );
		print "openpath mode $MODE on $xbt $ybt $zbt dir $DIR backtrack set to $bt\n";
	};
};

#------------------------------------------------------------------------------
# getdsspan - get span endpoint and distance of a dynamic stair segment 

sub getdsspan {
	my ( $X, $Y, $Z ) = @_;

	print "getdsspan called with $X $Y $Z\n" if ( $debug2 );

	my $valid = 1;
	my $fwd = 1;
	my $lastspan = 0;
	my $mult = 1;
	for my $spancnt ( 1 .. ( $maxdsspan * 2 ) ) {
		last if ( ! $valid );

		# get the cellspc value of the location
		my $cellspc = getcellspc( $X, $Y, $Z );

		# get the cellspc values of the upper/lower cells
		my $ucellspc = getcellspc( $X, $Y-1, $Z );
		my $lcellspc = getcellspc( $X, $Y+1, $Z );
		$ucellspc = 0 if ( ! $ucellspc );
		$lcellspc = 0 if ( ! $lcellspc );

		print "getdsspan $X $Y $Z cellspc $cellspc u $ucellspc l $lcellspc\n" if ( $debug2 );

		# validate that we are seeing what we are expecting
		$valid = 0 if ( $cellspc < 40 || $cellspc > 63 );
		$valid = 0 if ( $cellspc == 48 || $cellspc == 53 || $cellspc == 58 || $cellspc == 63 );
		$valid = 0 if ( $spancnt == 1 && $cellspc >= 48 );

		$fwd = 0 if ( $spancnt == 1 && $cellspc >= 44 );

		# break out of the loop if we have hit the other end
		last if ( $spancnt != 1 && $fwd == 1 && $cellspc >= 44 && $cellspc <= 47 );
		last if ( $spancnt != 1 && $fwd == 0 && $cellspc >= 40 && $cellspc <= 43 );

		my ( $fdir, $bdir ) = ( -1, -1 );
		if ( $cellspc >= 48 ) {
			$fdir = ( $cellspc >> 2 ) & 0x03;
			$bdir = $cellspc & 0x03;

			print "$X $Y $Z fdir $fdir bdir $bdir\n" if ( $debug2 );

			# invert the directions if we are backtracking
			if ( ! $fwd ) {
				( $fdir, $bdir ) = ( $bdir, $fdir );
			};
		} else {
			$fdir = $cellspc & 3 ;
		};

		# direction should be 1-4 instead of 0-3
		$fdir += 1;
		$bdir += 1;

		my $YV=0;
		if ( $fwd ) {
			if ( $lcellspc == 53 ) {
				$YV=1;
			} elsif ( $ucellspc == 58 ) {
				$YV=-1;
			};
		} else {
			if ( $lcellspc == 63 ) {
				$YV=1;
			} elsif ( $ucellspc == 48 ) {
				$YV=-1;
			};
		};

		# invert the vertical slope if we are backtracking
		# $YV = ( 0 - $YV ) if ( ! $fwd );

		$lastspan = $spancnt;

		my ( $XI, $YI, $ZI ) = getmazedirection($fdir);

		print "getdsspan for $X $Y $Z fdir $fdir bdir $bdir\n" if ( $debug2 );

		$X += $XI;
		$Y += $YV;
		$Z += $ZI;

		print "getdsspan move to $X $Y $Z\n" if ( $debug2 );
	};

	return( 0, 0, 0, 0, 0 ) if ( ! $valid );

	print "getdsspan returns $X $Y $Z spanlen $lastspan\n" if ( $debug2 );

	return( 1, $X, $Y, $Z, $lastspan )
};

#------------------------------------------------------------------------------
# getthruspan - get span distance of passthru

sub getthruspan {
	my ( $X, $Y, $Z, $backdir ) = @_;

	my ( $XI, $YI, $ZI ) = getmazedirection($backdir);
	my $cellspc = getcellspc( $X, $Y, $Z );
	my $chkcellspc = ($cellspc^1);

	my $roomid = getroomid( $X+$XI, $Y+$YI, $Z+$ZI );
	$roomid = 0 if ( ! $roomid );
	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = ( 0, 0, 0, 0, 0, 0 );
	( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $roomid ) if $roomid;

	print "getthruspan coord $X $Y $Z backdir $backdir I $XI $YI $ZI room $roomid corner $xc $yc $zc size $xs $ys $zs\n" if $debug3;

	my $maxthruspan = $xs;
	$maxthruspan = $zs if ( $backdir == 3 || $backdir == 4 );

	foreach my $thrunum ( 1..($maxthruspan + 1) ) {
	$cellspc = getcellspc( $X+($XI*$thrunum+$XI), $Y, $Z+($ZI*$thrunum+$ZI));
	return( $thrunum ) if ($cellspc == $chkcellspc);
	};
};

#------------------------------------------------------------------------------
# getcrossspan - get span distance of crossover

sub getcrossspan {
	my ( $X, $Y, $Z, $backdir ) = @_;

	my ( $XI, $YI, $ZI ) = getmazedirection($backdir);
	my $cellspc = getcellspc( $X, $Y, $Z );
	my $chkcellspc = ($cellspc^1);

	foreach my $crossnum ( 1..($maxcrossspan + 1) ) {
	$cellspc = getcellspc( $X+($XI*$crossnum+$XI), $Y, $Z+($ZI*$crossnum+$ZI));
	return( $crossnum ) if ($cellspc == $chkcellspc);
	};
};

#------------------------------------------------------------------------------
# spcroomadjust - perform door adjustments on special rooms

sub spcroomadjust {
	my ( $roomid, $xmp, $ymp, $zmp ) = @_;
	my ( $xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze ) = getroompos( $roomid );
	my $roomspc = getroomspc( $roomid );

	# clear all doorflags on room level if room special flag bit 7 is set.
	my ( $valid_b7, $roomspc_b7) = getroomspcflag( $roomspc, 7 );
	if ( $roomspc_b7 ) {
		foreach my $xinc ( $xc .. $xc+$xs-1 ) {
		    foreach my $zinc ( $zc .. $zc+$zs-1 ) {
			cleardoorflag( $xinc, $ymp, $zinc, 1 );
		    }
		}
		return 1;
	};
	return 0;
};

#------------------------------------------------------------------------------
# gethalltype - use the cell information to determine type of hall to use

sub gethalltype {
	my ( $xmp, $ymp, $zmp, $backdir ) = @_;

	# get room ids for both sides of door location
	my $roomid = getroomid( $xmp, $ymp, $zmp );
	my ( $XI, $YI, $ZI ) = getmazedirection( $backdir );
	my $backroomid = getroomid ( $xmp+$XI, $ymp+$YI, $zmp+$ZI );

	# we don't need to choose a hallway class if we are going room-to-room
	return 0 if ( $backroomid && $roomid );

	# get the door class flags for this door
	my ($dfound, $doorid) = lookupdoor( $xmp, $ymp, $zmp );
	my $doorclass = getdoorclass( $doorid ) if $dfound;
	my $doorflags = $doorclass[$doorclass][1];

	my @okclasses;
	my $numokclasses;
	my ( $found, $class ) = (0,0);
	$numokclasses = 0;
	foreach my $hclassnum ( 0..$maxhallclass ) {

		# skip this class if it is not valid
		next if ! $hallclass[$hclassnum][0][0];

		# get the flag info for the hall class we are examining.
		my $hclass_weight = $hallclass[$hclassnum][0][8];
		my $hclass_dst = $hallclass[$hclassnum][0][4];
		my ( $hclass_required, $hclass_disallowed, $hclass_recommended, $hclass_notrec ) = parsedoorflagstring( $hclass_dst );

		# skip this class if door characteristics match disallowed room characteristics
		next if ( $doorflags & $hclass_disallowed );

		# skip this class if door characteristics do not match required room characteristics
		next if ( ($doorflags & $hclass_required) != $hclass_required );

		my $recnrec = $hclass_weight;

		# check for each recommended/not-recommended bit match
		foreach my $bit ( 0..31 ) {
			my $recobit = (($hclass_recommended>>$bit) & 1);
			my $nrecbit = (($hclass_notrec>>$bit) & 1);
			my $dclbit = (($doorclass>>$bit) & 1);
			$recnrec = ( $recnrec * 2 ) if ( $recobit & $dclbit );
			$recnrec = ( $recnrec / 2 ) if ( $nrecbit & $dclbit );
		};
		$recnrec = 1 if ( $recnrec < 1 );

		# add the class to the list once per adjusted weight
		foreach my $count ( 1..int($recnrec) ) {
			$okclasses[$numokclasses]=$hclassnum;
			$numokclasses += 1;
		};
	};

	# randomly pick one of the matches if there is more than one available
	$class = $okclasses[int(rand( $numokclasses ))] if $numokclasses;

	return( $class );
};

#------------------------------------------------------------------------------
# genhallstyle - use the cell information to determine global or local style of hall to use

sub genhallstyle {
	my ( $xmp, $ymp, $zmp, $backdir, $grouping ) = @_;
	$grouping = 0 if ( ! $grouping );

	print "genhallstyle for group $grouping called for $xmp $ymp $zmp\n" if ( $debug3 );

	if ( ! $grouping ) {

		# return a zero if global hallway style flag is turned off.
		my ( $hvalid_b42, $hallspc_b42) = gethallflag( $xmp, $ymp, $zmp, 42 );
		if ( ! $hallspc_b42 ) {
			my $dummyrand = int( rand( 100 ) );
			return 0;
		};

		# get room ids for both sides of door location
		my $roomid = getroomid( $xmp, $ymp, $zmp );
		my ( $XI, $YI, $ZI ) = getmazedirection( $backdir );
		my $backroomid = getroomid ( $xmp+$XI, $ymp+$YI, $zmp+$ZI );
	
		# we don't need to choose a global hallway style if we are going room-to-room
		return 0 if ( $backroomid && $roomid );

	} else {

		# return a zero value if the local style flag is turned off.
		my ( $hvalid_b43, $hallspc_b43) = gethallflag( $xmp, $ymp, $zmp, 43 );
		if ( ! $hallspc_b43 ) {
			my $dummyrand = int( rand( 100 ) );
			return 0;
		};

	};

	my $hallid = gethallid( $xmp, $ymp, $zmp );
	my $hclass = gethallinfo( $xmp, $ymp, $zmp, 0, 0);
	my $stylestr = gethallinfo( $xmp, $ymp, $zmp, 1, 3 );

	my ( $weight, $rtype ) = parsestylestring( $stylestr, '', 0, $grouping );

	my @list;
	my $linc = 0;
	my $totstyles = 0;
	my $idxmax = ( $gstylemask >> $gstyleshft );
	$idxmax = ( $lstylemask >> $lstyleshft ) if ( $grouping );

	# use the style weight values to influence the odds of selection.
	for my $index ( 0 .. $idxmax ) {

		my $wgtval = ( ( $weight >> ( 4 * $index ) ) & 0xf );
		# convert weights 10/11/12/13/14/15 to 16/32/48/64/80/96
		$wgtval = ( 16 * ( $wgtval - 9 )) if ( $wgtval > 9 );

		if ( $wgtval ) {
			$totstyles += 1;
			for my $idx ( 1 .. $wgtval ) {
				$list[$linc] = $index;
				$linc += 1;
			};
		};
	};

	print "genhallstyle for group $grouping at $xmp $ymp $zmp: $totstyles styles to choose from\n" if ( $debug3 );

	# return zero if we have no styles to choose from
	if ( ! $linc ) {
		my $dummyrand = int( rand( 100 ) );
		return 0;
	};

	# select and return a random style.
	my $randsel = int( rand( $linc ) );
	my $selstyle = $list[$randsel];

	print "genhallstyle: style $selstyle chosen for $xmp $ymp $zmp\n" if ( $debug3 );
	
	return( $selstyle );
};

#------------------------------------------------------------------------------
# getinteriortype - use the room info to determine type of interior to use

sub getinteriortype {
	my $room = $_[0];

	# get attributes for room
	my $roomattr1 = $roominfo[$room][14];
	my $roomattr2 = $roominfo[$room][15];
	
	my @okclasses;
	my $numokclasses;
	my $class = 0;
	$numokclasses = 0;
	foreach my $classnum ( 0..$maxinteriorclass ) {

		# skip this class if it has no weight value
		next if ( ! $interiorclass[$classnum][3] );

		# get the info for the interior class we are examining.
		my $class_weight = $interiorclass[$classnum][3];
		my $class_maxnum = $interiorclass[$classnum][11];
		my $class_istr = $interiorclass[$classnum][12];
		my $class_curnum = $intclassqty[$classnum];
		$class_curnum = 0 if ( ! $class_curnum );

		# skip this class if we have hit class quantity restrictions, if any.
		next if ( $class_maxnum && ( $class_curnum >= $class_maxnum ));

		my ( $intreq, $intdis, $intrec, $intnot, $intreq2, $intdis2, $intrec2, $intnot2 ) =
			parseinteriorflagstring( $class_istr );

		# skip this class if room characteristics match disallowed interior characteristics
		if (( $roomattr1 & $intdis ) || ( $roomattr2 & $intdis2 )) {
			if ( $debug3 ) {
				my $intname = $interiorclass[$classnum][0];
				my $disbits1 = ( $roomattr1 & $intdis );
				my $disbits2 = ( $roomattr2 & $intdis2 );
				printf( "getint: $intname dis room $room %08x/%08x dis bits %08x/%08x\n", $roomattr1, $roomattr2, $disbits1, $disbits2 );
			};
			next;
		};

		# skip this class if room characteristics do not match required interior characteristics
		if ((( $roomattr1 & $intreq ) != $intreq ) || (( $roomattr2 & $intreq2 ) != $intreq2 )) {
			if ( $debug3 ) {
				my $intname = $interiorclass[$classnum][0];
				my $reqbits1 = (( $roomattr1 & $intreq ) ^ $intreq );
				my $reqbits2 = (( $roomattr2 & $intreq2 ) ^ $intreq2 );
				printf( "getint: $intname dis room $room %08x/%08x req bits %08x/%08x\n", $roomattr1, $roomattr2, $reqbits1, $reqbits2 );
			};
			next;
		};

		my $recnrec = $class_weight;

		# check for each recommended/not-recommended bit match
		foreach my $bit ( 0..31 ) {
			my $rec1bit = (($intrec>>$bit) & 1);
			my $not1bit = (($intnot>>$bit) & 1);
			my $rec2bit = (($intrec2>>$bit) & 1);
			my $not2bit = (($intnot2>>$bit) & 1);
			my $ra1bit = (($roomattr1>>$bit) & 1);
			my $ra2bit = (($roomattr2>>$bit) & 1);

			# double or halve the odds for each recommended/not-recommended bit match
			$recnrec = ( $recnrec * 2 ) if ( $rec1bit & $ra1bit );
			$recnrec = ( $recnrec / 2 ) if ( $not1bit & $ra1bit );
			$recnrec = ( $recnrec * 2 ) if ( $rec2bit & $ra2bit );
			$recnrec = ( $recnrec / 2 ) if ( $not2bit & $ra2bit );
		};
		$recnrec = 1 if ( $recnrec < 1 );

		# add the class to the list once per adjusted weight
		foreach my $count ( 1..int($recnrec) ) {
			$okclasses[$numokclasses]=$classnum;
			$numokclasses += 1;
		};
	};

	# randomize the list
	if ( $numokclasses ) {
		my @randnums;

		while (@okclasses) {
			push @randnums, splice(@okclasses, rand(@okclasses), 1);
		};
	
		$class = $randnums[int(rand($numokclasses))];
	};

	# increment the counter for this class
	$intclassqty[$class] = 0 if ( ! $intclassqty[$class] );
	$intclassqty[$class] += 1;

	return( $class );
};

#------------------------------------------------------------------------------
# getintvari - lookup interior variation count based on interior class, layer, and segment pattern.

sub getintvari {
	my ( $interior, $rel, $segment ) = @_;
	my $intvari = 0;

	# build variation array if necessary
	if ( ! $intvarindex[$interior][0][0] ) {
		print "building intvarindex for interior $interior\n" if ( $debug2 );
		my $layer = 0;
		my $intvaridefault = $interiorclass[$interior][9];

		my @optents = split(';', $interiorclass[$interior][15] );
		for my $opt ( @optents ) {
			$layer += 1;
			for my $position ( 0 .. 63 ) {
				my $char = substr( $opt, $position, 1 );
				last if ( $char eq '' );

				my $intval = 0;
				$intval =  $intvaridefault if ( $char eq '.' );
				$intval =  0 if ( $char eq '0' );
				$intval =  1 if ( $char eq '1' );
				$intval =  2 if ( $char eq '2' );
				$intval =  3 if ( $char eq '3' );
				$intval =  4 if ( $char eq '4' );
				$intval =  5 if ( $char eq '5' );
				$intval =  6 if ( $char eq '6' );
				$intval =  7 if ( $char eq '7' );
				$intval =  8 if ( $char eq '8' );
				$intval =  9 if ( $char eq '9' );
				$intval = 10 if ( $char eq 'a' );
				$intval = 11 if ( $char eq 'b' );
				$intval = 12 if ( $char eq 'c' );
				$intval = 13 if ( $char eq 'd' );
				$intval = 14 if ( $char eq 'e' );
				$intval = 15 if ( $char eq 'f' );
				$intval = 16 if ( $char eq 'g' );
				$intval = 17 if ( $char eq 'h' );
				$intval = 18 if ( $char eq 'i' );
				$intval = 19 if ( $char eq 'j' );
				$intval = 20 if ( $char eq 'k' );
				$intval = 21 if ( $char eq 'l' );
				$intval = 22 if ( $char eq 'm' );
				$intval = 23 if ( $char eq 'n' );
				$intval = 24 if ( $char eq 'o' );
				$intval = 25 if ( $char eq 'p' );
				$intval = 26 if ( $char eq 'q' );
				$intval = 27 if ( $char eq 'r' );
				$intval = 28 if ( $char eq 's' );
				$intval = 29 if ( $char eq 't' );
				$intval = 30 if ( $char eq 'u' );
				$intval = 31 if ( $char eq 'v' );
				$intval = 32 if ( $char eq 'w' );
				$intval = 33 if ( $char eq 'x' );
				$intval = 34 if ( $char eq 'y' );
				$intval = 35 if ( $char eq 'z' );

				$intvarindex[$interior][$layer][$position] = $intval;
			};
		};

		# designate that we have populated the index for this interior
		$intvarindex[$interior][0][0] = 1;
	};

	# lookup the requested variation in the index
	$intvari = $intvarindex[$interior][$rel + 1][$segment];
	$intvari = 0 if ( ! $intvari );

	return( $intvari );
};

#------------------------------------------------------------------------------
# getncintvari - lookup non-cached interior variation count based on interior class, layer, and segment pattern.

sub getncintvari {
	my ( $interior, $rel, $segment, $yroomsize ) = @_;
	my $intvaridefault;

	my ( $intvalid_b8, $intspc_b8 ) = getintspcflag( $interior, 8 );

	if ( $intspc_b8 ) {
		my @optents = split(',', $interiorclass[$interior][9] );
		$intvaridefault = $optents[$yroomsize - 1];
		$intvaridefault = 0 if ( ! $intvaridefault );
	} else {
		$intvaridefault = $interiorclass[$interior][9];
	};

	my @optents = split(';', $interiorclass[$interior][15] );
	my $opt = $optents[$rel];
	my $char = substr( $opt, $segment, 1 );
	my $intval = 0;

	$intval =  $intvaridefault if ( $char eq '.' );
	$intval =  0 if ( $char eq '0' );
	$intval =  1 if ( $char eq '1' );
	$intval =  2 if ( $char eq '2' );
	$intval =  3 if ( $char eq '3' );
	$intval =  4 if ( $char eq '4' );
	$intval =  5 if ( $char eq '5' );
	$intval =  6 if ( $char eq '6' );
	$intval =  7 if ( $char eq '7' );
	$intval =  8 if ( $char eq '8' );
	$intval =  9 if ( $char eq '9' );
	$intval = 10 if ( $char eq 'a' );
	$intval = 11 if ( $char eq 'b' );
	$intval = 12 if ( $char eq 'c' );
	$intval = 13 if ( $char eq 'd' );
	$intval = 14 if ( $char eq 'e' );
	$intval = 15 if ( $char eq 'f' );
	$intval = 16 if ( $char eq 'g' );
	$intval = 17 if ( $char eq 'h' );
	$intval = 18 if ( $char eq 'i' );
	$intval = 19 if ( $char eq 'j' );
	$intval = 20 if ( $char eq 'k' );
	$intval = 21 if ( $char eq 'l' );
	$intval = 22 if ( $char eq 'm' );
	$intval = 23 if ( $char eq 'n' );
	$intval = 24 if ( $char eq 'o' );
	$intval = 25 if ( $char eq 'p' );
	$intval = 26 if ( $char eq 'q' );
	$intval = 27 if ( $char eq 'r' );
	$intval = 28 if ( $char eq 's' );
	$intval = 29 if ( $char eq 't' );
	$intval = 30 if ( $char eq 'u' );
	$intval = 31 if ( $char eq 'v' );
	$intval = 32 if ( $char eq 'w' );
	$intval = 33 if ( $char eq 'x' );
	$intval = 34 if ( $char eq 'y' );
	$intval = 35 if ( $char eq 'z' );

	print "getncintvari lookup int $interior rel $rel seg $segment ys $yroomsize ivd $intvaridefault b8flag $intspc_b8 result $intval\n" if ( $debug2 );

	return( $intval );
};

#------------------------------------------------------------------------------
# getdoortype - use the room or hallway information to determine type of door to use

sub getdoortype {
	my ( $roomid, $xmp, $ymp, $zmp, $backdir ) = @_;

	# get room information
	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $roomid );
	my $roomspc = getroomspc( $roomid );
	my $rclass_dst=$roomclass[$roomspc][22];
	my ( $rclass_required, $rclass_disallowed, $rclass_recommended, $rclass_notrec ) = parsedoorflagstring( $rclass_dst );

	my ( $XI, $YI, $ZI ) = getmazedirection( $backdir );
	my $backroomid = getroomid ( $xmp+$XI, $ymp+$YI, $zmp+$ZI );

	# get hallway information
	my $cellhallid = gethallid( $xmp, $ymp, $zmp );
	my ($hclass_disallowed, $hclass_required, $hclass_recommended, $hclass_notrec, $hclass_weight ) = (0,0,0,0,0);
	if ( $cellhallid) {
		my $hclass = gethallinfo( $xmp, $ymp, $zmp, 0, 0);
		$hclass_weight = $hallclass[$hclass][0][8];
		my $hclass_dst = gethallinfo( $xmp, $ymp, $zmp, 1, 4 );
		( $hclass_required, $hclass_disallowed, $hclass_recommended, $hclass_notrec ) = parsedoorflagstring( $hclass_dst );
	};

	# get list of door position chracteristics to match to.
	my ($udir, $ddir, $hdir, $vdir, $gonly, $eonly, $rm2rm, $hl2hl ) = (0,0,0,0,0,0,0,0);
	$udir = 1 if $backdir == 5;
	$ddir = 1 if $backdir == 6;
	$hdir = 1 if ($backdir >= 1 && $backdir <= 4);
	$vdir = $udir | $ddir;
	$gonly = 1 if ( $ymp == ( $yc + $ys - 1 ));
	$eonly = $gonly ^ 1;
	$rm2rm = (1<<16) if ( $roomid && $backroomid );
	$hl2hl = (1<<18) if ( $roomid == 0 && $backroomid == 0 );
	my $cellflags = (( ~ (($gonly<<8)|($eonly<<9)|($hdir<<10)|($ddir<<11)|($udir<<12)|($vdir<<13))) & 0x00003f00);

	my @okclasses;
	my $numokclasses;
	my ($found, $class) = (0,0);
	$numokclasses = 0;
	foreach my $dclassnum ( 0..$maxdoorclass ) {

		# skip this class if it is not valid
		next if ! $doorclass[$dclassnum][0];

		# get the flag info for the door class we are examining.
		my $classflags = $doorclass[$dclassnum][1];
		my $classweight = $doorclass[$dclassnum][8];

		# skip this class if cell characteristics do not meet door requirements
		next if ( $classflags & $cellflags );

		# check for a rm2rm or hl2hl door/cell mismatch.
		next if ( ($classflags & (1<<16)) != $rm2rm);
		next if ( ($classflags & (1<<18)) != $hl2hl);

		# skip this class if door characteristics match disallowed room/hall characteristics
		next if ( $classflags & $rclass_disallowed );
		next if ( $classflags & $hclass_disallowed );

		# skip this class if door characteristics do not match required room/hall characteristics
		next if ( ($classflags & $rclass_required) != $rclass_required );
		next if ( ($classflags & $hclass_required) != $hclass_required );

		my $recnrec = $classweight;

		# check for each recommended/not-recommended bit match
		foreach my $bit ( 0..31 ) {
			my $recobit1 = (($rclass_recommended>>$bit) & 1);
			my $recobit2 = (($hclass_recommended>>$bit) & 1);
			my $nrecbit1 = (($rclass_notrec>>$bit) & 1);
			my $nrecbit2 = (($hclass_notrec>>$bit) & 1);
			my $dclbit = (($classflags>>$bit) & 1);
			$recnrec = ( $recnrec * 2 ) if (( $recobit1 & $dclbit) || ( $recobit2 & $dclbit));
			$recnrec = ( $recnrec / 2 ) if (( $nrecbit1 & $dclbit) || ( $nrecbit2 & $dclbit));
		};
		$recnrec = 1 if ( $recnrec < 1 );

		# add the class to the list once per door weight for each recommended bit matched
		foreach my $count ( 1..int($recnrec) ) {
			$okclasses[$numokclasses]=$dclassnum;
			$numokclasses += 1;
		};
	};

	# randomly pick one of the matches if there is more than one available
	$class = $okclasses[int(rand( $numokclasses ))] if $numokclasses;

	return( $class );
};

#------------------------------------------------------------------------------
# addtohalllist - add a new hall segment to the hall list

sub addtohalllist {
	my ($hclass, $xstart, $ystart, $zstart) = @_;

	# return 0 if $totalhalls > ($hallidmask>>$hallidshft);

	$totalhalls += 1;
	print "addtohalllist hallid $totalhalls class $hclass start $xstart $ystart $zstart\n" if $debug2;

	# set default values
	my $numdoors = 0;
	my $numcells = 0;

	# add the new info to the hallway list
	$hallinfo[$totalhalls][0][0]=$hclass;
	$hallinfo[$totalhalls][0][1]=$xstart;
	$hallinfo[$totalhalls][0][2]=$ystart;
	$hallinfo[$totalhalls][0][3]=$zstart;
	$hallinfo[$totalhalls][0][4]=$numdoors;
	$hallinfo[$totalhalls][0][5]=$numcells;

	# initialize the hall class cell count tally if necessary
	$hallclasstotalloc[$hclass] = 0 if ( ! $hallclasstotalloc[$hclass] );

	# add the previous hallway cell count to the appropriate tally
	if ( $totalhalls > 1 ) {
		my $prevhallcellct = $hallinfo[$totalhalls - 1][0][5];
		my $prevhallclass = $hallinfo[$totalhalls - 1][0][0];
		$hallclasstotalloc[$prevhallclass] += $prevhallcellct;
		my $totalcells = $hallclasstotalloc[$prevhallclass];
		# print "hall class $prevhallclass cell tally at $totalcells\n";
	};

	# copy base hall class info over
	for my $index ( 0 .. 99 ) {
		$hallinfo[$totalhalls][1][$index] = $hallclass[$hclass][0][$index];
	};

	# get the number of variations available
	my $hclass_vari = $hallclass[$hclass][0][34];

	# create any hall class variations
	for my $vindex ( 1 .. $hclass_vari ) {
		last if ! $hallclass[$hclass][$vindex][0];
		my $vari = $vindex + 1;
		for my $index ( 0 .. 99 ) {
			$hallinfo[$totalhalls][$vari][$index] = $hallclass[$hclass][0][$index];
			if ( $hallclass[$hclass][$vindex][$index] ) {
				if ( $index == 1 || $index == 2 ) {

					# bit fields are exclusive-or'ed with base info
					$hallinfo[$totalhalls][$vari][$index] =
						( eval($hallclass[$hclass][$vindex][$index]) ^ eval($hallclass[$hclass][0][$index] ));

				} elsif ( $index == 3 ) {
					# field 3 is a special global hall style string field
					
					$hallinfo[$totalhalls][$vari][$index] =
						parsestylestring( $hallclass[$hclass][0][$index], $hallclass[$hclass][$vindex][$index], 1 );

					print "hallinfo f3 alter $hallclass[$hclass][0][$index] to $hallinfo[$totalhalls][$vari][$index]\n" if $debug2;

				} elsif ( $index == 4 ) {
					# field 4 is a special door string field
					
					$hallinfo[$totalhalls][$vari][$index] =
						parsedoorflagstring( $hallclass[$hclass][0][$index], $hallclass[$hclass][$vindex][$index], 1 );

					print "hallinfo f4 alter $hallclass[$hclass][0][$index] to $hallinfo[$totalhalls][$vari][$index]\n" if $debug2;

				} elsif ( $hallclass[$hclass][$vindex][$index] eq 'NULL' ) {

					# fields specifying 'NULL' are nullified;
					$hallinfo[$totalhalls][$vari][$index] = '';

				} else {

					# other fields are copied
					$hallinfo[$totalhalls][$vari][$index] = $hallclass[$hclass][$vindex][$index];
				};
			};
		};
	};

	# initialize hallway dead-end counter
	$halldeadendctr[$totalhalls]=0;

	return ( $totalhalls );
};

#------------------------------------------------------------------------------
# addtodoorlist - set the primary door coordinates for a room

sub addtodoorlist {
	my ( $roomid, $X, $Y, $Z, $backdir, $primary, $dclass, $fromdoor ) = @_;

	$totaldoors += 1;
	my $valid = 1;
	print "addtodoorlist $X $Y $Z room $roomid backdir $backdir doornum $totaldoors priflag $primary class $dclass\n" if $debug2;

	# increment door count in roominfo array
	$roominfo[$roomid][10] += 1;

	# add the new info to the door array
	$doorinfo[$totaldoors][0]=$roomid;
	$doorinfo[$totaldoors][1]=$roominfo[$roomid][10];
	$doorinfo[$totaldoors][2]=$X;
	$doorinfo[$totaldoors][3]=$Y;
	$doorinfo[$totaldoors][4]=$Z;
	$doorinfo[$totaldoors][5]=$backdir;
	$doorinfo[$totaldoors][6]=$fromdoor;
	$doorinfo[$totaldoors][7]=$totaldoors;
	$doorinfo[$totaldoors][8]=$valid;
	$doorinfo[$totaldoors][9]=$dclass;

	# set the backtrack direction of the door cell
	setbacktrack( $X, $Y, $Z, $backdir ) if $roomid;

	if ( $roomid && 0 ) {
		# get the door attributes
		my ( $dvalid_b13, $doorspc_b13) = getdoorspcflag( $dclass, 13 );
		my ( $dvalid_b14, $doorspc_b14) = getdoorspcflag( $dclass, 14 );
		my ( $dvalid_b15, $doorspc_b15) = getdoorspcflag( $dclass, 15 );
		my ( $dvalid_b16, $doorspc_b16) = getdoorspcflag( $dclass, 16 );
		my ( $dvalid_b19, $doorspc_b19) = getdoorspcflag( $dclass, 19 );
		my ( $dvalid_b20, $doorspc_b20) = getdoorspcflag( $dclass, 20 );

		# determine which side of door corresponds to the inside of this room
		my ( $XN, $YN, $ZN ) = ( $X, $Y, $Z );
		my $rcid = getroomid( $X, $Y, $Z );
		if ( $rcid != $roomid ) {
			my ( $XI, $YI, $ZI ) = getmazedir( $backdir );
			$XN = ( $X + $XI );
			$YN = ( $Y + $YI );
			$ZN = ( $Z + $ZI );
			$rcid = getroomid( $XN, $YN, $ZN );
		};

		# get cell attributes
		if ( $rcid = $roomid ) {
			my $segment = getsegment( $XN, $YN, $ZN );

			# set room attribute bits based on the cell attributes
			setroomattrib( $roomid, 16 ) if ( $segment & 32 );
			setroomattrib( $roomid, 17 ) if ( ( $segment & 32 ) == 0 );
		} else {
			print "could not find inner-door side for room $roomid door $totaldoors\n";
		};

		# get hallway/cell/room attributes
		my $roomspc = getroomspc( $roomid );
		my $hid = gethallid( $X, $Y, $Z );
		my $ihid = gethallid( $XN, $YN, $ZN );
		my ( $valid_b29, $hallspc_b29 ) = gethallflag( $X, $Y, $Z, 29 );
		my ( $valid_b47, $hallspc_b47 ) = gethallflag( $X, $Y, $Z, 47 );
	        my ( $valid_b63, $roomspc_b63) = getroomspcflag( $roomspc, 63 );

		if ( $debug2 ) {
			print "addtodoorlist $X $Y $Z room $roomid backdir $backdir doornum $totaldoors priflag $primary class $dclass hid $hid ihid $ihid\n";
		};

		if ( $roomspc_b63 && $doorspc_b20 && $hallspc_b29 && $hallspc_b47 ) {
			setcellspc( $XN, $YN, $ZN, 64 );
		} elsif ( $roomspc_b63 && $doorspc_b20 && $hallspc_b29 ) {
			setcellspc( $XN, $YN, $ZN, 65 );
		};

		my $halltype = gethallinfo( $X, $Y, $Z, 1, 41 );
		my $segment = getsegment( $XN, $YN, $ZN );
		my $floor = ( $segment & 32 );

		# set room attribute bits based the door attribute bits
		setroomattrib( $roomid, 18 ) if ( $doorspc_b13 );
		setroomattrib( $roomid, 19 ) if ( $doorspc_b16 );
		if ( $floor ) {
			setroomattrib( $roomid, 32 ) if ( $doorspc_b14 );
			setroomattrib( $roomid, 33 ) if ( $doorspc_b15 );
			setroomattrib( $roomid, 34 ) if ( $doorspc_b20 );
			setroomattrib( $roomid, 35 ) if ( $doorspc_b19 || $doorspc_b13 );
		} else {
			setroomattrib( $roomid, 36 ) if ( $doorspc_b14 );
			setroomattrib( $roomid, 37 ) if ( $doorspc_b15 );
			setroomattrib( $roomid, 38 ) if ( $doorspc_b20 );
			setroomattrib( $roomid, 39 ) if ( $doorspc_b19 || $doorspc_b13 );
		};

		# set room attribute bits based on the hallway attribute bits
		setroomattrib( $roomid, 24 ) if ( $halltype == 2 );
		setroomattrib( $roomid, 25 ) if ( $halltype == 3 );
		setroomattrib( $roomid, 26 ) if ( $halltype == 1 );
		setroomattrib( $roomid, 27 ) if ( $halltype == 4 );
		setroomattrib( $roomid, 40 ) if ( $doorspc_b20 && $hallspc_b29 && ( ! $hallspc_b47 ) && ( $segment & 32 ) );
		setroomattrib( $roomid, 41 ) if ( $doorspc_b20 && $hallspc_b29 && ( ! $hallspc_b47 ) && (( $segment & 32 ) == 0 ) );
		setroomattrib( $roomid, 42 ) if ( $doorspc_b20 && $hallspc_b29 && $hallspc_b47 && ( $segment & 32 ) );
		setroomattrib( $roomid, 43 ) if ( $doorspc_b20 && $hallspc_b29 && $hallspc_b47 && (( $segment & 32 ) == 0 ) );
	};

	# return the door number we just added
	return( $totaldoors );
};

#------------------------------------------------------------------------------
# setprimarydoor - set the primary door coordinates for a room

sub setprimarydoor {
	my ( $roomid, $X, $Y, $Z, $doornum ) = @_;
	my $oldX = $roominfo[$roomid][6];
	my $oldY = $roominfo[$roomid][7];
	my $oldZ = $roominfo[$roomid][8];
	my $olddoor = $roominfo[$roomid][12];
	$olddoor = 0 if ( ! $olddoor );
	print "setprimarydoor room $roomid loc $X $Y $Z doornum $doornum oloc $oldX $oldY $oldZ odoornum $olddoor\n" if $debug2;
	$roominfo[$roomid][6]=$X;
	$roominfo[$roomid][7]=$Y;
	$roominfo[$roomid][8]=$Z;
	$roominfo[$roomid][12]=$doornum;
};

#------------------------------------------------------------------------------
# checkforhallpath - check around a hallway cell for an available move path

sub checkforhallpath {
	my ( $X, $Y, $Z ) = @_;

	print "checkforhallpath called for $X $Y $Z\n" if $debug3;
	# grab current cell attributes
	my $cc_roomid = getroomid( $X, $Y, $Z );
	my $cc_hallid = gethallid( $X, $Y, $Z );
	my $cc_vheflags = getvhe( $X, $Y, $Z );
	my $cc_segment = getsegment( $X, $Y, $Z );
	my $cc_fev = getfev( $X, $Y, $Z );
	my $cc_cellspc = getcellspc( $X, $Y, $Z );

	my $hipridir=0;
	my $lopridir=0;
	my $dirfound=0;
	my $crossover=0;
	my $passthru=0;
	my $dynstair=0;
	
	# get random direction list
	my @dirlist = &randomdirectionlist($cc_roomid, $X, $Y, $Z);
	
	# determine if we allow crossovers or passthrus on this level.
	my ( $valid_b2, $levelspc_b2) = getlevelflag( $Y, 2 );
	my ( $valid_b13, $levelspc_b13) = getlevelflag( $Y, 13 );

	# determine if hall class spec allows crossovers, passthrus, or dynamic stairs
	my ( $hvalid_b8, $hallspc_b8) = gethallflag( $X, $Y, $Z, 8 );
	my ( $hvalid_b36, $hallspc_b36) = gethallflag( $X, $Y, $Z, 36 );
	my ( $hvalid_b39, $hallspc_b39) = gethallflag( $X, $Y, $Z, 39 );
	my ( $valid_b40, $hallspc_b40) = gethallflag( $X, $Y, $Z, 40 );

	# grab a random number, in case we need it for selection odds.
	my $selrand = rand( 100 );

	# try each of the types move movement checks
	foreach my $chktype ( "PTP", "DST", "STD", "XO", "PT" ) {

	    last if ( $dirfound != 0 || $lopridir != 0 );

	    next if ( ( $chktype eq "XO" ) && ( ! $crossovers ) );
	    next if ( ( $chktype eq "PT" ) && ( ! $passthrus ) );
	    next if ( ( $chktype eq "PTP" ) && ( ! $passthrus ) );
	    next if ( ( $chktype eq "DST" ) && ( ! $dynstairs ) );
	    next if ( ( $chktype eq "DST" ) && ( $cc_fev ) );
	    next if ( ( $chktype eq "DST" ) && ( $cc_cellspc ) );

	    # try each direction for a path until we find one.
	    foreach my $checkdir ( @dirlist ) {

		# skip this section if we are trying to place a dynamic staircase
		last if ( $chktype eq "DST" );

		# check for standard hallway movement
		if ( $chktype eq "STD" ) {
		    my $vert = 0;
		    $vert = 1 if ( $checkdir == 5 || $checkdir == 6 );
		
		    # get the relative XYZ direction of the path to check
		    my ( $XI, $YI, $ZI ) = getmazedirection($checkdir);

		    # check if VHE hallway transitions are allowed for this hallway type
		    if ( $checkdir >= 8 && $YI < 0 ) {
			my ( $hvalid_b14, $hallspc_b14) = gethallflag( $X, $Y, $Z, 14 );
			next if $hallspc_b14;
		    } elsif ( $checkdir >= 8 && $YI > 0 ) {
			my ( $hvalid_b15, $hallspc_b15) = gethallflag( $X, $Y, $Z, 15 );
			next if $hallspc_b15;
		    };

		    # check if cell is valid and get use flag
		    my $ch_valid = checkbounds( $XI+$X, $YI+$Y, $ZI+$Z );
		    my $ch_celluse = getcelluse( $XI+$X, $YI+$Y, $ZI+$Z );
			
		    # skip to next direction if this cell is not valid or already used
		    next if ( !$ch_valid || $ch_celluse );

		    my $ch_roomid = getroomid( $XI+$X, $YI+$Y, $ZI+$Z );
		    my $ch_roomspc = getroomspc( $ch_roomid );
		    my $ch_thruflag = getthruflag( $XI+$X, $YI+$Y, $ZI+$Z );
		
		    # skip to next direction if the check cell is a crossover/passthru and we are trying a vertical dir.
		    my $ch_cellspc = getcellspc( $X+$XI, $Y+$YI, $Z+$ZI );
		    next if ( $ch_cellspc >= 2 && $ch_cellspc <= 7 && $vert );
		    next if ( $ch_cellspc >= 32 && $ch_cellspc <= 39 && $vert );

		    # skip to next direction if the current cell is a crossover and we are trying a vertical dir.
		    $ch_cellspc = getcellspc( $X, $Y, $Z );
		    next if ( $ch_cellspc >= 2 && $ch_cellspc <= 7 && $vert );
		    next if ( $ch_cellspc >= 32 && $ch_cellspc <= 39 && $vert );

		    # skip to next direction if the current cell has a trap and we are checking up or down.
		    next if (($ch_cellspc == 8 || $ch_cellspc == 9) && $vert );

		    # skip to next direction if the current cell has a shallow pit and we are checking the up direction.
		    next if ( $ch_cellspc == 10 && $checkdir == 5 );

		    # we are not allowed to enter a room from above/below by option or if room special flag bit 0 is set
		    my ( $valid_b0, $roomspc_b0) = getroomspcflag( $ch_roomspc, 0 );
		    next if ( $ch_roomid && $vert && ( !$verticaldoors || $roomspc_b0 ));
			
		    # if we found a horiz. direction, use that and skip checking up/down paths
		    last if ( $dirfound != 0 && $vert );
			
		    $dirfound = $checkdir;
			
		    # prioritize access into rooms with room special flag bit 10 enabled based on angle of access
		    # access into end of room = high priority, override random dirs.
		    # access into side of room = low priority, use only if no other dirs available.

		    my ( $valid_b10, $roomspc_b10) = getroomspcflag( $ch_roomspc, 10 );

		    if ( $roomspc_b10 ) {
			my ( $XR, $YR, $ZR, $XS, $YS, $ZS ) = getroompos($ch_roomid);
				
			if (( $dirfound == 1 || $dirfound == 2 ) && $XS > 1) {
				$hipridir = $dirfound;
			} elsif (( $dirfound == 3 || $dirfound == 4 ) && $ZS > 1) {
				$hipridir = $dirfound;
			} elsif (( $dirfound == 1 || $dirfound == 2 ) && $XS == 1) {
				$lopridir = $dirfound;
				$dirfound = 0;
			} elsif (( $dirfound == 3 || $dirfound == 4 ) && $ZS == 1) {
				$lopridir = $dirfound;
				$dirfound = 0;
			};
		    };

		    # prioritize access through doors marked with a high-priority flag.
		    my $pridoorflag = getpridoorflag( $XI+$X, $YI+$Y, $ZI+$Z );
		    $hipridir = $dirfound if $pridoorflag;
		};

		# Check if we have any crossover movement available
		if ( $chktype eq "XO" ) {
		    next if ( $cc_cellspc );
		    next if ( $levelspc_b2 );
		    next if ( $hallspc_b8 );
		    next if ( $hallspc_b39 );

		    $crossover = checkcrossover( $X, $Y, $Z, $checkdir, $cc_hallid, 0 );
		    $dirfound = $checkdir if ( $crossover );
		    last;
		};

		# Check if we have any priority passthru movement available
		if ( $chktype eq "PTP" ) {
		    next if ( $cc_cellspc );
		    next if ( $levelspc_b13 );
		    next if ( $hallspc_b36 );
		    next if ( $cc_vheflags );

		    $passthru = checkpassthru( $X, $Y, $Z, $checkdir, $cc_hallid, 0, 1 );
		    $dirfound = $checkdir if ( $passthru );
		    last;
		};

		# Check if we have any regular passthru movement available
		if ( $chktype eq "PT" ) {
		    next if ( $cc_cellspc );
		    next if ( $levelspc_b13 );
		    next if ( $hallspc_b36 );
		    next if ( $cc_vheflags );

		    $passthru = checkpassthru( $X, $Y, $Z, $checkdir, $cc_hallid, 0, 0 );
		    $dirfound = $checkdir if ( $passthru );
		    last;
		};
	    };

	    # Check if we are willing to start a dynamic stair path
	    if ( $chktype eq "DST" ) {
		next if ( ! $hallspc_b40 );
		next if ( $cc_vheflags );
		next if ( $cc_fev );

		my $dsstartodds = gethallinfo( $X, $Y, $Z, 1, 38 );
		next if ( $selrand >= $dsstartodds );

		my $minsize = gethallinfo( $X, $Y, $Z, 1, 36 );
		my $maxsize = gethallinfo( $X, $Y, $Z, 1, 37 );
		my $target = $maxsize;
		
		if ( ( $maxsize - $minsize ) >= 1 ) {
			$target = $minsize + int( rand( $maxsize - $minsize + 1 ) );
		};
		
		my $XC = $X;
		my $YC = $Y;
		my $ZC = $Z;
		my $YV = 1;

		# set the starting point in the dynstairlist
		$dsindex=1;
		$dynstairlist[$dsindex][0]=0;
		$dynstairlist[$dsindex][1]=$XC;
		$dynstairlist[$dsindex][2]=$YC;
		$dynstairlist[$dsindex][3]=$ZC;
		$dynstairlist[$dsindex][4]=0;
		$dynstairlist[$dsindex][5]=0;
		$dynstairlist[$dsindex][6]=$YV;
		my $odsindex=1;
		my $odsindex2 = 1;

		my $midsegs = 0;
		foreach my $SEG ( 1.. $target ) {

			my ( $startdir, $slopedir ) = ( 0, 0 );
			my @dirlist = &randomdirectionlist(1, $XC, $YC, $ZC);
			foreach my $checkdir ( @dirlist ) {
				my ( $XI, $YI, $ZI ) = getmazedirection($checkdir);
	
				# skip this direction if the desired cells are in use
				my $ucelluse = getcelluse( $XC+$XI, $YC, $ZC+$ZI );
				my $lcelluse = getcelluse( $XC+$XI, $YC+$YV, $ZC+$ZI );
				next if ( $ucelluse );
				next if ( $lcelluse );
				my $uroomid = getroomid( $XC+$XI, $YC, $ZC+$ZI );
				my $lroomid = getroomid( $XC+$XI, $YC+$YV, $ZC+$ZI );
				next if ( $uroomid );
				next if ( $lroomid );

				# skip this direction if the desired cells are already marked
				my $udslistmatch = scandynstairlist( $XC+$XI, $YC, $ZC+$ZI );
				my $ldslistmatch = scandynstairlist( $XC+$XI, $YC+$YV, $ZC+$ZI );
				next if ( $udslistmatch || $ldslistmatch );

				# check if we are out of bounds
				my $valid = checkbounds( $XC+$XI, $YC+$YI+$YV, $ZC+$ZI );
				next if ( ! $valid );
	
				$slopedir = 0;
				my ( $XI2, $YI2, $ZI2 ) = ( 0, 0, 0 );
				my @dirlist2 = &randomdirectionlist(1, $XC+$XI, $YC, $ZC+$ZI);
				foreach my $checkdir2 ( @dirlist ) {

					# we cannot fold back upon our first direction
					next if (( $checkdir ^ $checkdir2 ) == 0x01 );
	
					( $XI2, $YI2, $ZI2 ) = getmazedirection($checkdir2);

					# check if we are out of bounds
					my $valid = checkbounds( $XC+$XI+$XI2, $YC+$YI+$YV, $ZC+$ZI+$ZI2 );
					next if ( ! $valid );

					# skip this direction if the desired cells are in use
					my $ucelluse = getcelluse( $XC+$XI+$XI2, $YC, $ZC+$ZI+$ZI2 );
					my $lcelluse = getcelluse( $XC+$XI+$XI2, $YC+$YV, $ZC+$ZI+$ZI2 );
					next if ( $ucelluse || $lcelluse );
					my $uroomid = getroomid( $XC+$XI+$XI2, $YC, $ZC+$ZI+$ZI2 );
					my $lroomid = getroomid( $XC+$XI+$XI2, $YC+$YV, $ZC+$ZI+$ZI2 );
					next if ( $uroomid || $lroomid );

					# skip this direction if the desired cells are already marked
					my $udslistmatch = scandynstairlist( $XC+$XI+$XI2, $YC, $ZC+$ZI+$ZI2 );
					my $ldslistmatch = scandynstairlist( $XC+$XI+$XI2, $YC+$YV, $ZC+$ZI+$ZI2 );
					next if ( $udslistmatch || $ldslistmatch );
	
					$startdir = $checkdir;
					$slopedir = $checkdir2;
					last;
				};
				next if ( ! $slopedir );

				# make sure we are still within the proper bounds.
				$valid = checkbounds( $XC+$XI+$XI2, $YC+$YI+$YV, $ZC+$ZI+$ZI2 );
				next if ( ! $valid );

				# Add segments into the stairlist
				$dsindex += 1;
				$dynstairlist[$dsindex][0]=$startdir;
				$dynstairlist[$dsindex][1]=$XC+$XI;
				$dynstairlist[$dsindex][2]=$YC;
				$dynstairlist[$dsindex][3]=$ZC+$ZI;
				$dynstairlist[$dsindex][4]=$slopedir;
				$dynstairlist[$dsindex][5]=0;
				$dynstairlist[$dsindex][6]=$YV;
				$dynstairlist[$odsindex][5]=$startdir;
				$dynstairlist[$odsindex2][5]=$startdir;
				$odsindex = $dsindex;
				if ( $YV ) {
					$dsindex += 1;
					$dynstairlist[$dsindex][0]=-1;
					$dynstairlist[$dsindex][1]=$XC+$XI+$XI2;
					$dynstairlist[$dsindex][2]=$YC;
					$dynstairlist[$dsindex][3]=$ZC+$ZI+$ZI2;
					$dynstairlist[$dsindex][4]=$slopedir;
					$dynstairlist[$dsindex][5]=0;
					$dynstairlist[$dsindex][6]=$YV;
					$dsindex += 1;
					$dynstairlist[$dsindex][0]=-2;
					$dynstairlist[$dsindex][1]=$XC+$XI;
					$dynstairlist[$dsindex][2]=$YC+$YV;
					$dynstairlist[$dsindex][3]=$ZC+$ZI;
					$dynstairlist[$dsindex][4]=$slopedir;
					$dynstairlist[$dsindex][5]=0;
					$dynstairlist[$dsindex][6]=$YV;
					$dsindex += 1;
					$dynstairlist[$dsindex][0]=-3;
					$dynstairlist[$dsindex][1]=$XC+$XI+$XI2;
					$dynstairlist[$dsindex][2]=$YC+$YV;
					$dynstairlist[$dsindex][3]=$ZC+$ZI+$ZI2;
					$dynstairlist[$dsindex][4]=$slopedir;
					$dynstairlist[$dsindex][5]=0;
					$dynstairlist[$dsindex][6]=$YV;
					$odsindex2 = $dsindex;
				} else {
					$dsindex += 1;
					$dynstairlist[$dsindex][0]=-4;
					$dynstairlist[$dsindex][1]=$XC+$XI+$XI2;
					$dynstairlist[$dsindex][2]=$YC;
					$dynstairlist[$dsindex][3]=$ZC+$ZI+$ZI2;
					$dynstairlist[$dsindex][4]=$slopedir;
					$dynstairlist[$dsindex][5]=0;
					$dynstairlist[$dsindex][6]=$YV;
					$odsindex2 = $dsindex;
				};

				# move to the new coordinate and continue checking
				$XC += ( $XI+$XI2 );
				$YC += 1;
				$ZC += ( $ZI+$ZI2 );

				# increment our count of middle stair segments.
				$midsegs += 1;

				last;
			};

			# skip dynamic stair placement if we were not able to find a path. 
			last if ( ! $slopedir );
		};

		# look for an ending cell.
		my $enddir = 0;
		my @dirlist = &randomdirectionlist(1, $XC, $YC, $ZC);
		foreach my $checkdir ( @dirlist ) {
			my ( $XI, $YI, $ZI ) = getmazedirection($checkdir);
			# skip this direction if the desired cells are in use
			my $celluse = getcelluse( $XC+$XI, $YC, $ZC+$ZI );
			next if ( $celluse );

			# skip this direction if the desired cells are part of a room
			my $roomid = getroomid( $XC+$XI, $YC, $ZC+$ZI );
			next if ( $roomid );

			# make sure we are still within the proper bounds.
			my $valid = checkbounds( $XC+$XI, $YC, $ZC+$ZI );
			next if ( ! $valid );

			# skip this direction if the desired cells are already marked
			my $dslistmatch = scandynstairlist( $XC+$XI, $YC, $ZC+$ZI );
			next if ( $dslistmatch );

			$enddir = $checkdir;

			# record the ending cell.
			$dsindex += 1;
			$dynstairlist[$dsindex][0]=$enddir;
			$dynstairlist[$dsindex][1]=$XC+$XI;
			$dynstairlist[$dsindex][2]=$YC;
			$dynstairlist[$dsindex][3]=$ZC+$ZI;
			$dynstairlist[$dsindex][4]=0;
			$dynstairlist[$dsindex][5]=-1;
			$dynstairlist[$dsindex][6]=$YV;
			$dynstairlist[$odsindex][5]=$enddir;
			$dynstairlist[$odsindex2][5]=$enddir;

			$dirfound = -1;
			$dynstair = 1;

			last;
		};

		# skip this path if we couldn't find even one stair segment.
		if ( $dsindex < 3 ) {
			$dirfound = 0;
			$dynstair = 0;
		};

		print "cfs dynstair midsegs $midsegs min $minsize max $maxsize\n" if ( $debug3 );

		if ( ( $midsegs < $minsize ) || ( $midsegs > $maxsize ) ) {
			$dirfound = 0;
			$dynstair = 0;
		};

		if ( $dirfound ) {
			foreach my $index ( 1 .. $dsindex ) {
				my $start = $dynstairlist[$index][0];
				my $xpos = $dynstairlist[$index][1];
				my $ypos = $dynstairlist[$index][2];
				my $zpos = $dynstairlist[$index][3];
				my $slope = $dynstairlist[$index][4];
				my $end = $dynstairlist[$index][5];
				my $angle = $dynstairlist[$index][6];
				next if ( $start == -1 || $start == -2 );
				print "dynstairlist idx $index coord $xpos $ypos $zpos start $start slope $slope angle $angle end $end\n" if ( $debug3 );
			};
		};
	    };
	};
		    
	# adjust for high/low priority directions
	$dirfound = $hipridir if ( $hipridir != 0 );
	$dirfound = $lopridir if ($dirfound == 0 && $lopridir != 0 );

	print "checkforhallpath $X $Y $Z returns dir $dirfound crossover $crossover passthru $passthru dynstair $dynstair\n" if $debug3;
	return( $dirfound, $crossover, $passthru, $dynstair );
};

#---------------------------------------------------
# checkpassthru - check a direction for a possible passthru

sub checkpassthru {
	my ($X, $Y, $Z, $checkdir, $cc_hallid, $mode, $priority ) = @_;

	# skip vertical directions
	return 0 if ( $checkdir == 5 || $checkdir == 6 );

	# get the relative XYZ direction of the path to check
	my ( $XI, $YI, $ZI ) = getmazedirection($checkdir);

	# make sure we are checking a valid maze location
	my $valid = checkbounds( $X+($XI*2), $Y, $Z+($ZI*2));
	return 0 if !$valid;

	# skip direction if it does not contain a passthru flag
	my $thruflag = getthruflag( $X+$XI, $Y+$YI, $Z+$ZI );
	return 0 if ( ! $thruflag );

	# get the originating room ID, and abort if room ID is invalid.
	my $o_roomid = getroomid( $X+$XI, $Y+$YI, $Z+$ZI );
	return 0 if ( ! $o_roomid );

	# check if this hallway has already crossed the room being checked.
	my $match = scanroomforhallid( $o_roomid, $cc_hallid );
	return 0 if ( $match );

	my $o_roomspc = getroomspc( $o_roomid );
	# print "checkpassthru processing chasm path at $X $Y $Z direction $checkdir\n" if ( $o_roomspc == 25 );

	# get the minimum/maximum allowed passthru sizes for this class of room
	my $ptminsize = $roomclass[$o_roomspc][10];
	my $ptmaxsize = $roomclass[$o_roomspc][11];

	# get room size information to determine maximum span size
	my ($XR, $YR, $ZR, $XS, $YS, $ZS) = getroompos( $o_roomid );
	my $maxthruspan = $XS;
	$maxthruspan = $ZS if ( $ZS > $XS );

	# get attributes of start of potential path.
	my ( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
		$ch_dist, $ch_feffectlvl, $ch_feffecttype, $ch_ceffectlvl, $ch_ceffecttype ) =
	 	getcellinfo( $X, $Y, $Z );

	# check for passthru restrictions
	my ( $hvalid_b37, $hallspc_b37) = gethallflag( $X, $Y, $Z, 37 );
	my ( $hvalid_b38, $hallspc_b38) = gethallflag( $X, $Y, $Z, 38 );
	my ( $hvalid_b39, $hallspc_b39) = gethallflag( $X, $Y, $Z, 39 );

	# get room priority flag
	my ( $valid_b44, $roomspc_b44) = getroomspcflag( $o_roomspc, 44 );

	# print "checkpassthru $X $Y $Z dir $checkdir\n";

	my $midspanlen = 0;
	foreach my $midcell ( 1..$maxthruspan) {

		# get attributes of this potential span segment
		my ( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
			$ch_dist, $ch_feffectlvl, $ch_feffecttype, $ch_ceffectlvl, $ch_ceffecttype ) =
			getcellinfo( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );

		# skip this span if cell is invalid, not part of the same room, or is already in use.
		last if ( ! $ch_valid );
		last if ( ! $ch_roomid );
		last if ( $ch_roomid && ( $ch_roomid != $o_roomid ) );
		# last if ( $ch_celluse );

		# this span is invalid if it already has a cellspc value.
		my $cellspc = getcellspc($X+($XI*$midcell), $Y, $Z+($ZI*$midcell));
		last if ( $cellspc );

		# abandon this direction if we have a door present
		my $doorflag = getdoorflag( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );
		if ( ! $doorflag ) {
			my $doorfound = lookupdoor( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );
			if ( $doorfound ) {
				$midspanlen = 0;
				last;
			};
		};

		# skip this direction if hall class requires elevated passthrus and we have a floor.
		if ( $hallspc_b37 && ( $ch_segment & 32 ) ) {
			$midspanlen = 0;
			last;
		};
		# skip this direction if hall class requires ground-level passthrus and we have no floor.
		if ( $hallspc_b38 && ( ! ( $ch_segment & 32 ) ) ) {
			$midspanlen = 0;
			last;
		};

		$midspanlen = $midcell;
	};

	# skip this direction if the passthru span length would violate the single-span-only requirement.
	$midspanlen = 0 if ( $hallspc_b39 && ( $midspanlen > 1 ));

	# skip this direction if we are checking for a priority path and do not have a priority flag on the room.
	$midspanlen = 0 if ( $priority && ( ! $roomspc_b44 ));

	# skip this direction if it falls outside of the minimum/maximum span size allowed by the room.
	$midspanlen = 0 if ( $midspanlen < $ptminsize );
	$midspanlen = 0 if ( $midspanlen > $ptmaxsize );

	return 0 if ! $midspanlen;

	my $endspan = $midspanlen + 1;

	# get attributes of end of potential path.
	( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
		$ch_dist, $ch_feffectlvl, $ch_feffecttype, $ch_ceffectlvl, $ch_ceffecttype ) =
		getcellinfo( ($X+($XI*$endspan)), $Y, ($Z+($ZI*$endspan)) );

	# skip to next direction if this cell is not valid or a room
	return 0 if ( !$ch_valid || $ch_roomid );

	# skip to next direction if start and end are same hallway ID under mode 1.
	my $st_hallid = gethallid( $X, $Y, $Z );
	my $end_hallid = gethallid( $X+($XI*$endspan), $Y, $Z+($ZI*$endspan));
	return 0 if ( $st_hallid == $end_hallid && $mode == 1 );

	# skip to the next direction if the cell thread ownerships are different in mode 1
	my $st_threadfield = $thrmazegrid[$X][$Y][$Z];
	my $end_threadfield = $thrmazegrid[$X+($XI*$endspan)][$Y][$Z+($ZI*$endspan)];
	return 0 if ( $st_threadfield != $end_threadfield && $mode == 1 );

	# skip to next direction if start or end are in a downward VHE segment 
	my $st_vhe = getvhe( $X, $Y, $Z );
	my $end_vhe = getvhe( $X+($XI*$endspan), $Y, $Z+($ZI*$endspan));
	return 0 if ( $st_vhe >= 0b101 || $end_vhe >= 0b101 );

	# skip if cell is used and we are mode 0
	return 0 if ( $ch_celluse && $mode == 0 );

	# get the hallway special field for the direction we are checking
	my $ch_endcellspc = getcellspc($X+($XI*$endspan), $Y, $Z+($ZI*$endspan));

	# skip to next direction if this direction already has special hallway types
	return 0 if ( $ch_endcellspc );

	# verify that the far end of the passthru is not a dead-end (mode 0 only)
	my $notdead = 0;
	my @dirlist = &randomnumberlist(4);
	foreach my $checkpthru ( @dirlist ) {
		my ( $XC, $YC, $ZC ) = getmazedirection($checkpthru);
		my $XF = ( $XC + $X + ($XI*$endspan) );
		my $YF = ( $Y + $YI );
		my $ZF = ( $ZC + $Z + ($ZI*$endspan) );
		my $valid = checkbounds ( $XF, $YF, $ZF );
		next if ! $valid;
		my $celluse = getcelluse( $XF, $YF, $ZF );
			$notdead = 1 if ! $celluse;
	};
	return 0 if ( ! $notdead && $mode == 0 );

	my $passthru = $midspanlen;

	# print "checkpassthru $X $Y $Z midspan $midspanlen\n" if $passthru;

	return( $passthru );
};

#---------------------------------------------------
# checkcrossover - check a direction for a possible crossover

sub checkcrossover {

	my ($X, $Y, $Z, $checkdir, $cc_hallid, $mode ) = @_;

	# skip vertical directions
	return 0 if ( $checkdir == 5 || $checkdir == 6 );

	# do not allow us to cross back over our own path or if our path is vertical
	my $backdir = getbacktrack( $X, $Y, $Z );
	return 0 if ( $backdir == $checkdir || $backdir == 5 || $backdir == 6 );

	# get the relative XYZ direction of the path to check
	my ( $XI, $YI, $ZI ) = getmazedirection($checkdir);

	# make sure we are checking a valid maze location
	my $valid = checkbounds( $X+($XI*2), $Y, $Z+($ZI*2));
	return 0 if !$valid;

	# get attributes of start of potential path.
	my ( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
	$ch_dist, $ch_feffectlvl, $cd_feffecttype, $cd_ceffectlvl, $cd_ceffecttype );
	# 	getcellinfo( $X, $Y, $Z );

	$ch_roomid = getroomid( $X, $Y, $Z );
	$ch_paths = getpathflags( $X, $Y, $Z );

	# skip to next direction if starting cell is a room or has a vertical path
	return 0 if ( $ch_roomid || (( $ch_paths & 48 ) != 48) );

	# set mask of side walls required for mid-spans.
	my $thruwallmask;
	$thruwallmask = 0x33 if $XI;
	$thruwallmask = 0x3c if $ZI;

	my $midspanlen = 0;
	foreach my $midcell ( 1..$maxcrossspan) {

		# get attributes of this potential span segment
		( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
			$ch_dist, $ch_feffectlvl, $cd_feffecttype, $cd_ceffectlvl, $cd_ceffecttype ) =
			getcellinfo( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );

		# this span is invalid if it is a room or is marked as unused
		last if ( !$ch_valid || $ch_roomid || ! $ch_celluse );

		# this span is invalid if it has the wrong wall settings
		last if (( $ch_paths & $thruwallmask ) != $thruwallmask );

		# this span is invalid if it already has a special hallway value.
		my $cellspc = getcellspc($X+($XI*$midcell), $Y, $Z+($ZI*$midcell));
		last if ( $cellspc );

		# this span is invalid if we are jumping our own hallway under mode 0
		my $ch_hallid = gethallid( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );
		last if ( $ch_hallid == $cc_hallid );
		# last if ( $ch_hallid == $cc_hallid && $mode == 0 );

		# this span is invalid if any midspan points are adjacent to a room entrance
		my $ch_roomid = getroomid( $X+($XI*$midcell)+$ZI, $Y, $Z+($ZI*$midcell)+$XI );
		last if $ch_roomid;
		$ch_roomid = getroomid( $X+($XI*$midcell)-$ZI, $Y, $Z+($ZI*$midcell)-$XI );
		last if $ch_roomid;

		# this span is invalid if we have an FEV set for the midspan point
		my $ch_fev = getfev( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );
		last if $ch_fev;

		$midspanlen = $midcell;
	}

	return 0 if ! $midspanlen;

	my $endspan = $midspanlen + 1;

	# get attributes of end of potential path.
	( $ch_valid, $ch_celluse, $ch_paths, $ch_backdir, $ch_segment, $ch_roomid,
		$ch_dist, $ch_feffectlvl, $cd_feffecttype, $cd_ceffectlvl, $cd_ceffecttype ) =
		getcellinfo( ($X+($XI*$endspan)), $Y, ($Z+($ZI*$endspan)) );

	# skip to next direction if this cell is not valid or a room
	return 0 if ( !$ch_valid || $ch_roomid );

	# skip to next direction if start and end are same hallway ID under mode 1.
	my $st_hallid = gethallid( $X, $Y, $Z );
	my $end_hallid = gethallid( $X+($XI*$endspan), $Y, $Z+($ZI*$endspan));
	return 0 if ( $st_hallid == $end_hallid && $mode == 1 );

	# skip to the next direction if the cell thread ownerships are different in mode 1
	my $st_threadfield = $thrmazegrid[$X][$Y][$Z];
	my $end_threadfield = $thrmazegrid[$X+($XI*$endspan)][$Y][$Z+($ZI*$endspan)];
	return 0 if ( $st_threadfield != $end_threadfield && $mode == 1 );

	# skip to next direction if start or end are in a downward VHE segment 
	my $st_vhe = getvhe( $X, $Y, $Z );
	my $end_vhe = getvhe( $X+($XI*$endspan), $Y, $Z+($ZI*$endspan));
	return 0 if ( $st_vhe >= 0b101 || $end_vhe >= 0b101 );

	# skip if cell is used and we are mode 0
	return 0 if ( $ch_celluse && $mode == 0 );

	# get the hallway special field for the direction we are checking
	my $ch_endcellspc = getcellspc($X+($XI*$endspan), $Y, $Z+($ZI*$endspan));

	# skip to next direction if this direction already has special hallway types
	return 0 if ( $ch_endcellspc );

	# verify that the far end of the crossover is not a dead-end (mode 0 only)
	my $notdead = 0;
	my @dirlist = &randomnumberlist(4);
	foreach my $checkcross ( @dirlist ) {
		my ( $XC, $YC, $ZC ) = getmazedirection($checkcross);
		my $XF = ( $XC + $X + ($XI*$endspan) );
		my $YF = ( $Y + $YI );
		my $ZF = ( $ZC + $Z + ($ZI*$endspan) );
		my $valid = checkbounds ( $XF, $YF, $ZF );
		next if ! $valid;
		my $celluse = getcelluse( $XF, $YF, $ZF );
			$notdead = 1 if ! $celluse;
	};
	return 0 if ( ! $notdead && $mode == 0 );

	# perform a comparison of midspan hallway types to endpoints for mode 1
	foreach my $midcell ( 1..$midspanlen) {
		last if ( $mode != 1 );

		# get the midspan hallway ID
		my $mid_hallid = gethallid( $X+($XI*$midcell), $Y, $Z+($ZI*$midcell) );

		# disallow crossing over the same hallway ID as the end points.
		return 0 if ( $mid_hallid == $st_hallid || $mid_hallid == $end_hallid );
	};
		
	my $crossover = $midspanlen;

	return( $crossover );
};
# ---------------------------------------------------------------
# checkforroompath - check around a room cell for an available move path

sub checkforroompath {
	my ( $xloc, $yloc, $zloc ) = @_;
	my ( $checkdir, $found, $celluse, $roomspc ) = ( 0,0,0,0 );
	my ( $XR, $YR, $ZR, $XS, $YS, $ZS ) = ( 0,0,0,0,0,0 );

	# get room information which could alter the path check
	my $roomid = getroomid( $xloc, $yloc, $zloc );
	$roomspc = getroomspc( $roomid ) if $roomid > 0;
	($XR, $YR, $ZR, $XS, $YS, $ZS) = getroompos( $roomid ) if $roomid > 0;

	# check if room allows vertical access - room special flag bit 0
	my ( $valid_b0, $roomspc_b0) = getroomspcflag( $roomspc, 0 );

	# check if the level allows vertical access - level special flag bit 7
	my ( $valid_b7, $levelspc_b7) = getlevelflag( $yloc, 7 );

	# check vertical directions if options and room and level classes allow it
	if ( $verticaldoors && $updowndirs && (! $roomspc_b0) && ( ! $levelspc_b7 )) {
	    if ( $yloc-1 >= 0 ) {
		$celluse = getcelluse( $xloc, $yloc-1, $zloc );
		my ( $ulvalid_b7, $ulevelspc_b7) = getlevelflag( $yloc-1, 7 );
		my ( $uhvalid_b0, $uhallspc_b0) = gethallflag( $xloc, $yloc-1, $zloc, 0 );
		my $ch_roomid = getroomid( $xloc, $yloc-1, $zloc );
		( $found, $checkdir ) = ( 1,5 ) if ($celluse == 0 && (! $ch_roomid) && ( ! $ulevelspc_b7 ) && ( ! $uhallspc_b0 ));
	    };

	    if ( $yloc+1 <= ($ymazesize-1)) {
		$celluse = getcelluse( $xloc, $yloc+1, $zloc );
		my ( $dlvalid_b7, $dlevelspc_b7) = getlevelspcflag( $yloc+1, 7 );
		my ( $dhvalid_b0, $dhallspc_b0) = gethallflag( $xloc, $yloc+1, $zloc, 0 );
		my $ch_roomid = getroomid( $xloc, $yloc+1, $zloc );
		( $found, $checkdir ) = ( 1,6 ) if ($celluse == 0 && (! $ch_roomid) && ( ! $dlevelspc_b7 ) && ( ! $dhallspc_b0 ));
	    };
	};

	# randomize X/Z check priority for most rooms
	my $XZPRI = int(rand(2));

	my ( $valid_b10, $roomspc_b10) = getroomspcflag( $roomspc, 10 );

	# non-random priority for narrow room types with room special flag bit 10 set.
	$XZPRI = 0 if ( $roomspc_b10 && $XS == 1 );
	$XZPRI = 1 if ( $roomspc_b10 && $ZS == 1 );

	my ($foundroom, $foundroomdir) = (0,0);

	if ( $XZPRI == 0 ) {
		if ( $xloc-1 >= 0 ) {
			$celluse = getcelluse( $xloc-1, $yloc, $zloc );
			my $ch_roomid = getroomid( $xloc-1, $yloc, $zloc );
			if ($celluse == 0 && $ch_roomid != $roomid ) {
				( $found, $checkdir ) = ( 1,1 );
				( $foundroom, $foundroomdir ) = ($ch_roomid, 1) if $ch_roomid;
			};
		};

		if ( $xloc+1 <= ($xmazesize-1)) {
			$celluse = getcelluse( $xloc+1, $yloc, $zloc );
			my $ch_roomid = getroomid( $xloc+1, $yloc, $zloc );
			if ($celluse == 0 && $ch_roomid != $roomid ) {
				( $found, $checkdir ) = ( 1,2 );
				( $foundroom, $foundroomdir ) = ($ch_roomid, 2) if $ch_roomid;
			};
		};
	};

	if ( $zloc-1 >= 0 ) {
		$celluse = getcelluse( $xloc, $yloc, $zloc-1 );
		my $ch_roomid = getroomid( $xloc, $yloc, $zloc-1 );
		if ($celluse == 0 && $ch_roomid != $roomid ) {
			( $found, $checkdir ) = ( 1,3 );
			( $foundroom, $foundroomdir ) = ($ch_roomid, 3) if $ch_roomid;
		};
	};

	if ( $zloc+1 <= ($zmazesize-1)) {
		$celluse = getcelluse( $xloc, $yloc, $zloc+1 );
		my $ch_roomid = getroomid( $xloc, $yloc, $zloc+1 );
		if ($celluse == 0 && $ch_roomid != $roomid ) {
			( $found, $checkdir ) = ( 1,4 );
			( $foundroom, $foundroomdir ) = ($ch_roomid, 4) if $ch_roomid;
		};
	};

	if ( $XZPRI == 1 ) {
		if ( $xloc-1 >= 0 ) {
			$celluse = getcelluse( $xloc-1, $yloc, $zloc );
			my $ch_roomid = getroomid( $xloc-1, $yloc, $zloc );
			if ($celluse == 0 && $ch_roomid != $roomid ) {
				( $found, $checkdir ) = ( 1,1 );
				( $foundroom, $foundroomdir ) = ($ch_roomid, 1) if $ch_roomid;
			};
		};

		if ( $xloc+1 <= ($xmazesize-1)) {
			$celluse = getcelluse( $xloc+1, $yloc, $zloc );
			my $ch_roomid = getroomid( $xloc+1, $yloc, $zloc );
			if ($celluse == 0 && $ch_roomid != $roomid ) {
				( $found, $checkdir ) = ( 1,2 );
				( $foundroom, $foundroomdir ) = ($ch_roomid, 2) if $ch_roomid;
			};
		};
	};

	# prioritize last found room-to-room entryway if room2roompriority option is enabled.
	my $selroom = 0;
	( $found, $checkdir, $selroom ) = ( 1, $foundroomdir, $foundroom ) if ( $foundroom && $room2roompriority );

	return( $found, $checkdir, $selroom );
};

#------------------------------------------------------------------------------
# scandynstairlist - scan dynamic stair coordinate list for a particular match

sub scandynstairlist {
	my ( $X, $Y, $Z ) = @_;

	my $indexmatch = 0;

	foreach my $index ( 1 .. $dsindex ) {
		next if ( $X != $dynstairlist[$index][1] );
		next if ( $Y != $dynstairlist[$index][2] );
		next if ( $Z != $dynstairlist[$index][3] );

		$indexmatch = $index;
		last;
	};
	return( $indexmatch );
};

#------------------------------------------------------------------------------
# clearallpaths - clear all wall flags for a particular cell

sub clearallpaths {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	# clear the wall flag cells
	$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $pathmask ) ^ $pathmask );
	return 1;
};

#------------------------------------------------------------------------------
# setstartcell - set a cell to be useable as a starting location

sub setstartcell {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $cellusemask |
		$backmask)^($cellusemask | $backmask ));
	return 1;
};

#------------------------------------------------------------------------------
# setipath - set the reverse wall flags for a particular direction

sub setipath {
	my ( $X, $Y, $Z, $DIR ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my ( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($DIR);

	# set the requested wall flag on the current cell
	$mazegrid[$X][$Y][$Z] = ( $mazegrid[$X][$Y][$Z] | $rdirmask );
	$auxmazegrid[$X][$Y][$Z] = ( $auxmazegrid[$X][$Y][$Z] | $srdirmask );
	return 1;
};

#------------------------------------------------------------------------------
# cleardiagpath - clear the diag path flag for a cell

sub cleardiagpath {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	# clear the diag path flag on the requested cell
	$mazegrid[$X][$Y][$Z] = ( ( $mazegrid[$X][$Y][$Z] | $diagpathmask ) ^ $diagpathmask );

	return 1;
};

#------------------------------------------------------------------------------
# getdiagpath - get the diag path flag for a cell

sub getdiagpath {
	my ( $X, $Y, $Z ) = @_;
	return ( 0, 0 ) if (! checkbounds( $X, $Y, $Z ));

	# get the diag path flag on the requested cell
	my $diagpath = ( ( $mazegrid[$X][$Y][$Z] & $diagpathmask ) >> $diagpathshft );

	return ( 1, $diagpath );
};


#------------------------------------------------------------------------------
# setdiagpath - set the diag path flag for a cell

sub setdiagpath {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	# set the diag path flag on the requested cell
	$mazegrid[$X][$Y][$Z] = ( $mazegrid[$X][$Y][$Z] | $diagpathmask );

	return 1;
};

#------------------------------------------------------------------------------
# setpath - set the wall flags for a particular direction

sub setpath {
	my ( $X, $Y, $Z, $DIR ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my ( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($DIR);

	# set the requested wall flag on the current cell
	$mazegrid[$X][$Y][$Z] = ( $mazegrid[$X][$Y][$Z] | $fdirmask );
	$auxmazegrid[$X][$Y][$Z] = ( $auxmazegrid[$X][$Y][$Z] | $sfdirmask );
	return 1;
};

#------------------------------------------------------------------------------
# clearpath - clear the wall flags for a particular direction

sub clearpath {
	my ( $X, $Y, $Z, $DIR ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my ( $fdirmask, $rdirmask ) = getdirmasks($DIR);

	# clear the requested wall flag on the current cell
	$mazegrid[$X][$Y][$Z] = (( $mazegrid[$X][$Y][$Z] | $fdirmask ) ^ $fdirmask );
	return 1;
};

#------------------------------------------------------------------------------
# getdoorlist - get a list of doors associated with the specified room

sub getdoorlist {
	my $room = $_[0];
	my ($xc, $yc, $zc, $xs, $ys, $zs) = getroompos( $room );
	my ($doorcount, $pridoorcount) = (0,0);

	# scan the room for door flags and add them to the list
	foreach my $yinc ($yc .. $yc+$ys-1) {
            foreach my $xinc ($xc .. $xc+$xs-1) {
        	foreach my $zinc ($zc .. $zc+$zs-1) {

			# skip this cell if it is not part of this room
			my $chkroom = getroomid( $xinc, $yinc, $zinc );
			next if ( $chkroom != $room );

			# get the door/priority door flags for the cell
			my $doorflag = getdoorflag( $xinc, $yinc, $zinc);
			my $pridoorflag = getpridoorflag( $xinc, $yinc, $zinc);

			if ( $doorflag == 1 ) {
				$doorcount += 1;
				$doorlist[$doorcount][0]=$xinc;
				$doorlist[$doorcount][1]=$yinc;
				$doorlist[$doorcount][2]=$zinc;
			};
			if ( $pridoorflag == 1 ) {
				$pridoorcount += 1;
				$pridoorlist[$pridoorcount][0]=$xinc;
				$pridoorlist[$pridoorcount][1]=$yinc;
				$pridoorlist[$pridoorcount][2]=$zinc;
			};
		}
	    }
	}
	return( $doorcount, $pridoorcount );
};

#------------------------------------------------------------------------------
# setcelldist - set the distance bit field and thread ID of a cell

sub setcelldist {
	my ( $X, $Y, $Z, $distance, $thread) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	print "setcelldist at $X $Y $Z dist $distance thread $thread\n" if $debug3;
	my ( $highdistval) = getthreadhighdist( $thread );
	setthreadhighdist( $thread, $X, $Y, $Z, $distance ) if ($distance > $highdistval );
	my $shifteddist = ( $distance >> $distrightshift );
	$shifteddist = ( $distmask >> $distshft) if $shifteddist > ($distmask >> $distshft) ;
	$distance = 0 if $distance < 0;
	$distmazegrid[$X][$Y][$Z] =
		(( $distmazegrid[$X][$Y][$Z] | $distmask )^$distmask) | ( $shifteddist << $distshft);
	if ( $thread == 0 ) {
	    $thrmazegrid[$X][$Y][$Z] = 0;
	} elsif ( $thread > 0 ) {
	    $thrmazegrid[$X][$Y][$Z] = ( $thrmazegrid[$X][$Y][$Z] | ( 1 << ($thread - 1 )));
	};
	return 1;
};

#------------------------------------------------------------------------------
# checkbounds - check if a point is within maze boundaries.

sub checkbounds {
	my ( $X, $Y, $Z ) = @_;
	my $valid = 1;
	$valid = 0 if ( ($X < 0)||($X > ($xmazesize-1)) );
	$valid = 0 if ( ($Y < 0)||($Y > ($ymazesize-1)) );
	$valid = 0 if ( ($Z < 0)||($Z > ($zmazesize-1)) );

	return( $valid );
};

#------------------------------------------------------------------------------
# getcelldist - get the distance bit field in a cell

sub getcelldist {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	my $rmdist = (( $distmazegrid[$X][$Y][$Z] & $distmask ) >> $distshft);
	return( $rmdist );
};

#------------------------------------------------------------------------------
# getpathflags - get the path flags for a cell

sub getpathflags {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	my $pathval = ( ( $mazegrid[$X][$Y][$Z] & $pathmask ) >> $pathshft );

	return( $pathval );
};

#------------------------------------------------------------------------------
# setnrflag - set the noroom flag for a cell

sub setnrflag {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$adjmazegrid[$X][$Y][$Z] = ( $adjmazegrid[$X][$Y][$Z] | $noroommask );

	return ( 1 );
};

#------------------------------------------------------------------------------
# getnrflag - get the noroom flag for a cell

sub getnrflag {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	my $nrflag = ( ( $adjmazegrid[$X][$Y][$Z] & $noroommask ) >> $noroomshft );

	return( $nrflag );
};

#------------------------------------------------------------------------------
# clearcelluse - clear the use flag for a cell

sub clearcelluse {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = (($mazegrid[$X][$Y][$Z] | $cellusemask ) ^ $cellusemask );

	return( 1 );
};

#------------------------------------------------------------------------------
# setpillarflag - set the pillar flag for a group of cells

sub setpillarflag {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	return ( 0 ) if (! checkbounds( $X+1, $Y, $Z+1 ));

	$adjmazegrid[$X][$Y][$Z] = ($adjmazegrid[$X][$Y][$Z] | $pillarmask );
	$adjmazegrid[$X+1][$Y][$Z] = ($adjmazegrid[$X+1][$Y][$Z] | $pillarmask );
	$adjmazegrid[$X][$Y][$Z+1] = ($adjmazegrid[$X][$Y][$Z+1] | $pillarmask );
	$adjmazegrid[$X+1][$Y][$Z+1] = ($adjmazegrid[$X+1][$Y][$Z+1] | $pillarmask );

	return( 1 );
};

#------------------------------------------------------------------------------
# setumflag - set the unmined flag for a cell

sub setumflag {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$adjmazegrid[$X][$Y][$Z] = ($adjmazegrid[$X][$Y][$Z] | $unminedmask );

	return( 1 );
};

#------------------------------------------------------------------------------
# setcelluse - set the use flag for a cell

sub setcelluse {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | $cellusemask );

	print "setcelluse called for $X $Y $Z\n" if $debug3;

	return( 1 );
};

#------------------------------------------------------------------------------
# getpillarflag - get the pillar flag for a cell

sub getpillarflag {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	my $pillar = ( ( $adjmazegrid[$X][$Y][$Z] & $pillarmask ) >> $pillarshft );

	return( $pillar );
};

#------------------------------------------------------------------------------
# getumflag - get the unmined flag for a cell

sub getumflag {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	my $umflag = ( ( $adjmazegrid[$X][$Y][$Z] & $unminedmask ) >> $unminedshft );

	return( $umflag );
};

#------------------------------------------------------------------------------
# getcelluse - get the use flag for a cell

sub getcelluse {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	my $celluse = ( ( $mazegrid[$X][$Y][$Z] & $cellusemask ) >> $celluseshft );

	print "getcelluse for $X $Y $Z is $celluse\n" if $debug3;

	return( $celluse );
};

#------------------------------------------------------------------------------
# setobjectclasses - specify object characteristics

sub setobjectclasses {
	# first array field: object class identifier
	# second array field: 0=name, 1/2=special flags, 3=file ID
	# 4=X/Y/Z size and X/Y/Z offset, 5=object value, 6=dataset classes req'd,
	# 7=variations
	#
	# 1 - selection flags:	0x00000001	bit  0:	treasure object
	#			0x00000002	bit  1:	architectural object
	#			0x00000004	bit  2:	room-only object
	#			0x00000008	bit  3:	hallway-only object
	#			0x00000010	bit  4:	vhe not allowed
	#			0x00000020	bit  5:	upper vhe required
	#			0x00000040	bit  6:	lower vhe required
	#			0x00000080	bit  7:	exact height required
	#			0x00000100	bit  8:	exclusive object in cell
	#			0x00000200	bit  9:	C/O directionals require walls
	#			0x00000400	bit 10:	non-directional disallows adjacent walls
	#			0x00000800	bit 11:	NS/EW directionals require corridors
	#			0x00001000	bit 12: C/O directionals are offset against wall
	#			0x00002000	bit 13: C/O directionals are offset away from wall
	#			0x00004000	bit 14: C/O object requires solid walls
	#			0x00008000	bit 15: C/O object requires door/arch wall
	#			0x00010000	bit 16:	floor effects not allowed
	#			0x00020000	bit 17: object requires a solid floor
	#			0x00040000	bit 18: object requires a solid ceiling
	#			0x00080000	bit 19:	object cannot occupy a cell with an up/down ladder
	#			0x00100000	bit 20: cell special flags not allowed
	#			0x00200000	bit 21: 
	#			0x00400000	bit 22:	
	#			0x00800000	bit 23:	
	#			0x01000000	bit 24:	
	#			0x02000000	bit 25: 
	#			0x04000000	bit 26: 
	#			0x08000000	bit 27: 
	#			0x10000000	bit 28:
	#			0x20000000	bit 29: 
	#			0x40000000	bit 30: 
	#			0x80000000	bit 31: 
	#
	# 2 - placement flags:	0x00000001	bit 32:	cardinal directional facing (N/S/E/W)
	#			0x00000002	bit 33:	ordinal directional facing (NE/SE/NW/SW)
	#			0x00000004	bit 34:	non-directional facing (ND)
	#			0x00000008	bit 35:	inline-facing (NS/EW)
	#			0x00000010	bit 36: horizontal wall versions available (0-15)
	#			0x00000020	bit 37: horiz/vert wall versions available (0-63)
	#			0x00000040	bit 38: vert-stackable versions available (U/I/L)
	#			0x00000080	bit 39: dataset-specific versions
	#			0x00000100	bit 40: random horizontal placement allowed
	#			0x00000200	bit 41: random vertical placement allowed
	#			0x00000400	bit 42: object hangs from ceiling

	$objectclass[ 0][ 0]="Glowstone Pillar";
	$objectclass[ 0][ 1]=0x00000000;
	$objectclass[ 0][ 2]=0x00000000;
	$objectclass[ 0][ 3]="glowstone-pillar";
	$objectclass[ 0][ 4]="2,3,2,0,0,0";
	$objectclass[ 0][ 5]=0;
	$objectclass[ 0][ 6]='';
	$objectclass[ 0][ 7]=1;

	$maxobjectclass = 0;
};

#------------------------------------------------------------------------------
# findobject - determine an acceptable object for a specific location

sub findobject {
	my ( $X, $Y, $Z, $objtype, $reqvalue, $objnbr );

	my ( $hall, $hclass, $roomspc, $setvalid ) = ( 0, 0, 0, 0 );
	my ( $setname, $lookupsetname ) = ( "$defaultset", '' );

	# grab general information about this cell
	my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
		getcellinfo( $X, $Y, $Z );
	my $cellspc = getcellspc( $X, $Y, $Z );
	my $vheflags = getvhe( $X, $Y, $Z );
	my ( $aobjthr, $tobjthr, $objidx, $objct ) = getobjvals( $X, $Y, $Z );

	# get the dataset name for this cell
	if ( $roomid ) {
		$roomspc = getroomspc( $roomid );
		$lookupsetname = $roomclass[$roomspc][16];
	} else {
		$hall = gethallid( $X, $Y, $Z );
		$hclass = gethallinfo( $X, $Y, $Z, 0, 0);
		$lookupsetname = gethallinfo( $X, $Y, $Z, 1, 18);
	};
	($setname, $setvalid) = getdatasetinfo( $lookupsetname );
	$setname = $defaultset if ( ! $setname || ! $setvalid );

	# determine required and disallowed flags

	my ( $reqbits1, $disbits1, $reqbits2, $disbits2 ) = ( 0, 0, 0, 0 );
	
	$reqbits1 = $reqbits1 | 0x00000001 if ( $objtype eq "T" || $objtype eq "AT" );
	$reqbits1 = $reqbits1 | 0x00000002 if ( $objtype eq "A" || $objtype eq "AT" );

	$disbits1 = $disbits1 | 0x00000001 if ( $objtype ne "T" && $objtype ne "AT" );
	$disbits1 = $disbits1 | 0x00000002 if ( $objtype ne "A" && $objtype ne "AT" );
	$disbits1 = $disbits1 | 0x00000004 if ( ! $roomid );
	$disbits1 = $disbits1 | 0x00000008 if ( ! $hall );
	$disbits1 = $disbits1 | 0x00000010 if ( $vheflags );
	$disbits1 = $disbits1 | 0x00000020 if ( $vheflags == 0b100 && ( $segment && 16 ) == 0 );
	$disbits1 = $disbits1 | 0x00000040 if ( $vheflags == 0b100 && ( $segment && 32 ) == 0 );
	$disbits1 = $disbits1 | 0x00000100 if ( $objct != 1 );
	$disbits1 = $disbits1 | 0x00000800 if ( ( $paths & 15 ) != 3 && ( $paths & 15 ) != 12 );
	$disbits1 = $disbits1 | 0x00000800 if ( ( $paths & 48 ) != 0 );
	$disbits1 = $disbits1 | 0x00010000 if ( $feffectlvl );
	$disbits1 = $disbits1 | 0x00020000 if ( ( $segment & 32 ) != 32 || ( $paths & 32 != 0 ) );
	$disbits1 = $disbits1 | 0x00040000 if ( ( $segment & 16 ) != 16 || ( $paths & 16 != 0 ) );
	$disbits1 = $disbits1 | 0x00080000 if ( ( $paths & 48 ) != 0 );
	$disbits1 = $disbits1 | 0x00100000 if ( $cellspc );

	# in a random order, examine each object for a match
	my $objmatch = 0;
	my @objectclasslist = &randomnumberlist( $maxobjectclass + 1 );
	foreach my $objectid ( @objectclasslist ) {
		my ( $objname, $objflags1, $objflags2, $objfname, $objvalue, $objvari, $objdsmatch, $XS, $YS, $ZS, $XO, $YO, $ZO ) =
			getobjinfo( $objectid, $setname );

		# check if object and location are compatible
		next if ( ! $objdsmatch );
		next if ( ( $objflags1 & $reqbits1 ) != $reqbits1 );
		next if ( ( $objflags1 & $disbits1 ) != 0 );
		next if ( ( $objflags2 & $reqbits2 ) != $reqbits2 );
		next if ( ( $objflags2 & $disbits2 ) != 0 );
		next if ( ( $reqvalue - $objvalue ) > 5 || ( $objvalue - $reqvalue ) > 5 );

		# return the first match we find
		$objmatch = $objectid;

		last;
	};
};

#------------------------------------------------------------------------------
# settowerclasses - specify tower characteristics

sub settowerclasses {
	# first array field: tower class identifier
	# second array field: 0=name, 1=special flags,
	# 2=X size, 3=Z size, 4=min Y, 5=max Y,
	# 6=file set identifier,7=max instances
	# 8,9,10=top/middle/bottom variations
	# 
	# 1 - special flags:	0x00000001	bit 0:	vert scaleable
	# 			0x00000002	bit 1:	horiz scaleable
	#

	$towerclass[ 0][ 0]="Tower";
	$towerclass[ 0][ 1]=0x00000001;
	$towerclass[ 0][ 2]=1;
	$towerclass[ 0][ 3]=1;
	$towerclass[ 0][ 4]=2;
	$towerclass[ 0][ 5]=3;
	$towerclass[ 0][ 6]="01";
	$towerclass[ 0][ 7]=99;
	$towerclass[ 0][ 8]=1;
	$towerclass[ 0][ 9]=1;
	$towerclass[ 0][10]=1;

	$towerclass[ 1][ 0]="Tower";
	$towerclass[ 1][ 1]=0x00000001;
	$towerclass[ 1][ 2]=1;
	$towerclass[ 1][ 3]=1;
	$towerclass[ 1][ 4]=2;
	$towerclass[ 1][ 5]=3;
	$towerclass[ 1][ 6]="02";
	$towerclass[ 1][ 7]=99;
	$towerclass[ 1][ 8]=1;
	$towerclass[ 1][ 9]=1;
	$towerclass[ 1][10]=1;

	$towerclass[ 2][ 0]="Tower";
	$towerclass[ 2][ 1]=0x00000001;
	$towerclass[ 2][ 2]=1;
	$towerclass[ 2][ 3]=1;
	$towerclass[ 2][ 4]=4;
	$towerclass[ 2][ 5]=9;
	$towerclass[ 2][ 6]="03";
	$towerclass[ 2][ 7]=99;
	$towerclass[ 2][ 8]=1;
	$towerclass[ 2][ 9]=1;
	$towerclass[ 2][10]=1;

	$towerclass[ 3][ 0]="Tower";
	$towerclass[ 3][ 1]=0x00000001;
	$towerclass[ 3][ 2]=1;
	$towerclass[ 3][ 3]=1;
	$towerclass[ 3][ 4]=4;
	$towerclass[ 3][ 5]=9;
	$towerclass[ 3][ 6]="04";
	$towerclass[ 3][ 7]=99;
	$towerclass[ 3][ 8]=1;
	$towerclass[ 3][ 9]=1;
	$towerclass[ 3][10]=1;

	$maxtowerclass = 3;
};

#------------------------------------------------------------------------------
# gettowerinfo - get information about a tower class

sub gettowerinfo {
	my $towertype = $_[0];
	
	my $xsize = $towerclass[$towertype][2];
	my $zsize = $towerclass[$towertype][3];
	my $yminsize = $towerclass[$towertype][4];
	my $ymaxsize = $towerclass[$towertype][5];
	my $towerid = $towerclass[$towertype][6];
	my $topvars = $towerclass[$towertype][8];
	my $midvars = $towerclass[$towertype][9];
	my $botvars = $towerclass[$towertype][10];

	return( $towerid, $topvars, $midvars, $botvars, $xsize, $zsize, $yminsize, $ymaxsize );
};

#------------------------------------------------------------------------------
# getobjinfo - get information about an object class

sub getobjinfo {
	my ( $objtype, $dsmatch ) = @_;
	
	my $objname = $objectclass[$objtype][0];
	my $objflags1 = $objectclass[$objtype][1];
	my $objflags2 = $objectclass[$objtype][2];
	my $objfname = $objectclass[$objtype][3];
	my $objvalue = $objectclass[$objtype][5];
	my $objvari = $objectclass[$objtype][7];
	
	# split out the object size and dimensions
	# this currently violates the generator/renderer data separation
	my @entry = split(',', $objectclass[$objtype][4] );
	my ( $XS, $YS, $ZS, $XO, $YO, $ZO ) = @entry;

	# look for a dataset match between specified DS and object DS list
	my $objdsmatch = 0;
	my @dsname = split(',', $objectclass[$objtype][6] );
	foreach my $dscheck ( @dsname ) {

		next if ( $dscheck ne $dsmatch );

		$objdsmatch = 1;
		last;
	};

	# dataset always matches if object doesn't specify a dataset list
	$objdsmatch = 1 if ( ! $objectclass[$objtype][6] );

	return ( $objname, $objflags1, $objflags2, $objfname, $objvalue, $objvari, $objdsmatch, $XS, $YS, $ZS, $XO, $YO, $ZO );
};

#------------------------------------------------------------------------------
# setceffectclasses - specify ceiling effect class characteristics

sub setceffectclasses {
	# first array field: ceiling effect class identifier
	# second array field: 0=name, 1=special flags,
	# 2/3=ascii ceiling effect character/color,
	# 4=insertion offset, 5/6=schematic set for rooms/hallways,
	# 7=ceiling effect type odds, 8=maximum ceiling effect level,
	# 9=minimum minecraft airspace blocks above floor,
	# 10/11=minecraft room/hall block fill type
	# 12/13=increase/decrease ceiling effect level odds
	# 14/15=random placement min/max count
	# 16/17=random placement obj H/V size
	# 18=disallowed floor effects, 19=random versions
	#
	# 1 - special flags:	0x00000001	bit  0:	minecraft static ceiling level air conversion
	#			0x00000002	bit  1:	minecraft schematic importing (segmented)
	#			0x00000004	bit  2:	minecraft schematic importing (single-unit - obsolete)
	#			0x00000008	bit  3:	minecraft schematic random placement
	#			0x00000010	bit  4:	adjacent max ceiling effect levels not allowed
	#			0x00000020	bit  5:	perform material conversion 
	#			0x00000040	bit  6:	perform segmented import with special cobweb design
	#			0x00000080	bit  7:	ceiling effect type is not allowed in rooms
	#			0x00000100	bit  8:	maximum ceiling effect level is not allowed in rooms
	#			0x00000200	bit  9:	import segments use cardinal directions
	#			0x00000400	bit 10:	segmented import includes non-layered content for max level
	#			0x00000800	bit 11: multi-layered content levels are inverted

	my $num = 0;
	$ceffectclass[$num][ 0]="Water Seepage";
	$ceffectclass[$num][ 1]=0x00000038;
	$ceffectclass[$num][ 2]='`';
	$ceffectclass[$num][ 3]=6;
	$ceffectclass[$num][ 4]=0;
	$ceffectclass[$num][ 5]='cwseep';
	$ceffectclass[$num][ 6]='cwseep';
	$ceffectclass[$num][ 7]=0;
	$ceffectclass[$num][ 8]=1;
	$ceffectclass[$num][ 9]=1;
	$ceffectclass[$num][10]=0;
	$ceffectclass[$num][11]=0;
	$ceffectclass[$num][12]=0;
	$ceffectclass[$num][13]=100;
	$ceffectclass[$num][14]=1;
	$ceffectclass[$num][15]=3;
	$ceffectclass[$num][16]=1;
	$ceffectclass[$num][17]=2;
	$ceffectclass[$num][18]=0x00000000;
	$ceffectclass[$num][19]=0;

	$num += 1;
	$ceffectclass[$num][ 0]="Lava Seepage";
	$ceffectclass[$num][ 1]=0x00000038;
	$ceffectclass[$num][ 2]='`';
	$ceffectclass[$num][ 3]=1;
	$ceffectclass[$num][ 4]=0;
	$ceffectclass[$num][ 5]='clseep';
	$ceffectclass[$num][ 6]='clseep';
	$ceffectclass[$num][ 7]=10;
	$ceffectclass[$num][ 8]=1;
	$ceffectclass[$num][ 9]=1;
	$ceffectclass[$num][10]=0;
	$ceffectclass[$num][11]=0;
	$ceffectclass[$num][12]=0;
	$ceffectclass[$num][13]=100;
	$ceffectclass[$num][14]=1;
	$ceffectclass[$num][15]=3;
	$ceffectclass[$num][16]=1;
	$ceffectclass[$num][17]=2;
	$ceffectclass[$num][18]=0x00000000;
	$ceffectclass[$num][19]=0;

	$num += 1;
	$ceffectclass[$num][ 0]="Vine Infiltration";
	$ceffectclass[$num][ 1]=0x00000038;
	$ceffectclass[$num][ 2]='`';
	$ceffectclass[$num][ 3]=2;
	$ceffectclass[$num][ 4]=0;
	$ceffectclass[$num][ 5]='vines';
	$ceffectclass[$num][ 6]='vines';
	$ceffectclass[$num][ 7]=10;
	$ceffectclass[$num][ 8]=1;
	$ceffectclass[$num][ 9]=1;
	$ceffectclass[$num][10]=0;
	$ceffectclass[$num][11]=0;
	$ceffectclass[$num][12]=1;
	$ceffectclass[$num][13]=40;
	$ceffectclass[$num][14]=5;
	$ceffectclass[$num][15]=10;
	$ceffectclass[$num][16]=1;
	$ceffectclass[$num][17]=2;
	$ceffectclass[$num][18]=0x00000000;
	$ceffectclass[$num][19]=5;

	$num += 1;
	$ceffectclass[$num][ 0]="Ceiling Erosion";
	$ceffectclass[$num][ 1]=0x00000f22;
	$ceffectclass[$num][ 2]='`';
	$ceffectclass[$num][ 3]=5;
	$ceffectclass[$num][ 4]=0;
	$ceffectclass[$num][ 5]='erosion';
	$ceffectclass[$num][ 6]='erosion';
	$ceffectclass[$num][ 7]=10;
	$ceffectclass[$num][ 8]=4;
	$ceffectclass[$num][ 9]=0;
	$ceffectclass[$num][10]=0;
	$ceffectclass[$num][11]=0;
	$ceffectclass[$num][12]=15;
	$ceffectclass[$num][13]=20;
	$ceffectclass[$num][14]=0;
	$ceffectclass[$num][15]=0;
	$ceffectclass[$num][16]=0;
	$ceffectclass[$num][17]=0;
	$ceffectclass[$num][18]=0x00000000;
	$ceffectclass[$num][19]=0;

	$maxceffectclass = $num;
};

#------------------------------------------------------------------------------
# setfeffectclasses - specify floor effect class characteristics

sub setfeffectclasses {
	# first array field: floor effect class identifier
	# second array field: 0=name, 1=special flags,
	# 2/3=ascii floor effect character/color,
	# 4=insertion offset, 5/6=schematic set for rooms/hallways,
	# 7=floor effect type odds, 8=maximum floor effect level,
	# 9=minimum minecraft airspace blocks below ceiling,
	# 10/11=minecraft room/hall block fill type
	# 12/13=increase/decrease floor effect level odds
	# 14/15=random placement min/max count
	# 16/17=random placement obj H/V size
	# 18=disallowed ceiling effects, 19=random versions
	#
	# 1 - special flags:	0x00000001	bit  0:	minecraft static floor level air conversion
	#			0x00000002	bit  1:	minecraft schematic importing (segmented)
	#			0x00000004	bit  2:	minecraft schematic importing (single-unit - obsolete)
	#			0x00000008	bit  3:	minecraft schematic random placement
	#			0x00000010	bit  4:	adjacent max floor effect levels not allowed
	#			0x00000020	bit  5:	perform material conversion 
	#			0x00000040	bit  6:	perform segmented import with special cobweb design
	#			0x00000080	bit  7:	floor effect type is not allowed in rooms
	#			0x00000100	bit  8:	maximum floor effect level is not allowed in rooms
	#			0x00000200	bit  9:	import segments use cardinal directions
	#			0x00000400	bit 10:	segmented import includes non-layered content for max level
	#			0x00000800	bit 11: multi-layered content levels are inverted

	my $num = 0;
	$feffectclass[$num][ 0]="Water Seepage";
	$feffectclass[$num][ 1]=0x00000018;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=6;
	$feffectclass[$num][ 4]=1;
	$feffectclass[$num][ 5]='wseep';
	$feffectclass[$num][ 6]='wseep';
	$feffectclass[$num][ 7]=0;
	$feffectclass[$num][ 8]=1;
	$feffectclass[$num][ 9]=1;
	$feffectclass[$num][10]=0;
	$feffectclass[$num][11]=0;
	$feffectclass[$num][12]=0;
	$feffectclass[$num][13]=100;
	$feffectclass[$num][14]=1;
	$feffectclass[$num][15]=3;
	$feffectclass[$num][16]=1;
	$feffectclass[$num][17]=2;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Lava Pitting";
	$feffectclass[$num][ 1]=0x00000202;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=1;
	$feffectclass[$num][ 4]=1;
	$feffectclass[$num][ 5]='lava';
	$feffectclass[$num][ 6]='lava';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=7;
	$feffectclass[$num][ 9]=0;
	$feffectclass[$num][10]=0;
	$feffectclass[$num][11]=0;
	$feffectclass[$num][12]=10;
	$feffectclass[$num][13]=30;
	$feffectclass[$num][14]=0;
	$feffectclass[$num][15]=0;
	$feffectclass[$num][16]=0;
	$feffectclass[$num][17]=0;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Sand Flooding";
	$feffectclass[$num][ 1]=0x00000002;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=3;
	$feffectclass[$num][ 4]=0;
	$feffectclass[$num][ 5]='rsand';
	$feffectclass[$num][ 6]='hsand';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=3;
	$feffectclass[$num][ 9]=0;
	$feffectclass[$num][10]=12;
	$feffectclass[$num][11]=12;
	$feffectclass[$num][12]=10;
	$feffectclass[$num][13]=30;
	$feffectclass[$num][14]=0;
	$feffectclass[$num][15]=0;
	$feffectclass[$num][16]=0;
	$feffectclass[$num][17]=0;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Gravel Flooding";
	$feffectclass[$num][ 1]=0x00000002;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=3;
	$feffectclass[$num][ 4]=0;
	$feffectclass[$num][ 5]='rgrav';
	$feffectclass[$num][ 6]='hgrav';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=3;
	$feffectclass[$num][ 9]=0;
	$feffectclass[$num][10]=13;
	$feffectclass[$num][11]=13;
	$feffectclass[$num][12]=10;
	$feffectclass[$num][13]=30;
	$feffectclass[$num][14]=0;
	$feffectclass[$num][15]=0;
	$feffectclass[$num][16]=0;
	$feffectclass[$num][17]=0;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Water Flooding";
	$feffectclass[$num][ 1]=0x00000011;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=4;
	$feffectclass[$num][ 4]=0;
	$feffectclass[$num][ 5]='';
	$feffectclass[$num][ 6]='';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=5;
	$feffectclass[$num][ 9]=1;
	$feffectclass[$num][10]=9;
	$feffectclass[$num][11]=8;
	$feffectclass[$num][12]=10;
	$feffectclass[$num][13]=30;
	$feffectclass[$num][14]=0;
	$feffectclass[$num][15]=0;
	$feffectclass[$num][16]=0;
	$feffectclass[$num][17]=0;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Lava Seepage";
	$feffectclass[$num][ 1]=0x00000018;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=1;
	$feffectclass[$num][ 4]=1;
	$feffectclass[$num][ 5]='lseep';
	$feffectclass[$num][ 6]='lseep';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=1;
	$feffectclass[$num][ 9]=1;
	$feffectclass[$num][10]=0;
	$feffectclass[$num][11]=0;
	$feffectclass[$num][12]=0;
	$feffectclass[$num][13]=100;
	$feffectclass[$num][14]=1;
	$feffectclass[$num][15]=3;
	$feffectclass[$num][16]=1;
	$feffectclass[$num][17]=2;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Floor Erosion";
	$feffectclass[$num][ 1]=0x00000222;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=5;
	$feffectclass[$num][ 4]=1;
	$feffectclass[$num][ 5]='erosion';
	$feffectclass[$num][ 6]='erosion';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=7;
	$feffectclass[$num][ 9]=0;
	$feffectclass[$num][10]=0;
	$feffectclass[$num][11]=0;
	$feffectclass[$num][12]=10;
	$feffectclass[$num][13]=30;
	$feffectclass[$num][14]=0;
	$feffectclass[$num][15]=0;
	$feffectclass[$num][16]=0;
	$feffectclass[$num][17]=0;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$num += 1;
	$feffectclass[$num][ 0]="Web Infestation";
	$feffectclass[$num][ 1]=0x000000d2;
	$feffectclass[$num][ 2]=',';
	$feffectclass[$num][ 3]=7;
	$feffectclass[$num][ 4]=0;
	$feffectclass[$num][ 5]='rsweb';
	$feffectclass[$num][ 6]='hsweb';
	$feffectclass[$num][ 7]=10;
	$feffectclass[$num][ 8]=4;
	$feffectclass[$num][ 9]=0;
	$feffectclass[$num][10]=30;
	$feffectclass[$num][11]=30;
	$feffectclass[$num][12]=10;
	$feffectclass[$num][13]=30;
	$feffectclass[$num][14]=0;
	$feffectclass[$num][15]=0;
	$feffectclass[$num][16]=0;
	$feffectclass[$num][17]=0;
	$feffectclass[$num][18]=0x00000000;
	$feffectclass[$num][19]=0;

	$maxfeffectclass = $num;
	
};

#------------------------------------------------------------------------------
# setdoorclasses - specify door characteristics

sub setdoorclasses {
	# first array field: door class identifier
	# second array field: 0=name, 1=special flags,
	# 2 thru 7=door character for directions 1 thru 6.
	# 8=door class selection weight, 9=water seal, 10=ansi color output
	# 11=door schematic identifier, 12=paired schematic identifier
	# 
	# 1 - special flags:	0x00000001	bit 0:	hidden
	#			0x00000002	bit 1:	trapped
	#			0x00000004	bit 2:	non-feffectable
	#			0x00000008	bit 3:	protected
	#			0x00000010	bit 4:	sealed
	#			0x00000020	bit 5:	open
	#			0x00000040	bit 6:	weak construction
	#			0x00000080	bit 7:	strong construction
	#			0x00000100	bit 8:	ground-floor only
	#			0x00000200	bit 9:	elevated only
	#			0x00000400	bit 10:	horizontal only
	#			0x00000800	bit 11:	down-only
	#			0x00001000	bit 12:	up-only
	#			0x00002000	bit 13:	vertical-only
	#			0x00004000	bit 14:	doorway
	#			0x00008000	bit 15:	archway
	#			0x00010000	bit 16:	room-to-room only
	#			0x00020000	bit 17:	canal access
	#			0x00040000	bit 18:	hall-to-hall only
	#			0x00080000	bit 19:	surface entryway
	#			0x00100000	bit 20: open-segment entryway
	#			0x00200000	bit 21: non-fev
	#
	# 2 thru 7 - single character to use for door location on the ascii grid,
	#	a false value will be interpreted to not update the ascii location.
	#
	my $num = 0;
	$doorclass[$num][0]="Opening";
	$doorclass[$num][1]=0x00004020;
	$doorclass[$num][2]='.';
	$doorclass[$num][3]='.';
	$doorclass[$num][4]='.';
	$doorclass[$num][5]='.';
	$doorclass[$num][6]='u';
	$doorclass[$num][7]='d';
	$doorclass[$num][8]=10;
	$doorclass[$num][9]=0;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=0;
	$doorclass[$num][12]=0;

	$num += 1;
	$doorclass[$num][0]="Wooden Door";
	$doorclass[$num][1]=0x00004440;
	$doorclass[$num][2]='+';
	$doorclass[$num][3]='+';
	$doorclass[$num][4]='+';
	$doorclass[$num][5]='+';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=10;
	$doorclass[$num][9]=1;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=0;

	$num += 1;
	$doorclass[$num][0]="Metal Door";
	$doorclass[$num][1]=0x00004488;
	$doorclass[$num][2]='*';
	$doorclass[$num][3]='*';
	$doorclass[$num][4]='*';
	$doorclass[$num][5]='*';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=5;
	$doorclass[$num][9]=1;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=2;
	$doorclass[$num][12]=0;

	$num += 1;
	$doorclass[$num][0]="Trapped Door";
	$doorclass[$num][1]=0x00004402;
	$doorclass[$num][2]='+';
	$doorclass[$num][3]='+';
	$doorclass[$num][4]='+';
	$doorclass[$num][5]='+';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=1;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=3;
	$doorclass[$num][12]=0;

	$num += 1;
	$doorclass[$num][0]="Hidden Arch";
	$doorclass[$num][1]=0x00008015;
	$doorclass[$num][2]='#';
	$doorclass[$num][3]='#';
	$doorclass[$num][4]='#';
	$doorclass[$num][5]='#';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=4;
	$doorclass[$num][12]=4;

	$num += 1;
	$doorclass[$num][0]="Hidden Door";
	$doorclass[$num][1]=0x00004015;
	$doorclass[$num][2]='#';
	$doorclass[$num][3]='#';
	$doorclass[$num][4]='#';
	$doorclass[$num][5]='#';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=4;
	$doorclass[$num][12]=4;

	$num += 1;
	$doorclass[$num][0]="Arch";
	$doorclass[$num][1]=0x00008420;
	$doorclass[$num][2]='.';
	$doorclass[$num][3]='.';
	$doorclass[$num][4]='.';
	$doorclass[$num][5]='.';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=10;
	$doorclass[$num][9]=0;
	$doorclass[$num][10]=2;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Sealed Arch";
	$doorclass[$num][1]=0x00008414;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=2;
	$doorclass[$num][11]=2;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Protected Arch";
	$doorclass[$num][1]=0x00008428;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=2;
	$doorclass[$num][10]=1;
	$doorclass[$num][11]=3;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Flooded Arch";
	$doorclass[$num][1]=0x00008420;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=0;
	$doorclass[$num][10]=4;
	$doorclass[$num][11]=5;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Hidden Protected Arch";
	$doorclass[$num][1]=0x00008415;
	$doorclass[$num][2]='#';
	$doorclass[$num][3]='#';
	$doorclass[$num][4]='#';
	$doorclass[$num][5]='#';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=2;
	$doorclass[$num][10]=2;
	$doorclass[$num][11]=6;
	$doorclass[$num][12]=4;

	$num += 1;
	$doorclass[$num][0]="Sealed Protected Arch";
	$doorclass[$num][1]=0x0000841c;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=1;
	$doorclass[$num][11]=7;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Trapdoor";
	$doorclass[$num][1]=0x00002003;
	$doorclass[$num][2]=0;
	$doorclass[$num][3]=0;
	$doorclass[$num][4]=0;
	$doorclass[$num][5]=0;
	$doorclass[$num][6]=0;
	$doorclass[$num][7]='^';
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=1;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Hole";
	$doorclass[$num][1]=0x00002020;
	$doorclass[$num][2]=0;
	$doorclass[$num][3]=0;
	$doorclass[$num][4]=0;
	$doorclass[$num][5]=0;
	$doorclass[$num][6]=' ';
	$doorclass[$num][7]='o';
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=0;
	$doorclass[$num][10]=5;
	$doorclass[$num][11]=2;
	$doorclass[$num][12]=2;

	$num += 1;
	$doorclass[$num][0]="Strongly Sealed Arch";
	$doorclass[$num][1]=0x00008494;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=2;
	$doorclass[$num][11]=8;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Canal Accessway";
	$doorclass[$num][1]=0x00024404;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=6;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Hidden Canal Accessway";
	$doorclass[$num][1]=0x00024405;
	$doorclass[$num][2]='#';
	$doorclass[$num][3]='#';
	$doorclass[$num][4]='#';
	$doorclass[$num][5]='#';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=2;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=6;
	$doorclass[$num][11]=4;
	$doorclass[$num][12]=4;

	$num += 1;
	$doorclass[$num][0]="Inter-room Doorway";
	$doorclass[$num][1]=0x00014000;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=80;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=3;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=0;

	$num += 1;
	$doorclass[$num][0]="Hidden Inter-room Doorway";
	$doorclass[$num][1]=0x00014001;
	$doorclass[$num][2]='#';
	$doorclass[$num][3]='#';
	$doorclass[$num][4]='#';
	$doorclass[$num][5]='#';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=20;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=3;
	$doorclass[$num][11]=4;
	$doorclass[$num][12]=4;

	$num += 1;
	$doorclass[$num][0]="Inter-hall Doorway";
	$doorclass[$num][1]=0x00044000;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=80;
	$doorclass[$num][9]=2;
	$doorclass[$num][10]=7;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Surface Arch";
	$doorclass[$num][1]=0x00088420;
	$doorclass[$num][2]='.';
	$doorclass[$num][3]='.';
	$doorclass[$num][4]='.';
	$doorclass[$num][5]='.';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=10;
	$doorclass[$num][9]=0;
	$doorclass[$num][10]=2;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Canal Archway";
	$doorclass[$num][1]=0x00028404;
	$doorclass[$num][2]='%';
	$doorclass[$num][3]='%';
	$doorclass[$num][4]='%';
	$doorclass[$num][5]='%';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=1;
	$doorclass[$num][9]=3;
	$doorclass[$num][10]=6;
	$doorclass[$num][11]=1;
	$doorclass[$num][12]=1;

	$num += 1;
	$doorclass[$num][0]="Open Hall Entryway";
	$doorclass[$num][1]=0x00100000;
	$doorclass[$num][2]='~';
	$doorclass[$num][3]='~';
	$doorclass[$num][4]='~';
	$doorclass[$num][5]='~';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=10;
	$doorclass[$num][9]=2;
	$doorclass[$num][10]=7;
	$doorclass[$num][11]=15;
	$doorclass[$num][12]=15;

	$num += 1;
	$doorclass[$num][0]="Open Canal Entryway";
	$doorclass[$num][1]=0x00120000;
	$doorclass[$num][2]='~';
	$doorclass[$num][3]='~';
	$doorclass[$num][4]='~';
	$doorclass[$num][5]='~';
	$doorclass[$num][6]=0;
	$doorclass[$num][7]=0;
	$doorclass[$num][8]=10;
	$doorclass[$num][9]=2;
	$doorclass[$num][10]=6;
	$doorclass[$num][11]=15;
	$doorclass[$num][12]=15;

	# invert up/down characters if invertlevels is enabled
	if ( $invertlevels ) {
	    foreach my $classinc ( 0..$maxdoorclass ) {
		( $doorclass[$classinc][6], $doorclass[$classinc][7] ) =
			( $doorclass[$classinc][7], $doorclass[$classinc][6] );
	    };
	};
};

#------------------------------------------------------------------------------
# sethallclasses - specify hallway characteristics

sub sethallclasses {
	# first array field: special hallway class identifier
	# second array field: variations of hallway class info
	# third array field:  0=name, 1=special hallway flags bits 0-31,
	# 2=special hallway flags bits 32-63, 3=hall global style selection,
	# 4=door flags, 5=hallway floor character,
	# 6=minimum floor effect level, 7=maximum floor effect level, 8=class selection weight,
	# 9=ansi output color, 10=upper-exp char, 11=mid-exp char, 12=lower-exp char,
	# 13=upper-exp color,14=mid-exp color, 15=lower-exp color, 16=vhe-start-odds,
	# 17=vhe-change-odds, 18=dataset name,
	# 19=maximum FEV, 20=FEV start odds, 21=FEV inc/dec odds,
	# 22=pillar placement odds, 23=pillar selection count,
	# 24=diag movement indicator char, 25=diag movement indicator color,
	# 26=vhe ledge character W/E, 27=vhe ledge character N/S,
	# 28=vhe ledge corner char, 29=vhe ledge color,
	# 30/31=maximum vhe height/depth, 32/33=default vhe height/depth,
	# 34=number of hallway class variations, 35=dead-end removal length,
	# 36/37=minimum/maximum dynamic stair length, 38=dynamic stair start odds,
	# 39=dynamic stair floor character,40=dynamic stair floor color,
	# 41=hallway type
	#
	# 1 - special flags	0x00000001	bit  0:	No vertical access
	# 			0x00000002	bit  1:	No traps allowed
	# 			0x00000004	bit  2:	No shallow pits
	# 			0x00000008	bit  3:	unused
	# 			0x00000010	bit  4:	Expandable height
	# 			0x00000020	bit  5:	Expandable depth
	# 			0x00000040	bit  6:	Auto-remove dead-ends
	# 			0x00000080	bit  7:	Open adjacent horizontal halls
	#			0x00000100	bit  8: No crossovers
	#			0x00000200	bit  9: Surface openings allowed
	#			0x00000400	bit 10: Add VHE upper edge enhancements
	#			0x00000800	bit 11: Add VHE lower edge enhancements
	#			0x00001000	bit 12: Allow FEV with upward VHE
	#			0x00002000	bit 13: Allow FEV with downward VHE
	#			0x00004000	bit 14: Disallow upward VHE hallway transitions
	#			0x00008000	bit 15: Disallow downward VHE hallway transitions
	#			0x00010000	bit 16: Do not fill lower VHE floor with lava
	#			0x00020000	bit 17: Use alt. VHE set for base of upper VHE segments
	#			0x00040000	bit 18: Use alt. VHE set for top of downward VHE segments
	#			0x00080000	bit 19: Use alt. VHE set for intermediate VHE segments
	#			0x00100000	bit 20: Remove any non-VHE pillars
	#			0x00200000	bit 21: Use default VHE height instead of random VHE
	#			0x00400000	bit 22: Add vertical transitions for dead-ends
	#			0x00800000	bit 23: Allow random FEV
	#			0x01000000	bit 24: Hallway is submerged
	#			0x02000000	bit 25: Open adjacent upper halls
	#			0x04000000	bit 26: Open adjacent lower halls
	#			0x08000000	bit 27: Add outer door extension
	#			0x10000000	bit 28: Remove extended-height pillars
	#			0x20000000	bit 29: Open entryways require endpoints
	#			0x40000000	bit 30: Replace dead-end spurs with unmined area
	#			0x80000000	bit 31: Use hall class instead of hall ID for adjacent wall removal
	#
	# 2 - special flags	0x00000001	bit 32: No floor effects
	#			0x00000002	bit 33: No ceiling effects
	#			0x00000004	bit 34: No advanced floor effects
	#			0x00000008	bit 35: No advanced ceiling effects
	#			0x00000010	bit 36: No passthrus
	#			0x00000020	bit 37: Passthrus must be elevated
	#			0x00000040	bit 38: Passthrus on ground level only
	#			0x00000080	bit 39: Single-span passthrus only
	#			0x00000100	bit 40: Dynamic stairs allowed
	#			0x00000200	bit 41: Dynamic stairs have start/stop transitions
	#			0x00000400	bit 42: Global style selection enabled
	#			0x00000800	bit 43: Local style selection enabled
	#			0x00001000	bit 44: Enable vhe stairs
	#			0x00002000	bit 45: Enable vhe corner ladders
	#			0x00004000	bit 46: Enable vhe central ladders
	#			0x00008000	bit 47: Open entryway endpoint is non-intrusive
	#
	# 3 - style selection weights/rendering, semicolon seperated fields, values are hex characters
	#			field 0 - global style weights
	#			field 1 - global style rendering
	#			field 2 - local style weights for passthrus
	#			field 3 - local style rendering for passthrus
	#			field 4 - local style weights for dynamic stairs
	#			field 5 - local style rendering for dynamic stairs
	#
	#			style rendering values:
	#			. or 0		append 'astyle#' schematic over base with default style # from hall class info
	#			1		append 'astyle#' schematic over base, but use thread # to determine style #
	#			2		append 'astyle#' schematic over base, but use Y level to determine style #
	#			3		
	#			4		
	#			5		
	#			6		
	#			7		
	#			8		
	#			9		
	#			a		append 'astyle#' schematic over base schematic
	#			b		use 'style#' schematic instead of base schematic
	#			c		append 'astyle#' schematic over 'style#' schematic
	#			d		
	#			e		
	#			f		
	#
	# 41 - hallway type	0 - other
	#			1 - unfinished
	#			2 - finished
	#			3 - utility
	#			4 - railway
	#
	my $num = 0;
	$hallclass[$num][0][ 0]="Dungeon Hallway";
	$hallclass[$num][0][ 1]=0x20000000;
	$hallclass[$num][0][ 2]=0x000001a0;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]=' ';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=3;
	$hallclass[$num][0][ 8]=10;
	$hallclass[$num][0][ 9]=7;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=0;
	$hallclass[$num][0][14]=0;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=0;
	$hallclass[$num][0][17]=0;
	$hallclass[$num][0][18]='generic hallway';
	$hallclass[$num][0][19]=3;
	$hallclass[$num][0][20]=10;
	$hallclass[$num][0][21]=30;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]='';
	$hallclass[$num][0][25]=7;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=7;
	$hallclass[$num][0][30]=0;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=2;
	$hallclass[$num][0][37]=6;
	$hallclass[$num][0][38]=3;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Ceremonial Hallway";
	$hallclass[$num][0][ 1]=0x00010037;
	$hallclass[$num][0][ 2]=0x00000012;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=69;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=69;
	$hallclass[$num][0][14]=69;
	$hallclass[$num][0][15]=69;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='ceremonial-hall';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=69;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=69;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Large Drainage Tunnel";
	$hallclass[$num][0][ 1]=0x08010037;
	$hallclass[$num][0][ 2]=0x00000012;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=68;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=68;
	$hallclass[$num][0][14]=68;
	$hallclass[$num][0][15]=68;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='drainage-large';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=68;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=68;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=3;

	$num += 1;
	$hallclass[$num][0][ 0]="Large Dungeon Hallway 3";
	$hallclass[$num][0][ 1]=0x00010037;
	$hallclass[$num][0][ 2]=0x00004012;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=67;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=67;
	$hallclass[$num][0][14]=67;
	$hallclass[$num][0][15]=67;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=50;
	$hallclass[$num][0][18]='dhall-large-3';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=67;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=67;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Small Drainage Tunnel";
	$hallclass[$num][0][ 1]=0x08010037;
	$hallclass[$num][0][ 2]=0x00002012;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=4;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=4;
	$hallclass[$num][0][14]=4;
	$hallclass[$num][0][15]=4;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='drainage-small-mid';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=4;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=4;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=1;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=2;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=3;
	$hallclass[$num][1][ 0]='RY,-99,-1';
	$hallclass[$num][1][18]='drainage-small-upper';
	$hallclass[$num][2][ 0]='RY,1,99';
	$hallclass[$num][2][18]='drainage-small-lower';

	$num += 1;
	$hallclass[$num][0][ 0]="Large Dungeon Hallway 2";
	$hallclass[$num][0][ 1]=0x00010017;
	$hallclass[$num][0][ 2]=0x00001012;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=67;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=67;
	$hallclass[$num][0][14]=67;
	$hallclass[$num][0][15]=67;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='dhall-large-2';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=67;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=67;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Large Dungeon Hallway";
	$hallclass[$num][0][ 1]=0x08010017;
	$hallclass[$num][0][ 2]=0x00004012;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=66;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=66;
	$hallclass[$num][0][14]=66;
	$hallclass[$num][0][15]=66;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='dhall-large';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=66;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=66;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Canal";
	$hallclass[$num][0][ 1]=0x260100b3;
	$hallclass[$num][0][ 2]=0x00008309;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.R.d,,,,....,,,,';
	$hallclass[$num][0][ 5]=',';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=0;
	$hallclass[$num][0][ 8]=5;
	$hallclass[$num][0][ 9]=68;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=68;
	$hallclass[$num][0][14]=68;
	$hallclass[$num][0][15]=68;
	$hallclass[$num][0][16]=20;
	$hallclass[$num][0][17]=40;
	$hallclass[$num][0][18]='canals';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=68;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=68;
	$hallclass[$num][0][30]=1;
	$hallclass[$num][0][31]=1;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=4;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=2;
	$hallclass[$num][0][37]=4;
	$hallclass[$num][0][38]=3;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=3;

	$hallclass[$num][1][18]='dry-canals';
	$hallclass[$num][1][ 0]='RY,-99,-4';
	$hallclass[$num][1][ 2]=0x00000002;
	$hallclass[$num][1][ 5]='.';
	$hallclass[$num][1][36]=2;
	$hallclass[$num][1][37]=8;
	$hallclass[$num][1][38]=5;

	$hallclass[$num][2][18]='upper-canals';
	$hallclass[$num][2][ 0]='RY,-3,-2';
	$hallclass[$num][2][ 2]=0x00000002;
	$hallclass[$num][2][36]=2;
	$hallclass[$num][2][37]=8;
	$hallclass[$num][2][38]=5;

	$hallclass[$num][3][18]='lower-canals';
	$hallclass[$num][3][ 0]='RY,2,3';
	$hallclass[$num][3][ 1]='0x80';
	$hallclass[$num][3][ 2]=0x00000042;
	$hallclass[$num][3][36]=1;
	$hallclass[$num][3][37]=2;
	$hallclass[$num][3][38]=1;

	$hallclass[$num][4][18]='submerged-canals';
	$hallclass[$num][4][ 0]='RY,4,99';
	$hallclass[$num][4][ 1]='0x09000080';
	$hallclass[$num][4][ 2]=0x00000112;
	$hallclass[$num][4][ 5]='w';
	$hallclass[$num][4][10]='w';
	$hallclass[$num][4][11]='w';
	$hallclass[$num][4][12]='w';
	$hallclass[$num][4][26]='w';
	$hallclass[$num][4][27]='w';
	$hallclass[$num][4][28]='w';
	$hallclass[$num][4][38]=1;
	$hallclass[$num][4][ 9]=4;

	$num += 1;
	$hallclass[$num][0][ 0]="Small Mining Tunnel";
	$hallclass[$num][0][ 1]=0x20803031;
	$hallclass[$num][0][ 2]=0x00000020;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,d.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=3;
	$hallclass[$num][0][ 9]=3;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=3;
	$hallclass[$num][0][14]=0;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=5;
	$hallclass[$num][0][17]=10;
	$hallclass[$num][0][18]='small mining tunnel';
	$hallclass[$num][0][19]=4;
	$hallclass[$num][0][20]=20;
	$hallclass[$num][0][21]=100;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=3;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=3;
	$hallclass[$num][0][30]=1;
	$hallclass[$num][0][31]=3;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=2;
	$hallclass[$num][0][35]=5;
	$hallclass[$num][0][36]=0;
	$hallclass[$num][0][37]=0;
	$hallclass[$num][0][38]=0;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=1;
	$hallclass[$num][1][ 0]='RY,1,99';
	$hallclass[$num][1][ 1]=0x40000000;
	$hallclass[$num][1][ 2]=0x00000010;
	$hallclass[$num][2][ 0]='RY,-99,-1';
	$hallclass[$num][2][ 1]=0x40000000;
	$hallclass[$num][2][ 2]=0x00000010;

	$num += 1;
	$hallclass[$num][0][ 0]="Large Mining Tunnel";
	$hallclass[$num][0][ 1]=0x20803030;
	$hallclass[$num][0][ 2]=0x00000020;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,d.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=3;
	$hallclass[$num][0][ 9]=3;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=3;
	$hallclass[$num][0][14]=0;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=5;
	$hallclass[$num][0][17]=10;
	$hallclass[$num][0][18]='large mining tunnel';
	$hallclass[$num][0][19]=3;
	$hallclass[$num][0][20]=20;
	$hallclass[$num][0][21]=100;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=3;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=3;
	$hallclass[$num][0][30]=1;
	$hallclass[$num][0][31]=3;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=2;
	$hallclass[$num][0][35]=5;
	$hallclass[$num][0][36]=0;
	$hallclass[$num][0][37]=0;
	$hallclass[$num][0][38]=0;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=1;
	$hallclass[$num][1][ 0]='RY,1,99';
	$hallclass[$num][1][ 1]=0x40000000;
	$hallclass[$num][1][ 2]=0x00000010;
	$hallclass[$num][2][ 0]='RY,-99,-1';
	$hallclass[$num][2][ 1]=0x40000000;
	$hallclass[$num][2][ 2]=0x00000010;

	$num += 1;
	$hallclass[$num][0][ 0]="Grand Hallway";
	$hallclass[$num][0][ 1]=0xba310897;
	$hallclass[$num][0][ 2]=0x00008122;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,d,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=2;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=2;
	$hallclass[$num][0][14]=2;
	$hallclass[$num][0][15]=2;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='grandhall';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=100;
	$hallclass[$num][0][23]=2;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=2;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=2;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Grand Hall Corridor";
	$hallclass[$num][0][ 1]=0x2a210817;
	$hallclass[$num][0][ 2]=0x00008122;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,d,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=2;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=2;
	$hallclass[$num][0][14]=2;
	$hallclass[$num][0][15]=2;
	$hallclass[$num][0][16]=25;
	$hallclass[$num][0][17]=25;
	$hallclass[$num][0][18]='grandhall';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=100;
	$hallclass[$num][0][23]=2;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=2;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=2;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=3;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=3;
	$hallclass[$num][0][37]=8;
	$hallclass[$num][0][38]=5;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=2;

	$num += 1;
	$hallclass[$num][0][ 0]="Rail Line";
	$hallclass[$num][0][ 1]=0x284eb137;
	$hallclass[$num][0][ 2]=0x0000030b;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=0;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=5;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=5;
	$hallclass[$num][0][14]=5;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=20;
	$hallclass[$num][0][17]=50;
	$hallclass[$num][0][18]='double-track';
	$hallclass[$num][0][19]=4;
	$hallclass[$num][0][20]=100;
	$hallclass[$num][0][21]=100;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=5;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=5;
	$hallclass[$num][0][30]=1;
	$hallclass[$num][0][31]=1;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=2;
	$hallclass[$num][0][37]=4;
	$hallclass[$num][0][38]=3;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=4;

	$num += 1;
	$hallclass[$num][0][ 0]="Unstable Tunnel";
	$hallclass[$num][0][ 1]=0x000000b1;
	$hallclass[$num][0][ 2]=0x00000080;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,d,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=0;
	$hallclass[$num][0][ 8]=7;
	$hallclass[$num][0][ 9]=7;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=7;
	$hallclass[$num][0][14]=7;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=20;
	$hallclass[$num][0][17]=5;
	$hallclass[$num][0][18]='unstable-tunnel';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=100;
	$hallclass[$num][0][23]=2;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=7;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=7;
	$hallclass[$num][0][30]=1;
	$hallclass[$num][0][31]=1;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=0;
	$hallclass[$num][0][37]=0;
	$hallclass[$num][0][38]=0;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=1;

	$num += 1;
	$hallclass[$num][0][ 0]="Lava Canal";
	$hallclass[$num][0][ 1]=0x20000133;
	$hallclass[$num][0][ 2]=0x000003ab;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,d,.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=0;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=1;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=1;
	$hallclass[$num][0][14]=1;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=10;
	$hallclass[$num][0][17]=2;
	$hallclass[$num][0][18]='lava-canal';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=1;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=1;
	$hallclass[$num][0][30]=1;
	$hallclass[$num][0][31]=1;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=1;
	$hallclass[$num][0][34]=1;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=2;
	$hallclass[$num][0][37]=6;
	$hallclass[$num][0][38]=4;
	$hallclass[$num][0][39]='.';
	$hallclass[$num][0][40]=1;
	$hallclass[$num][0][41]=3;

	$hallclass[$num][1][18]='lower-lava-canal';
	$hallclass[$num][1][ 0]='RY,1,99';
	$hallclass[$num][1][ 2]=0x00000000;

	$num += 1;
	$hallclass[$num][0][ 0]="Surface Labyrinth";
	$hallclass[$num][0][ 1]=0x0001c207;
	$hallclass[$num][0][ 2]=0x00000010;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,,.d.R,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=1;
	$hallclass[$num][0][ 8]=4;
	$hallclass[$num][0][ 9]=2;
	$hallclass[$num][0][10]='^';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]=',';
	$hallclass[$num][0][13]=2;
	$hallclass[$num][0][14]=2;
	$hallclass[$num][0][15]=1;
	$hallclass[$num][0][16]=5;
	$hallclass[$num][0][17]=10;
	$hallclass[$num][0][18]='labyrinth';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]='';
	$hallclass[$num][0][25]=7;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=2;
	$hallclass[$num][0][30]=0;
	$hallclass[$num][0][31]=0;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=0;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=0;
	$hallclass[$num][0][37]=0;
	$hallclass[$num][0][38]=0;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=0;

	$num += 1;
	$hallclass[$num][0][ 0]="Snow Cave";
	$hallclass[$num][0][ 1]=0x06010030;
	$hallclass[$num][0][ 2]=0x00000018;
	$hallclass[$num][0][ 3]='........;........;....;....;....;....';
	$hallclass[$num][0][ 4]='....,,,,....,,,d.d.d,,,,....,,,,';
	$hallclass[$num][0][ 5]='.';
	$hallclass[$num][0][ 6]=0;
	$hallclass[$num][0][ 7]=3;
	$hallclass[$num][0][ 8]=5;
	$hallclass[$num][0][ 9]=6;
	$hallclass[$num][0][10]=' ';
	$hallclass[$num][0][11]=' ';
	$hallclass[$num][0][12]='.';
	$hallclass[$num][0][13]=0;
	$hallclass[$num][0][14]=0;
	$hallclass[$num][0][15]=6;
	$hallclass[$num][0][16]=100;
	$hallclass[$num][0][17]=100;
	$hallclass[$num][0][18]='snowcave664';
	$hallclass[$num][0][19]=0;
	$hallclass[$num][0][20]=0;
	$hallclass[$num][0][21]=0;
	$hallclass[$num][0][22]=0;
	$hallclass[$num][0][23]=0;
	$hallclass[$num][0][24]=':';
	$hallclass[$num][0][25]=6;
	$hallclass[$num][0][26]='|';
	$hallclass[$num][0][27]='-';
	$hallclass[$num][0][28]='+';
	$hallclass[$num][0][29]=0;
	$hallclass[$num][0][30]=3;
	$hallclass[$num][0][31]=3;
	$hallclass[$num][0][32]=0;
	$hallclass[$num][0][33]=0;
	$hallclass[$num][0][34]=4;
	$hallclass[$num][0][35]=0;
	$hallclass[$num][0][36]=0;
	$hallclass[$num][0][37]=0;
	$hallclass[$num][0][38]=0;
	$hallclass[$num][0][39]='s';
	$hallclass[$num][0][40]=3;
	$hallclass[$num][0][41]=3;
	$hallclass[$num][1][ 0]='RY,-99,-1';
	$hallclass[$num][1][ 1]=0x20;
	$hallclass[$num][1][18]='snowcave686';
	$hallclass[$num][2][ 0]='RY,1,1';
	$hallclass[$num][2][ 1]=0x10;
	$hallclass[$num][2][18]='snowcave442';
	$hallclass[$num][3][ 0]='RY,2,2';
	$hallclass[$num][3][ 1]=0x10;
	$hallclass[$num][3][18]='snowcave';
	$hallclass[$num][4][ 0]='RY,3,99';
	$hallclass[$num][4][ 1]=0x10;
	$hallclass[$num][4][18]='icecave';
};

#------------------------------------------------------------------------------
# setlevelclasses - specify level characteristics

sub setlevelclasses {
	# first array field: special level class identifier
	# second array field:  0=name, 1=special level flags, 2=Y render scale for Minecraft,
	# 3=hallway floor character, 4=wall character, 5=floor effect character,
	# 6=up access character,7=down access character,8=intermediate access character
	# 9=level class alias, 10=initial hall class
	#
	# 1 - special flags:	0x00000001	bit  0:	No floor effects in hallways
	#			0x00000002	bit  1:	No trapped hallways
	#			0x00000004	bit  2:	No crossover hallways
	#			0x00000008	bit  3:	No random rooms
	#			0x00000010	bit  4:	Non-access rooms are single-level only
	#			0x00000020	bit  5:	shallow/deep pits not allowed
	#			0x00000040	bit  6:	Non-access rooms are not allowed
	#			0x00000080	bit  7:	No vertical access
	#			0x00000100	bit  8:	Unused cells rendered as empty
	#			0x00000200	bit  9:	No starting positions
	#			0x00000400	bit 10:	Tower rooms only
	#			0x00000800	bit 11:	No bottom-level rooms
	#			0x00001000	bit 12:	Labyrinth level
	#			0x00002000	bit 13:	No passthru hallways
	#			0x00004000	bit 14:	
	#			0x00008000	bit 15:	
	#

	my $num = 0;
	$levelclass[$num][ 0]="Maze";
	$levelclass[$num][ 1]=0x00000000;
	$levelclass[$num][ 2]=12;
	$levelclass[$num][ 3]=" ";
	$levelclass[$num][ 4]="#";
	$levelclass[$num][ 5]=",";
	$levelclass[$num][ 6]="u";
	$levelclass[$num][ 7]="d";
	$levelclass[$num][ 8]="i";
	$levelclass[$num][ 9]=0;
	$levelclass[$num][10]=0;

	$num += 1;
	$levelclass[$num][ 0]="Dungeon";
	$levelclass[$num][ 1]=0x00000090;
	$levelclass[$num][ 2]=12;
	$levelclass[$num][ 3]=" ";
	$levelclass[$num][ 4]="#";
	$levelclass[$num][ 5]=",";
	$levelclass[$num][ 6]="u";
	$levelclass[$num][ 7]="d";
	$levelclass[$num][ 8]="i";
	$levelclass[$num][ 9]=1;
	$levelclass[$num][10]=0;

	$num += 1;
	$levelclass[$num][ 0]="Village";
	$levelclass[$num][ 1]=0x000000ae;
	$levelclass[$num][ 2]=12;
	$levelclass[$num][ 3]=".";
	$levelclass[$num][ 4]="#";
	$levelclass[$num][ 5]=",";
	$levelclass[$num][ 6]="u";
	$levelclass[$num][ 7]="d";
	$levelclass[$num][ 8]="i";
	$levelclass[$num][ 9]=2;
	$levelclass[$num][10]=0;

	$num += 1;
	$levelclass[$num][ 0]="Canals";
	$levelclass[$num][ 1]=0x0000008f;
	$levelclass[$num][ 2]=12;
	$levelclass[$num][ 3]="`";
	$levelclass[$num][ 4]="#";
	$levelclass[$num][ 5]=",";
	$levelclass[$num][ 6]="u";
	$levelclass[$num][ 7]="d";
	$levelclass[$num][ 8]="i";
	$levelclass[$num][ 9]=3;
	$levelclass[$num][10]=0;

	$num += 1;
	$levelclass[$num][ 0]="Labyrinth";
	$levelclass[$num][ 1]=0x000015a4;
	$levelclass[$num][ 2]=12;
	$levelclass[$num][ 3]=" ";
	$levelclass[$num][ 4]="#";
	$levelclass[$num][ 5]=",";
	$levelclass[$num][ 6]="u";
	$levelclass[$num][ 7]="d";
	$levelclass[$num][ 8]="i";
	$levelclass[$num][ 9]=4;
	$levelclass[$num][10]=8;

	$num += 1;
	$levelclass[$num][ 0]="Towers";
	$levelclass[$num][ 1]=0x00000fa7;
	$levelclass[$num][ 2]=12;
	$levelclass[$num][ 3]=" ";
	$levelclass[$num][ 4]="#";
	$levelclass[$num][ 5]=",";
	$levelclass[$num][ 6]="u";
	$levelclass[$num][ 7]="d";
	$levelclass[$num][ 8]="i";
	$levelclass[$num][ 9]=4;
	$levelclass[$num][10]=8;

	$maxlevelclass = $num;
};

#------------------------------------------------------------------------------
# setdatasetclasses - specify dataset characteristics

sub setdatasetclasses {
	# first array field: dataset class identifier
	# second array field:
	# 0 - dataset name
	# 1 - special flags:	0x00000001	bit  0:	custom floor rendering
	#			0x00000002	bit  1:	use default openings (0=no/1=yes)
	#			0x00000004	bit  2:	use offset/oversize info
	#			0x00000008	bit  3:	FEV trans. thickness is a multiplier
	#			0x00000010	bit  4:	do not render upper directional boxes
	#			0x00000020	bit  5:	do not render lower directional boxes
	#			0x00000040	bit  6:	use wall mat'l type for floor dir thick adds
	#			0x00000080	bit  7:	use wall mat'l type for ceiling dir thick adds
	#
	# 2 - Minecraft material list
	#	1/2/3=floor/wall/ceiling fill material
	#	4/5/6=floor/wall/ceiling surface material
	#	7/8/9=core/opening/placeholder material
	#
	# 3 - Minecraft thickness list
	#	1/2/3=floor/wall/ceiling fill thickness
	#	4/5/6=floor/wall/ceiling surface thickness
	#	7/8=hcore/vcore thickness
	#	9=static water level
	#	10=FEV transition thickness
	#	11/12=wall fill thickness addition for VHE top/bottom
	#	13/14=wall surface thickness addition for VHE top/bottom
	#	15/16=wall surface/fill thickness addition for middle directional boxes
	#	17/18=floor surface/fill thickness addition for directional boxes
	#	19/20=ceiling surface/fill thickness addition for directional boxes
	#
	# 4 - alternate directory name
	# 5 - Minecraft up-ladder start offset
	# 6 - Minecraft hallway up/down opening constriction
	#
	# 7 - Minecraft block offset/oversizing specs
	#	1/2/3=X,Y,Z offset for block placement
	#	4/5/6=X,Y,Z size adjustment
	#
	# 8 - Minecraft alternate material list (see #2 above)

	my $num = 0;
	$datasetclass[$num][0] = "generic hallway";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,13,13,98:1,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,2,3,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "generic";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "test tunnel";
	$datasetclass[$num][1] = 0x00000040;
	$datasetclass[$num][2] = "3,1,1,43:0,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,3,2,0,2,0";
	$datasetclass[$num][4] = "test";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "large dungeon hallway 3";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,1,1,43:0,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "dhall-large-3";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "ceremonial hallway";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,98:0,98:0,98:1,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "ceremonial-hall";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "large drainage tunnel";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,98:0,98:0,98:1,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "drainage-large";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "small drainage tunnel";
	$datasetclass[$num][1] = 0x00000020;
	$datasetclass[$num][2] = "3,98:0,98:0,98:1,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,2,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0";
	$datasetclass[$num][4] = "drainage-small-mid";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "small drainage tunnel";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,98:0,98:0,98:1,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,2,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "drainage-small-upper";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "small drainage tunnel";
	$datasetclass[$num][1] = 0x00000030;
	$datasetclass[$num][2] = "3,98:0,98:0,98:1,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,2,1,1,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0,0";
	$datasetclass[$num][4] = "drainage-small-lower";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "large dungeon hallway 2";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,1,0,112,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "dhall-large-2";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "large dungeon hallway";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,1,1,112,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "dhall-large";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "grandhall";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "87,13,13,49,1,1,7,0,99";
	$datasetclass[$num][3] = "1,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "grandhall";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "utility 2";
	$datasetclass[$num][1] = 0x00000010;
	$datasetclass[$num][2] = "3,4,4,48,4,4,4,0,99";
	$datasetclass[$num][3] = "1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "generic";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "small mining tunnel";
	$datasetclass[$num][1] = 0x00000008;
	$datasetclass[$num][2] = "4,4,4,4,4,4,7,0,99";
	$datasetclass[$num][3] = "1,3,4,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "mining-small";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "large mining tunnel";
	$datasetclass[$num][1] = 0x00000008;
	$datasetclass[$num][2] = "4,4,4,4,4,4,7,0,99";
	$datasetclass[$num][3] = "1,2,4,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "mining-large";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "canals";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "4,4,4,48,4,4,7,0,99";
	$datasetclass[$num][3] = "0,1,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "canals";
	$datasetclass[$num][5] = 3;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "village";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,4,4,3,4,4,7,0,99";
	$datasetclass[$num][3] = "0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "village";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "utility";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "1,1,1,1,1,1,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "utility";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "utility-sb";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,3,3,98:0,98:0,98:0,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "utility-sb";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "double-track";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,7,12,3,7,48,7,0,99";
	$datasetclass[$num][3] = "0,1,4,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "double-track";
	$datasetclass[$num][5] = 3;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "unstable-tunnel";
	$datasetclass[$num][1] = 0x00000001;
	$datasetclass[$num][2] = "13,13,13,1,1,1,7,0,99";
	$datasetclass[$num][3] = "1,0,4,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "unstable-tunnel";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "special 1";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "12,12,12,48,4,4,7,0,99";
	$datasetclass[$num][3] = "0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "special1-cstone";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "lava-canal";
	$datasetclass[$num][1] = 0x00000002;
	$datasetclass[$num][2] = "11,1,1,1,1,1,7,0,99";
	$datasetclass[$num][3] = "2,0,0,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "lava-canal";
	$datasetclass[$num][5] = 5;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "labyrinth";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "4,4,4,48,4,4,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "labyrinth";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 0;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "tower";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "1,1,1,1,1,1,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "tower";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 0;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "hut";
	$datasetclass[$num][1] = 0x00000004;
	$datasetclass[$num][2] = "3,4,4,3,4,4,7,0,99";
	$datasetclass[$num][3] = "0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "village";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "-4,0,-4,8,0,8";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "grandhall2";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "87,13,13,49,1,1,7,0,99";
	$datasetclass[$num][3] = "1,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "grandhall2";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "upper-canals";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "4,1,1,48,1,1,7,0,99";
	$datasetclass[$num][3] = "0,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "upper-canals";
	$datasetclass[$num][5] = 3;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "lower-canals";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "48,48,48,48,48,48,7,0,99";
	$datasetclass[$num][3] = "0,0,2,0,1,1,1,1,2,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "lower-canals";
	$datasetclass[$num][5] = 3;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "lower-lava-canal";
	$datasetclass[$num][1] = 0x00000002;
	$datasetclass[$num][2] = "11,1,1,1,1,1,7,0,99";
	$datasetclass[$num][3] = "2,0,0,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "lower-lava-canal";
	$datasetclass[$num][5] = 5;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "dry-canals";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "4,1,1,48,1,1,7,0,99";
	$datasetclass[$num][3] = "0,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "upper-canals";
	$datasetclass[$num][5] = 3;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "submerged-canals";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "48,48,48,48,48,48,7,0,99";
	$datasetclass[$num][3] = "0,0,2,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "lower-canals";
	$datasetclass[$num][5] = 3;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "snow-cave-6x8x6";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "80,80,80,79,80,80,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "snowcave686";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "snow-cave-6x6x4";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "80,80,80,79,80,80,7,0,99";
	$datasetclass[$num][3] = "1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "snowcave664";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "snow-cave-4x4x2";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "80,80,80,79,80,80,7,0,99";
	$datasetclass[$num][3] = "1,2,0,1,1,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "snowcave442";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "SnowCave";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "80,80,80,79,80,80,7,0,99";
	$datasetclass[$num][3] = "1,3,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "snowcave";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "Ice Cave";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "80,80,80,79,79,79,7,0,99";
	$datasetclass[$num][3] = "1,3,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "icecave";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";

	$num += 1;
	$datasetclass[$num][0] = "Room";
	$datasetclass[$num][1] = 0x00000000;
	$datasetclass[$num][2] = "3,4,4,48,4,4,7,0,99";
	$datasetclass[$num][3] = "1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0";
	$datasetclass[$num][4] = "generic_room";
	$datasetclass[$num][5] = 0;
	$datasetclass[$num][6] = 3;
	$datasetclass[$num][7] = "0,0,0,0,0,0";
	$datasetclass[$num][8] = ",,,,,,,,";
};

#------------------------------------------------------------------------------
# setroomclasses - specify room characteristics

sub setroomclasses {
	# first array field: special room class identifier
	# second array field:  0=name, 1=min size, 2=max size, 3=max door count,
	# 4,5=special flags, 6=number of rooms to add (dungeon mode),
	# 7=number of rooms to add (maze mode), 8=ascii fill char 9=ascii floor fill char,
	# 10,11=minimum/maximum passthru length allowed
	# 12=recommended door characteristics,13=door flag fill pattern,
	# 14=ansi floor color, 15=ansi space color, 16=dataset name, 17=special room name,
	# 18=room placement attempts (0=default), 19=random variants, 20=hall class conversion name,
	# 21=room placement order, 22=door requirements
	# For sizes and door count: 0=use defaults, non-zero=override defaults.
	#
	# 13 - door/thru flag fill patterns:
	#	door bits 0-3:	0x0=full fill		0x8=undefined
	#			0x1=bottom fill		0x9=undefined
	#			0x2=top fill		0xa=undefined
	#			0x3=top & bottom fill	0xb=undefined
	#			0x4=no fill		0xc=undefined
	#			0x5=corner fill		0xd=undefined
	#			0x6=no bottom fill	0xe=undefined
	#			0x7=no top fill		0xf=custom fill
	#		0x10	bit 4:	clear center 0=on/1=off
	#		0x20	bit 5:	clear corners 0=on/1=off
	#		0x40	bit 6:	
	#		0x80	bit 7:	
	#       thru bits 8-11:	0x0=full fill		0x8=undefined
	#			0x1=bottom fill		0x9=undefined
	#			0x2=top fill		0xa=undefined
	#			0x3=top & bottom fill	0xb=undefined
	#			0x4=no fill		0xc=undefined
	#			0x5=corner fill		0xd=undefined
	#			0x6=no bottom fill	0xe=undefined
	#			0x7=no top fill		0xf=custom fill
	#		0x100	bit 12:	clear center 0=on/1=off
	#		0x200	bit 13:	clear corners 0=on/1=off
	#		0x400	bit 14:	
	#		0x800	bit 15:	
	
	#
	# 4 - special flags:	0x00000001	bit  0: no vertical access
	#			0x00000002	bit  1: indicate no room number on room
	#			0x00000004	bit  2: random 50% flip X/Z size 
	#			0x00000008	bit  3: indicate top/center/bottom segments
	#			0x00000010	bit  4: allow multiple entry doors
	#			0x00000020	bit  5: room is submerged
	#			0x00000040	bit  6: floor/ceiling effects not allowed
	#			0x00000080	bit  7: 1 door per level
	#			0x00000100	bit  8: top-level:corners only
	#			0x00000200	bit  9: attempt opposing door position
	#			0x00000400	bit 10: non-random selection priority
	#			0x00000800	bit 11: room is the dungeon gateway
	#			0x00001000	bit 12: room is the dungeon end
	#			0x00002000	bit 13: do not show floor effects in room
	#			0x00004000	bit 14: place bottom of room at bottom level
	#			0x00008000	bit 15: disallow room in dungeon mode
	#			0x00010000	bit 16: attempt round-robin Y positioning
	#			0x00020000	bit 17: number of rooms-to-add are per-level numbers
	#			0x00040000	bit 18: loose fill w/random huts
	#			0x00080000	bit 19: tight fill w/fixed-size huts
	#			0x00100000	bit 20: room is a random hut
	#			0x00200000	bit 21: room is a fixed-size hut
	#			0x00400000	bit 22: room is a small hut
	#			0x00800000	bit 23: bottom-level:corners only
	#			0x01000000	bit 24:	fill room with canals
	#			0x02000000	bit 25:	internal canal room
	#			0x04000000	bit 26:	top/bottom-level: alternating opposite corners
	#			0x08000000	bit 27:	room is a level access room
	#			0x10000000	bit 28:	room is a lava pit
	#			0x20000000	bit 29:	no internal door rendering
	#			0x40000000	bit 30:	no room block rendering
	#			0x80000000	bit 31:	custom room sizing/positioning
	#
	# 5 - special flags:	0x00000001	bit 32:	override adjacentrooms
	#			0x00000002	bit 33: this room is a tower
	#			0x00000004	bit 34: horizontal dimensions are square
	#			0x00000008	bit 35: require random treasure placement
	#			0x00000010	bit 36: floor elevation variance allowed
	#			0x00000020	bit 37: render room with hallway schematic set
	#			0x00000040	bit 38: convert room to hallway class
	#			0x00000080	bit 39: add random vertical rib pattern to walls
	#			0x00000100	bit 40: add rough ceiling to room
	#			0x00000200	bit 41: door set is room style specific
	#			0x00000400	bit 42: perform dense room packing on room
	#			0x00000800	bit 43: disable roomedgebuffer flag for room
	#			0x00001000	bit 44: passthrus should be priority for this room
	#			
	#			0x80000000	bit 63: an interior can be built into the room
	#
	my $num = 0;
	$roomclass[$num][ 0]="Room";
	$roomclass[$num][ 1]="2,1,2";
	$roomclass[$num][ 2]="3,3,3";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x00000004;
	$roomclass[$num][ 5]=0x80000008;
	$roomclass[$num][ 6]=($roomidmask>>$roomidshft);
	$roomclass[$num][ 7]=($roomidmask>>$roomidshft);
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=9;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x2020;
	# $roomclass[$num][13]=0x3221;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="Room";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=4;
	$roomclass[$num][22]='d...,,,,....,,,,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Start";
	$roomclass[$num][ 1]="3,1,3";
	$roomclass[$num][ 2]="0,1,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x00000001;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3400;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='....,,,,....,,,,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Shaft";
	$roomclass[$num][ 1]="1,3,1";
	$roomclass[$num][ 2]="1,6,1";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x1800c003;
	$roomclass[$num][ 5]=0x00000181;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=4;
	$roomclass[$num][ 8]="O";
	$roomclass[$num][ 9]=",";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3436;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=1;
	$roomclass[$num][16]="special 1";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=5;
	$roomclass[$num][22]='....,,,,....,,,,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Closet";
	$roomclass[$num][ 1]="1,1,1";
	$roomclass[$num][ 2]="1,1,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x00030002;
	$roomclass[$num][ 5]=0x00000001;
	$roomclass[$num][ 6]=2;
	$roomclass[$num][ 7]=2;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="closet";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=5;
	$roomclass[$num][22]='d...,,,,....,,R,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Treasure Room";
	$roomclass[$num][ 1]="1,1,1";
	$roomclass[$num][ 2]="1,1,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x00030002;
	$roomclass[$num][ 5]=0x00000001;
	$roomclass[$num][ 6]=1;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]='$';
	$roomclass[$num][ 9]='$';
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=5;
	$roomclass[$num][22]='R..r,,,,....,,,,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Gorge";
	$roomclass[$num][ 1]="4,3,1";
	$roomclass[$num][ 2]="6,6,1";
	$roomclass[$num][ 3]=2;
	$roomclass[$num][ 4]=0x10004447;
	$roomclass[$num][ 5]=0x00000181;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=4;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=",";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3422;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=1;
	$roomclass[$num][16]="special 1";
	$roomclass[$num][17]="gorge";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='d...,,,,....,,,R...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Stairwell";
	$roomclass[$num][ 1]="2,2,1";
	$roomclass[$num][ 2]="2,2,1";
	$roomclass[$num][ 3]=2;
	$roomclass[$num][ 4]=0x0803a4cf;
	$roomclass[$num][ 5]=0x00000200;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]="s";
	$roomclass[$num][ 9]="s";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="stairwell";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='d...,,,,....,,R,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Level Gateway";
	$roomclass[$num][ 1]="1,2,1";
	$roomclass[$num][ 2]="1,2,1";
	$roomclass[$num][ 3]=2;
	$roomclass[$num][ 4]=0x08002809;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]="d";
	$roomclass[$num][ 9]="u";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility";
	$roomclass[$num][17]="levelgate";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,R,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Dungeon End";
	$roomclass[$num][ 1]="1,1,1";
	$roomclass[$num][ 2]="1,1,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x00003003;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]="E";
	$roomclass[$num][ 9]="E";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,R,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Submerged Tunnel";
	$roomclass[$num][ 1]="3,2,1";
	$roomclass[$num][ 2]="6,2,1";
	$roomclass[$num][ 3]=2;
	$roomclass[$num][ 4]=0x00000565;
	$roomclass[$num][ 5]=0x00000581;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]=',';
	$roomclass[$num][ 9]="w";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3422;
	$roomclass[$num][14]=4;
	$roomclass[$num][15]=4;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=1;
	$roomclass[$num][22]='d...,,,,....,,,R...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Grand Hall";
	$roomclass[$num][ 1]="2,1,3";
	$roomclass[$num][ 2]="0,1,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x00000211;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3411;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="grandhall";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,,R...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Village";
	$roomclass[$num][ 1]="7,1,7";
	$roomclass[$num][ 2]="0,2,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x00080251;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3411;
	$roomclass[$num][14]=2;
	$roomclass[$num][15]=2;
	$roomclass[$num][16]="village";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=1;
	$roomclass[$num][22]='d...,,,,....,,,R...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Small Hut";
	$roomclass[$num][ 1]="1,1,1";
	$roomclass[$num][ 2]="1,1,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x20600043;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="village";
	$roomclass[$num][17]="hut";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d..d,,,,....,,R,...d,,,,....,,,,';
 
	$num += 1;
	$roomclass[$num][ 0]="Large Hut";
	# $roomclass[$num][ 1]="3,1,1";
	# $roomclass[$num][ 2]="3,1,1";
	$roomclass[$num][ 1]="1,1,1";
	$roomclass[$num][ 2]="1,1,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x20200047;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	# $roomclass[$num][13]=0x3411;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="village";
	$roomclass[$num][17]="hut";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d..d,,,,....,,R,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Village";
	$roomclass[$num][ 1]="7,1,7";
	$roomclass[$num][ 2]="0,2,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x00040251;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3411;
	$roomclass[$num][14]=2;
	$roomclass[$num][15]=2;
	$roomclass[$num][16]="village";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,,R...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Hut";
	$roomclass[$num][ 1]="1,1,1";
	$roomclass[$num][ 2]="1,1,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x201000c3;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="hut";
	$roomclass[$num][17]="hut";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d..d,,,,....,,R,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Village";
	$roomclass[$num][ 1]="8,1,8";
	$roomclass[$num][ 2]="12,1,12";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x000c0251;
	$roomclass[$num][ 5]=0x00000c00;
	$roomclass[$num][ 6]=1;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3411;
	$roomclass[$num][14]=2;
	$roomclass[$num][15]=2;
	$roomclass[$num][16]="village";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='d...,,,,....,,,R...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Village Level";
	$roomclass[$num][ 1]="0,3,0";
	$roomclass[$num][ 2]="0,3,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x04040251;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=".";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=2;
	$roomclass[$num][15]=2;
	$roomclass[$num][16]="village";
	$roomclass[$num][17]="village-level";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,,R...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Canal Level";
	$roomclass[$num][ 1]="0,3,0";
	$roomclass[$num][ 2]="0,3,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x05000251;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=",";
	$roomclass[$num][ 9]=",";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=4;
	$roomclass[$num][15]=4;
	$roomclass[$num][16]="canals";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,,,.r.d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Canal Room";
	$roomclass[$num][ 1]="0,0,0";
	$roomclass[$num][ 2]="0,0,0";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x02000003;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="canals";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='....,,,,....,,,,.r.d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Canal Access";
	$roomclass[$num][ 1]="0,0,0";
	$roomclass[$num][ 2]="0,0,0";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x00000003;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=0;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="canals";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='....,,,,....,,,,.R.d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Spiral Staircase";
	$roomclass[$num][ 1]="1,2,1";
	$roomclass[$num][ 2]="1,5,1";
	$roomclass[$num][ 3]=5;
	$roomclass[$num][ 4]=0x0803a4cb;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]="s";
	$roomclass[$num][ 9]="s";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility";
	$roomclass[$num][17]="staircase";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="8";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='d...,,,,....,,R,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Large Staircase";
	$roomclass[$num][ 1]="2,2,2";
	$roomclass[$num][ 2]="2,6,2";
	$roomclass[$num][ 3]=5;
	$roomclass[$num][ 4]=0x0803a4cb;
	$roomclass[$num][ 5]=0x00000200;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]=".";
	$roomclass[$num][ 9]=".";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3430;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="utility";
	$roomclass[$num][17]="large-staircase";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="4";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='d...,,,,....,,R,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Underground River";
	$roomclass[$num][ 1]="0,4,0";
	$roomclass[$num][ 2]="0,9,0";
	$roomclass[$num][ 3]=2;
	$roomclass[$num][ 4]=0xc8008043;
	$roomclass[$num][ 5]=0x00000000;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=4;
	$roomclass[$num][ 8]="r";
	$roomclass[$num][ 9]="r";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x343f;
	$roomclass[$num][14]=4;
	$roomclass[$num][15]=4;
	$roomclass[$num][16]="utility 2";
	$roomclass[$num][17]="dynriver";
	$roomclass[$num][18]=0;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='d...,,,,....,,R,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Tower";
	$roomclass[$num][ 1]="1,2,1";
	$roomclass[$num][ 2]="1,5,1";
	$roomclass[$num][ 3]=1;
	$roomclass[$num][ 4]=0x40000002;
	$roomclass[$num][ 5]=0x00000006;
	$roomclass[$num][ 6]=16;
	$roomclass[$num][ 7]=16;
	$roomclass[$num][ 8]="t";
	$roomclass[$num][ 9]="t";
	$roomclass[$num][10]=0;
	$roomclass[$num][11]=0;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3431;
	$roomclass[$num][14]=3;
	$roomclass[$num][15]=3;
	$roomclass[$num][16]="tower";
	$roomclass[$num][17]="tower";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=0;
	$roomclass[$num][22]='d...,,,,....,,R,...d,,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Chasm";
	$roomclass[$num][ 1]="1,8,8";
	$roomclass[$num][ 2]="1,10,16";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x1800c007;
	$roomclass[$num][ 5]=0x00001181;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=1;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=",";
	$roomclass[$num][10]=1;
	$roomclass[$num][11]=2;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3636;
	$roomclass[$num][14]=5;
	$roomclass[$num][15]=1;
	$roomclass[$num][16]="special 1";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='....,,,,....,,,,...dd,,,....,,,,';

	$num += 1;
	$roomclass[$num][ 0]="Small Chasm";
	$roomclass[$num][ 1]="1,8,2";
	$roomclass[$num][ 2]="1,10,3";
	$roomclass[$num][ 3]=0;
	$roomclass[$num][ 4]=0x1800c007;
	$roomclass[$num][ 5]=0x00001181;
	$roomclass[$num][ 6]=0;
	$roomclass[$num][ 7]=5;
	$roomclass[$num][ 8]=" ";
	$roomclass[$num][ 9]=",";
	$roomclass[$num][10]=1;
	$roomclass[$num][11]=2;
	$roomclass[$num][12]=0x00000000;
	$roomclass[$num][13]=0x3636;
	$roomclass[$num][14]=5;
	$roomclass[$num][15]=1;
	$roomclass[$num][16]="special 1";
	$roomclass[$num][17]="";
	$roomclass[$num][18]=200;
	$roomclass[$num][19]="1";
	$roomclass[$num][20]='';
	$roomclass[$num][21]=3;
	$roomclass[$num][22]='....,,,,....,,,,...dd,,,....,,,,';

	$maxroomclass = $num;
};

#------------------------------------------------------------------------------
# setinteriorclasses - specify room interior characteristics

sub setinteriorclasses {
	# first array field: special interior class identifier
	# second array field:  0=name, 1=dataset name, 2=dataset subset name
	# 3=interior class selection weight, 4/5=ascii open/floor character override,
	# 6/7=ansi open/floor color override, 8=interior render type,
	# 9=default variations, 10 = schematic horiz size, 11=maximum qty of this interior,
	# 12=room requirements, 13=interior special flags, 14=variation range size,
	# 15=variation count array
	#
	# 8 - Interior render type:	0=none
	#				1=H/V scaleable
	#				2=H fixed / V scaleable
	#				3=H scaleable / V fixed
	#				4=H fixed / V fixed
	#				5=H centered schematic / V scaleable
	#				6=H centered schematic / V fixed
	#				7=direct segment translation
	#
	# 13 - special flags:	0x00000001	bit  0:	global horizontal variation
	#			0x00000002	bit  1:	global vertical variation
	#			0x00000004	bit  2:	variation select: 0=random/1=increment
	#			0x00000008	bit  3:	inc. variation: 0=roundrobin/1=repeat max
	#			0x00000010	bit  4:	ignore placement direction
	#			0x00000020	bit  5:	treat room as single-height
	#			0x00000040	bit  6:	use non-intrusive door schematics
	#			0x00000080	bit  7:	repeat layer 1, layer 2 is top only
	#			0x00000100	bit  8: default variation is dependant on room height
	#			0x00000200	bit  9: room-wide variation with +/- adjustments
	#			0x00000400	bit 10: for b9, +/- adjustments should be on checkered grid
	#			0x00000800	bit 11: use variation 0 only for passthru cells
	#
	# 15 - variation count for render types 1-6:
	#				semicolon-separated segments correspond to layers 0-2
	#				16 characters correspond to 16 horizontal wall segment combinations
	#				characters: 1-9,a-z = number of variations for that segment (1-35),
	#				period = use default variation, 0 = no variation (no schematic)
	# 15 - variation count for render type 7:
	#				64 characters correspond to 64 horiz/vert wall segment combinations
	#				characters: 1-9,a-z = number of variations for that segment (1-35),
	#				period = use default variation, 0 = no variation (no schematic)

	my $num = 0;

	$interiorclass[$num][ 0]="Empty";
	$interiorclass[$num][ 1]="generic";
	$interiorclass[$num][ 2]="";
	$interiorclass[$num][ 3]=1;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=0;
	$interiorclass[$num][ 9]=0;
	$interiorclass[$num][10]=0;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000000;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]='';

	$num += 1;
	$interiorclass[$num][ 0]="Library";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="library";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='....,,,,....,,,,R...dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Courtyard";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="courtyard";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='....,,,,....,,,,R...dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Worker Barracks";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="worker-barracks";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d...d,,,....,,,,....dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Worker Housing";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="worker-housing";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d...d,,,d...,,,,.dd.dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Dining Hall";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="dining-hall";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d..dd,,d....,,,,R...dd,,....,,,,....,,,,dddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Meeting Hall";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="meeting-hall";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d..dd,,d....,,,,R...d,,,....,,,,....,,,,dddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Warrior Training";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="warrior-training";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=0;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d...dd,,R...,,,,.dd.dd,,r...,,,,..dd,,,,dddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]='................;................;................';

	$num += 1;
	$interiorclass[$num][ 0]="Marketplace";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="marketplace";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=0;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d...dd,,R...,,,,.dd.dd,,r...,,,,..dd,,,,dddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]='................;................;................';

	$num += 1;
	$interiorclass[$num][ 0]="Farming Area";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="farming-area";
	$interiorclass[$num][ 3]=2;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=2;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=10;
	# $interiorclass[$num][12]='d...d,,,....,,,,....dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][12]='d...d,,,....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000850;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Garden Area";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="garden-area";
	$interiorclass[$num][ 3]=2;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=2;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=10;
	# $interiorclass[$num][12]='d...d,,,....,,,,....dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][12]='d...d,,,....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000850;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Livestock Area";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="livestock-area";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]=1;
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='d...d,,,....,,,,....dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000050;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Construction Area";
	$interiorclass[$num][ 1]="utility-sb";
	$interiorclass[$num][ 2]="construction-area";
	$interiorclass[$num][ 3]=8;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=1;
	$interiorclass[$num][ 9]='6,11,16';
	$interiorclass[$num][10]=1;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='....,,,,....,,,,R...dd,,....,,,,..dd,,dddddd,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000752;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]="................;................;................";

	$num += 1;
	$interiorclass[$num][ 0]="Workshop";
	$interiorclass[$num][ 1]="generic";
	$interiorclass[$num][ 2]="workshop-generic";
	$interiorclass[$num][ 3]=0;
	$interiorclass[$num][ 4]=' ';
	$interiorclass[$num][ 5]='.';
	$interiorclass[$num][ 6]=3;
	$interiorclass[$num][ 7]=3;
	$interiorclass[$num][ 8]=4;
	$interiorclass[$num][ 9]=3;
	$interiorclass[$num][10]=0;
	$interiorclass[$num][11]=0;
	$interiorclass[$num][12]='.R..,R,,nrnn,,,,....dd,,...r,,,,....,,,,dd..,,,,....,,,,....,,,,';
	$interiorclass[$num][13]=0x00000000;
	$interiorclass[$num][14]=0;
	$interiorclass[$num][15]='................;................;................';

	$maxinteriorclass = $num;
};

#------------------------------------------------------------------------------
# parsestylestring - convert a global hall style string into bit patterns

sub parsestylestring {

	my $stylestring = $_[0];
	my $stylestring2 = $_[1];
	my $outputflag = $_[2];
	my $grouping = $_[3];

	$outputflag = 0 if ! $outputflag;
	$grouping = 0 if ! $grouping;

	if ( $outputflag ) {
		return ( '' ) if ( ! $stylestring );
	} else {
		return ( 0, 0 ) if ( ! $stylestring );
	};

	# split the input strings into weight and render type strings
	my @stylestr = split(';', $stylestring );
	my @stylestr2 = split(';', $stylestring2 ) if $stylestring2;
	
	my $ofieldstr = '';

	my @bitfield;

	for my $field ( 0 .. 5 ) {
	    my $val = 0;
	    $bitfield[$field] = 0;

	    $ofieldstr = "$ofieldstr;" if ( $field );

	    my $idxmax = ( $gstylemask >> $gstyleshft );
	    $idxmax = ( $lstylemask >> $lstyleshft ) if ( $field >= 2 );

	    for my $bit ( 0 .. $idxmax ) {

		# break out the individual characters
		my $char = substr( $stylestr[$field], $bit, 1 );
		my $char2 = substr( $stylestr2[$field], $bit, 1 ) if $stylestring2;

		# combine the particular field of the input strings
		if ( $char2 ) {
			$char = $char2 if ( $char2 eq '.' );
			$char = $char2 if ( $char2 eq '0' );
			$char = $char2 if ( $char2 eq '1' );
			$char = $char2 if ( $char2 eq '2' );
			$char = $char2 if ( $char2 eq '3' );
			$char = $char2 if ( $char2 eq '4' );
			$char = $char2 if ( $char2 eq '5' );
			$char = $char2 if ( $char2 eq '6' );
			$char = $char2 if ( $char2 eq '7' );
			$char = $char2 if ( $char2 eq '8' );
			$char = $char2 if ( $char2 eq '9' );
			$char = $char2 if ( $char2 eq 'a' );
			$char = $char2 if ( $char2 eq 'b' );
			$char = $char2 if ( $char2 eq 'c' );
			$char = $char2 if ( $char2 eq 'd' );
			$char = $char2 if ( $char2 eq 'e' );
			$char = $char2 if ( $char2 eq 'f' );
		};

		# turn the chars into an 8-nybble binary value
		$val =  0;
		$val =  1 if ( $char eq '1' );
		$val =  2 if ( $char eq '2' );
		$val =  3 if ( $char eq '3' );
		$val =  4 if ( $char eq '4' );
		$val =  5 if ( $char eq '5' );
		$val =  6 if ( $char eq '6' );
		$val =  7 if ( $char eq '7' );
		$val =  8 if ( $char eq '8' );
		$val =  9 if ( $char eq '9' );
		$val = 10 if ( $char eq 'a' );
		$val = 11 if ( $char eq 'b' );
		$val = 12 if ( $char eq 'c' );
		$val = 13 if ( $char eq 'd' );
		$val = 14 if ( $char eq 'e' );
		$val = 15 if ( $char eq 'f' );

		$bitfield[$field] = ( $bitfield[$field] | ( $val << ( $bit * 4 )));
		$ofieldstr = "$ofieldstr" . "$char";
	    };
	};

	if ( $outputflag ) {
		# return the combined string value.
		return( $ofieldstr );
	} else {
		# return the combined binary values for both input strings.
		return( $bitfield[ ( $grouping * 2 ) ], $bitfield[ ( $grouping * 2 ) + 1 ] );
	};
};

#------------------------------------------------------------------------------
# parseinteriorflagstring - convert an interior flag string into bit patterns

sub parseinteriorflagstring {

	my $intstring = $_[0];

	return ( 0, 0, 0 ) if ( ! $intstring );

	my ( $intreq, $intdis, $intrec, $intnot ) = ( 0, 0, 0, 0 );
	my ( $intreq2, $intdis2, $intrec2, $intnot2 ) = ( 0, 0, 0, 0 );

	for my $bit ( 0 .. 31 ) {
		my $char = substr( $intstring, $bit, 1 );

		$intreq = ( $intreq | ( 1<<$bit )) if ( $char eq 'R' );
		$intdis = ( $intdis | ( 1<<$bit )) if ( $char eq 'd' );
		$intrec = ( $intrec | ( 1<<$bit )) if ( $char eq 'r' );
		$intnot = ( $intnot | ( 1<<$bit )) if ( $char eq 'n' );
	};
	for my $bit ( 32 .. 63 ) {
		my $char = substr( $intstring, $bit, 1 );
		my $shft = $bit - 32;

		$intreq2 = ( $intreq2 | ( 1<<$shft )) if ( $char eq 'R' );
		$intdis2 = ( $intdis2 | ( 1<<$shft )) if ( $char eq 'd' );
		$intrec2 = ( $intrec2 | ( 1<<$shft )) if ( $char eq 'r' );
		$intnot2 = ( $intnot2 | ( 1<<$shft )) if ( $char eq 'n' );
	};

	printf( "parseint 1: req %08x dis %08x rec %08x not %08x 2: req %08x dis %08x rec %08x not %08x\n",
		$intreq, $intdis, $intrec, $intnot, $intreq2, $intdis2, $intrec2, $intnot2 ) if ( $debug3 );

	return( $intreq, $intdis, $intrec, $intnot, $intreq2, $intdis2, $intrec2, $intnot2 );
};

#------------------------------------------------------------------------------
# parsedoorflagstring - convert a door flag string into bit patterns

sub parsedoorflagstring {

	my $doorstring = $_[0];
	my $doorstring2 = $_[1];
	my $outputflag = $_[2];

	$outputflag = 0 if ! $outputflag;

	if ( $outputflag ) {
		return ( '' ) if ( ! $doorstring );
	} else {
		return ( 0, 0, 0 ) if ( ! $doorstring );
	};

	my ( $doorreq, $doordis, $doorrec, $doornot ) = ( 0, 0, 0, 0 );

	for my $bit ( 0 .. 31 ) {
		my $char = substr( $doorstring, $bit, 1 );
		my $char2 = substr( $doorstring2, $bit, 1 ) if $doorstring2;

		if ( $char2 ) {
			$char = $char2 if ( $char2 eq 'R' );
			$char = $char2 if ( $char2 eq 'd' );
			$char = $char2 if ( $char2 eq 'r' );
			$char = $char2 if ( $char2 eq 'n' );
			$char = ' ' if ( $char2 eq 'x' );
		};

		$doorreq = ( $doorreq | ( 1<<$bit )) if ( $char eq 'R' );
		$doordis = ( $doordis | ( 1<<$bit )) if ( $char eq 'd' );
		$doorrec = ( $doorrec | ( 1<<$bit )) if ( $char eq 'r' );
		$doornot = ( $doornot | ( 1<<$bit )) if ( $char eq 'n' );
	};

	if ( $outputflag ) {
		my $outstr = '';
		for my $bit ( 0 .. 31 ) {
			if ( $doorreq & ( 1<<$bit )) {
				$outstr = $outstr . 'R';
			} elsif ( $doordis & ( 1<<$bit )) {
				$outstr = $outstr . 'd';
			} elsif ( $doorrec & ( 1<<$bit )) {
				$outstr = $outstr . 'r';
			} elsif ( $doornot & ( 1<<$bit )) {
				$outstr = $outstr . 'n';
			} else {
				$outstr = $outstr . ' ';
			};
		};
		return( $outstr );
	} else {
		return( $doorreq, $doordis, $doorrec, $doornot );
	};
};

#------------------------------------------------------------------------------
# getdatasetinfo - get information about a dataset class

sub getdatasetinfo {
	my $datasetname = $_[0];
	my $valid = 0;
	my $datasetnumber = 0;
	foreach my $setnumber ( 0..$maxdatasetclass ) {

		next if ( ! $datasetclass[$setnumber][0] );

		if ( $datasetname eq $datasetclass[$setnumber][0] ) {
			$valid = 1;
			$datasetnumber = $setnumber;
			last;
		} elsif ( $datasetname eq $datasetclass[$setnumber][4] ) {
			$valid = 1;
			$datasetnumber = $setnumber;
			last;
		}
	};
	my ( $fft,$wft,$cft,$fst,$wst,$cst,$cmt,$omt,$pmt ) = parsedsmaterials( 0, $datasetclass[$datasetnumber][2] );
	my ( $ffs,$wfs,$cfs,$fss,$wss,$css,$hco,$vco,$swl,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff ) =
		parsedsthickness( 0, $datasetclass[$datasetnumber][3] );

	$datasetname = $datasetclass[$datasetnumber][4] if $datasetclass[$datasetnumber][4];
	my $ulo = $datasetclass[$datasetnumber][5];
	my $oco = $datasetclass[$datasetnumber][6];

	return( $datasetname,$valid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
		$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff);
};

#------------------------------------------------------------------------------
# getdsoffset - get offset information about a dataset class

sub getdsoffset {
	my $datasetname = $_[0];
	my $valid = 0;
	my $datasetnumber = 0;
	foreach my $setnumber ( 0..$maxdatasetclass ) {

		next if ( ! $datasetclass[$setnumber][0] );

		if ( $datasetname eq $datasetclass[$setnumber][0] ) {
			$valid = 1;
			$datasetnumber = $setnumber;
			last;
		}
		if ( $datasetname eq $datasetclass[$setnumber][4] ) {
			$valid = 1;
			$datasetnumber = $setnumber;
			last;
		}
	};

	my ( $ofvalid, $offlag) = getdatasetflag( $datasetname, 2 );
	return ( 0,0,0,0,0,0) if ! $offlag;

	my ( $xoff,$yoff,$zoff,$xover,$yover,$zover ) = parsedsoffset( 0, $datasetclass[$datasetnumber][7] );

	return ( $xoff, $yoff, $zoff, $xover, $yover, $zover );
};

#------------------------------------------------------------------------------
# getdatasetflag - get special flag for a dataset

sub getdatasetflag {
	my ($datasetname, $bitnumber) = @_;
	my $valid = 0;
	my $datasetnumber = 0;
	my $bitvalue;
	foreach my $setnumber ( 0..$maxdatasetclass ) {

		next if ( ! $datasetclass[$setnumber][0] );

		if ( $datasetname eq $datasetclass[$setnumber][0] ) {
			$valid = 1;
			$datasetnumber = $setnumber;
			last;
		}
		if ( $datasetname eq $datasetclass[$setnumber][4] ) {
			$valid = 1;
			$datasetnumber = $setnumber;
			last;
		}
	};

	# check if the dataset is valid.
	if ( ! $datasetclass[$datasetnumber][0] ) {
		print "getdatasetflag dataset $datasetname is not valid.\n" if $debug3;
		return( 0, 0);
	}

	# check if the bit requested is valid
	if ( $bitnumber < 0 || $bitnumber > 31) {
		print "getdatasetflag bit # $bitnumber is not valid.\n" if $debug3;
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($datasetclass[$datasetnumber][1] >> $bitnumber) & 1 );

	print "getdatasetflag bit $bitnumber requested for dataset $datasetname, bit $bitvalue returned\n" if $debug3;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# scanforhallflag - scan for a particular flag and return first hall class found

sub scanforhallflag {
	my $flagbit = $_[0];

	my $found = 0;
	my $foundhall = 0;
	foreach my $halltype ( 0..$maxhallclass ) {
		next if ! $hallclass[$halltype][0][1];
		next if ! (($hallclass[$halltype][0][1]>>$flagbit)&1);
		$found = 1;
		$foundhall = $halltype;
		last
	}
	return( $found, $foundhall );
};

#------------------------------------------------------------------------------
# getroomident - lookup a room class using a name

sub getroomident {
	my $roomspcname = $_[0];
	my $valid = 0;
	my $roomclassid = 0;
	foreach my $rcnum ( 0..$maxroomclass ) {
		if ( $roomspcname eq $roomclass[$rcnum][0] ) {
			$valid = 1;
			$roomclassid = $rcnum;
			last;
		}
	};

	$roomspcname = $roomclass[$roomclassid][0] if $roomclass[$roomclassid][0];

	return( $roomclassid, $roomspcname );
};

#------------------------------------------------------------------------------
# getlevelident - lookup a level class using a name

sub getlevelident {
	my $levelname = $_[0];
	my $valid = 0;
	my $levelnumber = 0;
	foreach my $lvlnumber ( 0..$maxlevelclass ) {
		if ( $levelname eq $levelclass[$lvlnumber][0] ) {
			$valid = 1;
			$levelnumber = $lvlnumber;
			last;
		}
	};

	$levelname = $levelclass[$levelnumber][0] if $levelclass[$levelnumber][0];

	return( $levelnumber, $levelname );
};

#------------------------------------------------------------------------------
# scanforlevelflag - scan for a particular flag and return first level class found

sub scanforlevelflag {
	my $flagbit = $_[0];

	my $found = 0;
	my $foundlevel = 0;
	foreach my $leveltype ( 0..$maxlevelclass ) {
		next if ! $levelclass[$leveltype][1];
		next if ! (($levelclass[$leveltype][1]>>$flagbit)&1);
		$found = 1;
		$foundlevel = $leveltype;
		last
	}
	return( $found, $foundlevel );
};

#------------------------------------------------------------------------------
# scanfordoorflag - scan for a particular flag and return first door class found

sub scanfordoorflag {
	my $flagbit = $_[0];

	my $found = 0;
	my $founddoor = 0;
	foreach my $doortype ( 0..$maxdoorclass ) {
		next if ! $doorclass[$doortype][1];
		next if ! (($doorclass[$doortype][1]>>$flagbit)&1);
		$found = 1;
		$founddoor = $doortype;
		last
	}
	return( $found, $founddoor );
};

#------------------------------------------------------------------------------
# scanforroomflag - scan for a particular flag and return first room class found

sub scanforroomflag {
	my $flagbit = $_[0];

	my $field=4;
	if ( $flagbit >=32 && $flagbit <= 63 ) {
		$field=5;
		$flagbit -= 32;
	};

	my $found = 0;
	my $foundroom = 0;
	foreach my $roomtype ( 0..$maxroomclass ) {
		next if ! $roomclass[$roomtype][$field];
		next if ! (($roomclass[$roomtype][$field]>>$flagbit)&1);
		$found = 1;
		$foundroom = $roomtype;
		last
	}
	return( $found, $foundroom );
};

#------------------------------------------------------------------------------
# getdoorfillflag - lookup the door fill flag in the room class array

sub getdoorfillflag {
	my ($roomtype) = @_;

	print "getdoorfillflag requested for room type $roomtype\n" if $debug3;
	if ( ! $roomclass[$roomtype][0] ) {
		print "getdoorfillflag room type $roomtype is not valid.\n" if $debug3;
		return(0,0,0,0,0);
	}

	my $bit0 = (($roomclass[$roomtype][13]>>0) & 15);
	my $bit4 = (($roomclass[$roomtype][13]>>4) & 1);
	my $bit5 = (($roomclass[$roomtype][13]>>5) & 1);
	my $bit6 = (($roomclass[$roomtype][13]>>6) & 1);
	my $bit7 = (($roomclass[$roomtype][13]>>7) & 1);

	print "getdoorfillflag requested for room type $roomtype, returned $bit0 $bit4 $bit5 $bit6 $bit7\n" if $debug3;

	return( $bit0, $bit4, $bit5, $bit6, $bit7 );
};

#------------------------------------------------------------------------------
# getthrufillflag - lookup the passthru fill flag in the room class array

sub getthrufillflag {
	my ($roomtype) = @_;

	print "getthrufillflag requested for room type $roomtype\n" if $debug3;
	if ( ! $roomclass[$roomtype][0] ) {
		print "getthrufillflag room type $roomtype is not valid.\n" if $debug3;
		return(0,0,0,0,0);
	}

	my $bit8 = (($roomclass[$roomtype][13]>>8) & 15);
	my $bit12 = (($roomclass[$roomtype][13]>>12) & 1);
	my $bit13 = (($roomclass[$roomtype][13]>>13) & 1);
	my $bit14 = (($roomclass[$roomtype][13]>>14) & 1);
	my $bit15 = (($roomclass[$roomtype][13]>>15) & 1);

	print "getthrufillflag requested for room type $roomtype, returned $bit8 $bit12 $bit13 $bit14 $bit15\n" if $debug3;

	return( $bit8, $bit12, $bit13, $bit14, $bit15 );
};

#------------------------------------------------------------------------------
# getroomclasssizes - lookup room min/max sizes in the room class array

sub getroomclasssizes {
	my $roomspc = $_[0];

	# grab the min/max fields for the particular special room class
	my $roomclassmin = $roomclass[$roomspc][1];
	my $roomclassmax = $roomclass[$roomspc][2];

	# reset values to zero if they are undefined
	$roomclassmin = "0,0,0" if (! $roomclassmin);
	$roomclassmax = "0,0,0" if (! $roomclassmax);

	# split out the X/Y/Z values
	my @min = split(',', $roomclassmin );
	my @max = split(',', $roomclassmax );

	# Assign X/Y/Z values to variables
	my ( $xmin, $ymin, $zmin ) = @min;
	my ( $xmax, $ymax, $zmax ) = @max;

	# assign default values if stored values are zero
	$xmin = $xminroom if (! $xmin);
	$ymin = $yminroom if (! $ymin);
	$zmin = $zminroom if (! $zmin);
	$xmax = $xmaxroom if (! $xmax);
	$ymax = $ymaxroom if (! $ymax);
	$zmax = $zmaxroom if (! $zmax);

	print "getroomclasssizes for room class $roomspc are min $xmin $ymin $zmin max $xmax $ymax $zmax\n" if $debug2;

	return( $xmin, $ymin, $zmin, $xmax, $ymax, $zmax );
};

#------------------------------------------------------------------------------
# getdoorclass - lookup a door class for a door

sub getdoorclass {
	my $class = $doorinfo[$_[0]][9];
	$class = 0 if ! $class;
	return( $class );
};

#------------------------------------------------------------------------------
# gethallflag - lookup a flag in the hallway class array for a cell

sub gethallflag {
	my ( $X, $Y, $Z, $bit) = @_;
	my $field = 0;

	if ( $bit >= 0 && $bit <= 31 ) {
		$field = gethallinfo( $X, $Y, $Z, 1, 1 );
	} elsif ( $bit >= 32 && $bit <= 63 ) {
		$field = gethallinfo( $X, $Y, $Z, 1, 2 );
		$bit -= 32;
	} else {
		print "gethallflag bit # $bit is not valid.\n" if $debug3;
		return( 0, 0);
	}

	# grab the specific bit value requested
	my $bitvalue=(($field >> $bit) & 1 );

	return( 1, $bitvalue );
};

#------------------------------------------------------------------------------
# gethallinfo - get information about a hallway

sub gethallinfo {
	my ( $X, $Y, $Z, $group, $field) = @_;
	my $match = 0;

	my $hall = gethallid( $X, $Y, $Z );
	return( 0) if ! $hall;

	# check if the hall type is valid.
	if ( ! $hallinfo[$hall][1][0] ) {
		print "gethallinfo hall ID $hall at $X $Y $Z is not valid.\n" if $debug3;
		return( 0);
	}

	# check if the field requested is valid
	if ( $field < 0 || $field > 99) {
		print "gethallinfo field # $field is not valid.\n" if $debug3;
		return( 0);
	}

	# get the number of hall class variations
	my $hclass_vari = $hallinfo[$hall][1][34];

	if ( $cached_hv_match && $group == 1 ) {
		if ( $cached_hv_match eq "$hall,$Y" ) {
			$group = $cached_hv_num;
			$match = 1;
		} else {
			$cached_hv_match = '';
		};
	};

	if ( $hclass_vari && $group == 1 && ! $match ) {
		# placeholder for variation selection code
		for my $vari ( 1 .. ( $hclass_vari ) ) {
			my @hc_varitem = split( ',', $hallinfo[$hall][$vari + 1][0] );
			if ( $hc_varitem[0] eq 'RY' ) {
				my $RY = $Y - $hallinfo[$hall][0][2];
				if ( $RY >= $hc_varitem[1] && $RY <= $hc_varitem[2] ) {
					$group = $vari + 1;
					$match = 1;
				};
			} elsif ( $hc_varitem[0] eq 'Y' ) {
				my $SY = $hallinfo[$hall][0][2];
				if ( $SY >= $hc_varitem[1] && $SY <= $hc_varitem[2] ) {
					$group = $vari + 1;
					$match = 1;
				};
			};
			last if $match;
		};
	};

	# store the current value in the cache variables
	$cached_hv_match = "$hall,$Y" if $group;
	$cached_hv_num = $group if $group;

	# grab the specific bit value requested
	my $value=($hallinfo[$hall][$group][$field]);

	return( $value );
};

#------------------------------------------------------------------------------
# sethallinfo - set information field for a hallway

sub sethallinfo {
	my ( $X, $Y, $Z, $group, $field, $value) = @_;

	my $hall = gethallid( $X, $Y, $Z );
	return( 0) if ! $hall;

	# check if the hall type is valid.
	if ( ! $hallinfo[$hall][1][0] ) {
		print "sethallinfo hall ID $hall at $X $Y $Z is not valid.\n" if $debug3;
		return( 0);
	}

	# check if the field specified is valid
	if ( $field < 0 || $field > 99) {
		print "sethallinfo field # $field is not valid.\n" if $debug3;
		return( 0);
	}

	# set the specific bit value
	$hallinfo[$hall][$group][$field] = $value;

	return( 1 );
};


#------------------------------------------------------------------------------
# getlevelflag - lookup a flag in the level class array for a level

sub getlevelflag {
	my ( $ylevel, $bit) = @_;

	my $levelclass = getlevelspc( $ylevel );

	$levelclass = 0 if ( ! $levelclass );

	my ($found, $flag) = getlevelspcflag( $levelclass, $bit );

	return( $found, $flag );
};

#------------------------------------------------------------------------------
# getlevelspcflag - lookup a flag in the level class array

sub getlevelspcflag {
	my ($leveltype, $bitnumber) = @_;
	my ($bitvalue);

	print "getlevelspcflag bit $bitnumber requested for level type $leveltype\n" if $debug3;

	$leveltype = 0 if ! $leveltype;

	# check if the level type is valid.
	if ( ! $levelclass[$leveltype][0] ) {
		print "getlevelspcflag level type $leveltype is not valid.\n" if $debug3;
		return( 0, 0);
	}

	# check if the bit requested is valid
	if ( $bitnumber < 0 || $bitnumber > 31) {
		print "getlevelspcflag bit # $bitnumber is not valid.\n" if $debug3;
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($levelclass[$leveltype][1] >> $bitnumber) & 1 );

	print "getlevelspcflag bit $bitnumber requested for level type $leveltype, bit $bitvalue returned\n" if $debug3;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# getceffectspcflag - lookup a flag in the ceiling effect class array

sub getceffectspcflag {
	my ($ceffecttype, $bitnumber) = @_;
	my ($bitvalue);

	print "getceffectspcflag bit $bitnumber requested for ceffect type $ceffecttype\n" if $debug3;

	# check if the ceiling effect type is valid.
	if ( ! $ceffectclass[$ceffecttype][0] ) {
		print "getceffectspcflag ceffect type $ceffecttype is not valid.\n" if $debug2;
		return( 0, 0);
	}

	# check if the bit requested is valid
	if ( $bitnumber < 0 || $bitnumber > 31) {
		print "getceffectspcflag bit # $bitnumber is not valid.\n" if $debug2;
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($ceffectclass[$ceffecttype][1] >> $bitnumber) & 1 );

	print "getceffectspcflag bit $bitnumber requested for ceffect type $ceffecttype, bit $bitvalue returned\n" if $debug2;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# getfeffectspcflag - lookup a flag in the floor effect class array

sub getfeffectspcflag {
	my ($feffecttype, $bitnumber) = @_;
	my ($bitvalue);

	print "getfeffectspcflag bit $bitnumber requested for feffect type $feffecttype\n" if $debug3;

	# check if the floor effect type is valid.
	if ( ! $feffectclass[$feffecttype][0] ) {
		print "getfeffectspcflag feffect type $feffecttype is not valid.\n" if $debug2;
		return( 0, 0);
	}

	# check if the bit requested is valid
	if ( $bitnumber < 0 || $bitnumber > 31) {
		print "getfeffectspcflag bit # $bitnumber is not valid.\n" if $debug2;
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($feffectclass[$feffecttype][1] >> $bitnumber) & 1 );

	print "getfeffectspcflag bit $bitnumber requested for feffect type $feffecttype, bit $bitvalue returned\n" if $debug2;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# getdoorspcflag - lookup a flag in the door class array

sub getdoorspcflag {
	my ($doortype, $bitnumber) = @_;
	my ($bitvalue);

	print "getdoorspcflag bit $bitnumber requested for door type $doortype\n" if $debug3;

	# check if the door type is valid.
	if ( ! $doorclass[$doortype][0] ) {
		print "getdoorspcflag door type $doortype is not valid.\n" if $debug2;
		return( 0, 0);
	}

	# check if the bit requested is valid
	if ( $bitnumber < 0 || $bitnumber > 31) {
		print "getdoorspcflag bit # $bitnumber is not valid.\n" if $debug2;
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($doorclass[$doortype][1] >> $bitnumber) & 1 );

	print "getdoorspcflag bit $bitnumber requested for door type $doortype, bit $bitvalue returned\n" if $debug2;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# getroomspcflag - lookup a flag in the room class array

sub getroomspcflag {
	my ($roomtype, $bitnumber) = @_;
	my ($bitvalue);
	my $field;

	print "getroomspcflag bit $bitnumber requested for room type $roomtype\n" if $debug3;

	# check if the room type is valid.
	if ( ! $roomclass[$roomtype][0] ) {
		print "getroomspcflag room type $roomtype is not valid.\n" if $debug3;
		return( 0, 0);
	}

	if ( $bitnumber >= 0 && $bitnumber <= 31 ) {
		$field = 4;
	} elsif ( $bitnumber >= 32 && $bitnumber <= 63 ) {
		$field = 5;
		$bitnumber -= 32;
	} else {
		print "getroomspcflag bit # $bitnumber is not valid.\n";
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($roomclass[$roomtype][$field] >> $bitnumber) & 1 );

	print "getroomspcflag bit $field/$bitnumber requested for room type $roomtype, bit $bitvalue returned\n" if $debug3;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# getintspcflag - lookup a flag in the interior class array

sub getintspcflag {
	my ($iclass, $bitnumber) = @_;
	my ($bitvalue);
	my $field;

	print "getintspcflag bit $bitnumber requested for interior type $iclass\n" if $debug3;

	# check if the interior type is valid.
	if ( ! $interiorclass[$iclass][0] ) {
		print "getintspcflag interior type $iclass is not valid.\n" if $debug3;
		return( 0, 0);
	}

	if ( $bitnumber >= 0 && $bitnumber <= 31 ) {
		$field = 13;
	} else {
		print "getroomspcflag bit # $bitnumber is not valid.\n";
		return( 0, 0);
	}

	# grab the specific bit value requested
	$bitvalue=(($interiorclass[$iclass][$field] >> $bitnumber) & 1 );

	print "getintspcflag bit $field/$bitnumber requested for interior type $iclass, bit $bitvalue returned\n" if $debug3;

	# return the value with the valid flag set.
	return( 1, $bitvalue);
};

#------------------------------------------------------------------------------
# setroombitmap - set bitmap of specially-shaped rooms

sub setroombitmap {
	# first array field: room bitmap identifier number
	# second array field:
	# 0=bitmap information, 1=room class information, 2=room cell allocation, 3=door flag allocation
	# 4=door flag group allocation, 5=vhe flag allocation, 6=passthru flag allocation
	#
	# 0 - bitmap information:
	#	0=flags, 1=name, 2=source size, 3=subroom ID characters
	#	4=multi-item fields specified (one item specified per subroom)
	#
	#	flags:
	#
	#	0 - special flags	0x00000001	bit  0:	clear special room name of secondary subrooms
	#				0x00000002	bit  1:	door flag array specified
	#				0x00000004	bit  2:	door group array specified
	#				0x00000008	bit  3:	VHE flag array specified
	#				0x00000010	bit  4: Passthru flag array specified
	#
	# 1 - room class information: same format as a room class set stored under the setroomclasses function
	#
	# door flag characters: f=door flag, p=priority door flag, w/e/n/s/u/d - directional door placeholders (not implemented)
	# room flag characters are specified in "subroom ID characters" field listed above.
	#
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	# bitmap 0 - large arena example: room cell allocation mirrors custom room schematic,
	#	room design roughly indicates internal arena structure.
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	$roombitmaps[0][0][ 0]=0x00000007;
	$roombitmaps[0][0][ 1]="Arena";
	$roombitmaps[0][0][ 2]="8,4,8";
	$roombitmaps[0][0][ 3]="12345";
	$roombitmaps[0][0][ 4]="14,15";
	#
	$roombitmaps[0][1][ 0]="Arena";
	$roombitmaps[0][1][ 1]="8,4,8";
	$roombitmaps[0][1][ 2]="8,4,8";
	$roombitmaps[0][1][ 3]=0;
	$roombitmaps[0][1][ 4]=0x40000054;
	$roombitmaps[0][1][ 5]=0x00000000;
	$roombitmaps[0][1][ 6]=0;
	$roombitmaps[0][1][ 7]=0;
	$roombitmaps[0][1][ 8]=" ";
	$roombitmaps[0][1][ 9]=".";
	$roombitmaps[0][1][12]=0x00000000;
	$roombitmaps[0][1][13]=0x3400;
	$roombitmaps[0][1][14]="3,3,3,6,7";
	$roombitmaps[0][1][15]="3,3,3,6,7";
	$roombitmaps[0][1][16]="utility";
	$roombitmaps[0][1][17]="arena";
	$roombitmaps[0][1][18]=0;
	$roombitmaps[0][1][19]="1";
	$roombitmaps[0][1][20]='';
	$roombitmaps[0][1][21]=0;
	$roombitmaps[0][1][22]='d...,,,,....,,,,...d,,,,....,,,,';
	# room usage mask
	$roombitmaps[0][2][ 0]="11111111 ........ ........ ........";
	$roombitmaps[0][2][ 1]="14444441 .222222. ........ ........";
	$roombitmaps[0][2][ 2]="14444441 .244442. ..3333.. ........";
	$roombitmaps[0][2][ 3]="14444441 .244442. ..3443.. ...55...";
	$roombitmaps[0][2][ 4]="14444441 .244442. ..3443.. ...55...";
	$roombitmaps[0][2][ 5]="14444441 .244442. ..3333.. ........";
	$roombitmaps[0][2][ 6]="14444441 .222222. ........ ........";
	$roombitmaps[0][2][ 7]="11111111 ........ ........ ........";
	# room door flag mask
	$roombitmaps[0][3][ 0]="..ffff.. ........ ........ ........";
	$roombitmaps[0][3][ 1]="........ ...ff... ........ ........";
	$roombitmaps[0][3][ 2]="f......f ........ ...ff... ........";
	$roombitmaps[0][3][ 3]="f......f .f....f. ..f..f.. ........";
	$roombitmaps[0][3][ 4]="f......f .f....f. ..f..f.. ........";
	$roombitmaps[0][3][ 5]="f......f ........ ...ff... ........";
	$roombitmaps[0][3][ 6]="........ ...ff... ........ ........";
	$roombitmaps[0][3][ 7]="..ffff.. ........ ........ ........";
	# room door groups
	$roombitmaps[0][4][ 0]="..4444.. ........ ........ ........";
	$roombitmaps[0][4][ 1]="........ ...44... ........ ........";
	$roombitmaps[0][4][ 2]="1......3 ........ ...44... ........";
	$roombitmaps[0][4][ 3]="1......3 .1....3. ..1..3.. ........";
	$roombitmaps[0][4][ 4]="1......3 .1....3. ..1..3.. ........";
	$roombitmaps[0][4][ 5]="1......3 ........ ...22... ........";
	$roombitmaps[0][4][ 6]="........ ...22... ........ ........";
	$roombitmaps[0][4][ 7]="..2222.. ........ ........ ........";
	#
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	# bitmap 1 - complex room example - rooms 2 thru 6 get converted
	# to hallways.  Static doors are used for rooms 1 and 6.
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	$roombitmaps[1][0][ 0]=0x0000000f;
	$roombitmaps[1][0][ 1]="Temple";
	$roombitmaps[1][0][ 2]="8,4,8";
	$roombitmaps[1][0][ 3]="123456";
	$roombitmaps[1][0][ 4]="5,8,9,14,15";
	#
	$roombitmaps[1][1][ 0]="Temple";
	$roombitmaps[1][1][ 1]="8,4,8";
	$roombitmaps[1][1][ 2]="8,4,8";
	$roombitmaps[1][1][ 3]=0;
	$roombitmaps[1][1][ 4]=0x00000000;
	$roombitmaps[1][1][ 5]='0x00000000,0x40,0x40,0x40,0x40,0x40';
	$roombitmaps[1][1][ 6]=0;
	$roombitmaps[1][1][ 7]=0;
	$roombitmaps[1][1][ 8]=".     ";
	$roombitmaps[1][1][ 9]="......";
	$roombitmaps[1][1][12]=0x00000000;
	$roombitmaps[1][1][13]=0x3400;
	$roombitmaps[1][1][14]="2,5,5,5,5,6";
	$roombitmaps[1][1][15]="2,5,5,5,5,6";
	$roombitmaps[1][1][16]="utility";
	$roombitmaps[1][1][17]="";
	$roombitmaps[1][1][18]=0;
	$roombitmaps[1][1][19]=0;
	$roombitmaps[1][1][20]='Grand Hallway';
	$roombitmaps[1][1][21]=0;
	$roombitmaps[1][1][22]='....,,,,....,,,,....,,,,....,,,,';
	# room cell allocation
	$roombitmaps[1][2][ 0]="........ ........ ........ 22223333";
	$roombitmaps[1][2][ 1]="........ ........ ........ 22223333";
	$roombitmaps[1][2][ 2]="..6666.. ..6666.. ..6666.. 22666633";
	$roombitmaps[1][2][ 3]="..6666.. ..6116.. ..6116.. 22611633";
	$roombitmaps[1][2][ 4]="..6666.. ..6116.. ..6116.. 55611644";
	$roombitmaps[1][2][ 5]="..6666.. ..6666.. ..6666.. 55666644";
	$roombitmaps[1][2][ 6]="........ ........ ........ 55554444";
	$roombitmaps[1][2][ 7]="........ ........ ........ 55554444";
	# door flag allocation
	$roombitmaps[1][3][ 0]="........ ........ ........ .f....f.";
	$roombitmaps[1][3][ 1]="........ ........ ........ f......f";
	$roombitmaps[1][3][ 2]="........ ........ ........ ...sn...";
	$roombitmaps[1][3][ 3]="........ ........ ........ ..w..w..";
	$roombitmaps[1][3][ 4]="........ ........ ........ ..e..e..";
	$roombitmaps[1][3][ 5]="........ ........ ........ ...sn...";
	$roombitmaps[1][3][ 6]="........ ........ ........ f......f";
	$roombitmaps[1][3][ 7]="........ ........ ........ .f....f.";
	# door group allocation
	$roombitmaps[1][4][ 0]="........ ........ ........ .1....1.";
	$roombitmaps[1][4][ 1]="........ ........ ........ 1......1";
	$roombitmaps[1][4][ 2]="........ ........ ........ ........";
	$roombitmaps[1][4][ 3]="........ ........ ........ ........";
	$roombitmaps[1][4][ 4]="........ ........ ........ ........";
	$roombitmaps[1][4][ 5]="........ ........ ........ ........";
	$roombitmaps[1][4][ 6]="........ ........ ........ 1......1";
	$roombitmaps[1][4][ 7]="........ ........ ........ .1....1.";
	# VHE specs
	$roombitmaps[1][5][ 0]="........ ........ ........ ........";
	$roombitmaps[1][5][ 1]="........ ........ ........ ........";
	$roombitmaps[1][5][ 2]="..1111.. ..2222.. ..3333.. ..4444..";
	$roombitmaps[1][5][ 3]="..1..1.. ..2..2.. ..3..3.. ..4..4..";
	$roombitmaps[1][5][ 4]="..1..1.. ..2..2.. ..3..3.. ..4..4..";
	$roombitmaps[1][5][ 5]="..1111.. ..2222.. ..3333.. ..4444..";
	$roombitmaps[1][5][ 6]="........ ........ ........ ........";
	$roombitmaps[1][5][ 7]="........ ........ ........ ........";
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	$maxroombitmap = 1;
};

#------------------------------------------------------------------------------
# placebmroom - place room bitmap on array

sub placebmroom {
	my ( $x, $y, $z, $bmval, $bmflags, $bmrcval ) = @_;

	# pull in room bitmaps
	setroombitmap;

	my ( $bmnum, $found, $bmrclass )  = (0, 0, 0);

	foreach my $bitmap ( 0 .. $maxroombitmap ) {
		my $chkbm = "$roombitmaps[$bitmap][0][1]";
		if ( "$bmval" eq "$chkbm" || "$bmval" eq "$bitmap" ) {
			$bmnum = $bitmap;
			$found = 1;
		}
	}

	die( "Not a valid room bitmap specifier: $bmval\n" ) if ! $found;

	$found = 0;
	foreach my $rclass ( 0 .. $maxroomclass ) {
		my $chkrc = "$roomclass[$rclass][0]";
		if ( "$bmrcval" eq "$chkrc" || "$bmrcval" eq "$rclass" ) {
			$bmrclass = $rclass;
			$found = 1;
			last;
		}
		if ( "$bmrcval" eq "" && "$bmval" eq "$chkrc" ) {
			$bmrclass = $rclass;
			$found = 1;
			last;
		};
	}

	if ( ! $found ) {
		if ( "$bmrcval" eq "" ) {
			$bmrclass = 0;
		} else {
			die( "Not a valid room class specifier: $bmrcval\n" );
		}
	};

	# grab the X/Y/Z mirroring flags
	my $bmxswap = (( $bmflags>>0)&1);
	my $bmyswap = (( $bmflags>>1)&1);
	my $bmzswap = (( $bmflags>>2)&1);
	my $bmhrotate = (( $bmflags>>3)&3);

	my ( $bmsubrooms, $doormaskflag, $doorpriflag, $yinv, $xfieldsize, $xmask, $roomspc );

	my $flags = (( $roombitmaps[$bmnum][0][0]>>24) & 255 );
	my ( $xsize, $ysize, $zsize ) = parsesizeopt( $roombitmaps[$bmnum][0][2] );

	# grab the bitmap room information
	my $success = 0;
	( $success, $xsize, $ysize, $zsize, $bmsubrooms ) = stagebmroom( $bmnum, $bmxswap, $bmyswap, $bmzswap, $bmhrotate );
	return 0 if ( ! $success );

	# limit size to fit on maze
	$xsize = ( $xmazesize - $x ) if ( ($x + $xsize) > $xmazesize );
	$ysize = ( $ymazesize - $y ) if ( ($y + $ysize) > $ymazesize );
	$zsize = ( $zmazesize - $z ) if ( ($z + $zsize) > $zmazesize );

	# limit bitmap rooms to one vertical height in dungeon mode.
	$ysize = 1 if $dungeonmode;

	my @optents = split(',', $roombitmaps[$bmnum][0][4] );

	for my $subroom ( 0 .. $bmsubrooms ) {

	    # check if a room class has been added for this bitmap.
	    my $found = 0;
	    my $bmrcval = $roombitmaps[$bmnum][1][ 0];
	    $bmrcval = "$roombitmaps[$bmnum][1][ 0]" . " (sub-room $subroom)" if ( $subroom );
	    foreach my $rclass ( 0 .. $maxroomclass ) {
		my $chkrc = "$roomclass[$rclass][0]";
		if ( "$bmrcval" eq "$chkrc" ) {
			$bmrclass = $rclass;
			$found = 1;
			last;
		}
	    }
	    if ( ! $found ) {

		$maxroomclass += 1;

		# most info is copied verbatim
		for my $index ( 0 .. 20 ) {
			$roomclass[$maxroomclass][$index]=$roombitmaps[$bmnum][1][$index];
		};

		$roomclass[$maxroomclass][0]="$roombitmaps[$bmnum][1][0]" . " (sub-room $subroom)" if ( $subroom ) ;

		# check if we have specified multiple options for specific entries
		for my $opt ( @optents ) {
			if ( $opt == 8 || $opt == 9 ) {
				# single-character entries are selected with substr
				$roomclass[$maxroomclass][$opt] = substr( $roombitmaps[$bmnum][1][$opt], $subroom, 1 );
			} elsif ( $opt == 2 || $opt == 3 ) {
				# entries which are already comma-separated lists use split with a semicolon
				my @optitem = split(';', $roombitmaps[$bmnum][1][$opt] );
				$roomclass[$maxroomclass][$opt] = $optitem[$subroom];
			} elsif ( $opt == 4 || $opt == 5 || $opt == 10 || $opt == 11 || $opt == 12 || $opt == 13 ) {
				# bit flag entries use split with a comma, but additional values are xor'ed with the first field
				my @optitem = split(',', $roombitmaps[$bmnum][1][$opt] );
				if ( $subroom ) {
					$roomclass[$maxroomclass][$opt] = ( eval $optitem[0] ) ^ ( eval $optitem[$subroom] );
				} else {
					$roomclass[$maxroomclass][$opt] = ( eval $optitem[0] );
				};
			} else {
				# numeric/text entries require split with a comma
				my @optitem = split(',', $roombitmaps[$bmnum][1][$opt] );
				$roomclass[$maxroomclass][$opt] = $optitem[$subroom];
			};
		};

		# check if we have to clear the room name of secondary rooms
		my $bmclrrsp = (( $roombitmaps[$bmnum][0][0] >> 0 ) & 1 );
		if ( $bmclrrsp  && $subroom ) {
			$roomclass[$maxroomclass][17]='';
		};

		# check if we have to prevent rooms from rendering.
		my $bmnorend = (( $roombitmaps[$bmnum][0][0] >> 0 ) & 16 );
		if ( $bmnorend ) {
			$roomclass[$maxroomclass][4]=( $roomclass[$maxroomclass][4] | ( 1<<30 ));
		};

		$roomspc = $maxroomclass;

	    } else {
		$roomspc = $bmrclass;
	    };

	    # add an array entry for the room
	    my $room = addrooment( $x, $y, $z, $xsize, $ysize, $zsize, $roomspc);

	    # abandon adding bitmap room if the room number is invalid
	    return 0 if ! $room;

	    # set the use flag, roomid, roomspc, and clear the door flag for all used cells.
	    foreach my $zinc ( 0..($zsize-1)) {
		foreach my $YI ( 0..($ysize-1)) {

		    foreach my $xinc ( 0..($xsize-1)) {
			my $XI = $xinc;
			my $ZI = $zinc;

			my ( $usebit, $doorbit, $doorpribit, $doorgpval, $vheval, $ptbit ) = ( 0, 0, 0, 0, 0, 0 );

			# obtain bits from bitmap staging grid
			$usebit = 1 if (( $bmstagegrid[$xinc][$YI][$zinc] & 0xff ) == $subroom);
			$doorbit = 1 if (( $bmstagegrid[$xinc][$YI][$zinc] & 0x0100 ) && $usebit );
			$doorpribit = 1 if (( $bmstagegrid[$xinc][$YI][$zinc] & 0x0200 ) && $usebit );
			$ptbit = 1 if (( $bmstagegrid[$xinc][$YI][$zinc] & 0x0400 ) && $usebit );
			$doorgpval = (( $bmstagegrid[$xinc][$YI][$zinc] & 0xf0000 ) >> 16) if $usebit;
			$vheval = (( $bmstagegrid[$xinc][$YI][$zinc] & 0xf00000 ) >> 20) if $usebit;

			# skip this bit update if use-bit is 0 in bitmap
			next if (! $usebit);

			my $xcoord = ( $x + $XI );
			my $ycoord = ( $y + $YI );
			my $zcoord = ( $z + $ZI );

			my $valid = checkbounds( $xcoord, $ycoord, $zcoord );
			next if ! $valid;

			# toggle the door bits based on the door flags
			setdoorflag( $xcoord, $ycoord, $zcoord, 1) if ( $doorbit | $doorpribit );
			cleardoorflag( $xcoord, $ycoord, $zcoord, 1) if (! ($doorbit | $doorpribit));
			setpridoorflag( $xcoord, $ycoord, $zcoord) if ( $doorpribit );
			setdoorgp( $xcoord, $ycoord, $zcoord, $doorgpval ) if ( $doorgpval );
			setvhe( $xcoord, $ycoord, $zcoord, $vheval ) if ( $vheval );
			setthruflag( $xcoord, $ycoord, $zcoord, 1 ) if ( $ptbit );

			# set the room id and special room identifier for this cell
			setroomid( $xcoord, $ycoord, $zcoord, $room );
		    }
		}
	    }
	     
	    # open paths between room cells
	    foreach my $ZI ( 0..($zsize-1)) {
		foreach my $YI ( 0..($ysize-1)) {
		    foreach my $XI ( 0..($xsize-1)) {

			my $xcoord = ( $x + $XI );
			my $ycoord = ( $y + $YI );
			my $zcoord = ( $z + $ZI );

			# skip this location if it does not belong to this room
			my $roomid = getroomid( $xcoord, $ycoord, $zcoord );
			next if ( $roomid != $room );

			# clear out all walls for this room cell
			clearallpaths( $xcoord, $ycoord, $zcoord );

			# add walls back based on room cell adjacency
			my $path = 0;
			foreach my $dir ( 1..6 ) {
				my ($xdir, $ydir, $zdir) = getmazedirection( $dir );
				my $xcheck = $xcoord + $xdir;
				my $ycheck = $ycoord + $ydir;
				my $zcheck = $zcoord + $zdir;

				my $roomid = 0;

				# get adjacent room id, if the cell is within the array
				my $valid = checkbounds( $xcheck, $ycheck, $zcheck );
				$roomid = getroomid( $xcheck, $ycheck, $zcheck ) if $valid;

				if ( $roomid != $room ) {
					# set the wall flag if the adjacent cell does not belong to this room
					setpath($xcoord, $ycoord, $zcoord, $dir);
					my $pathval = getpathflags( $xcoord, $ycoord, $zcoord );
				};
			}

			# set new wall configuration and wall reference for cell
			my $pathval = getpathflags( $xcoord, $ycoord, $zcoord );
			setsegment( $xcoord, $ycoord, $zcoord, $pathval );
		    }
		}
	    }
	};

	# Add any static doors specified on door bitmap
	foreach my $zinc ( 0..($zsize-1)) {
		foreach my $yinc ( 0..($ysize-1)) {
		    foreach my $xinc ( 0..($xsize-1)) {

			# obtain static door flags from bitmap staging grid
			my $stdoorflag = (( $bmstagegrid[$xinc][$yinc][$zinc] & 0x7000 ) >> 12 );
			next if ( ! $stdoorflag );

			my $xcoord = ( $x + $xinc );
			my $ycoord = ( $y + $yinc );
			my $zcoord = ( $z + $zinc );

			# open the path in the arrays
			openpath( $xcoord, $ycoord, $zcoord, $stdoorflag, 4, 0 );

			# add a room-to-room doorway
			my $doorclass = 16;
			my $doornum = addtodoorlist( 0, $xcoord, $ycoord, $zcoord, $stdoorflag, 1, $doorclass, 0 );

			# increment door count of attached room
			my ( $XI, $YI, $ZI ) = getmazedirection( $stdoorflag );
			my $roomid2 = getroomid( $xcoord + $XI, $ycoord + $YI, $zcoord + $ZI );
			$roominfo[$roomid2][10] += 1 if ( $roomid2 );
		    };
		};
	};

};

#------------------------------------------------------------------------------
# clearbacktrack - clear backtrack value for cell

sub clearbacktrack {
	my ( $X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );


	if ( $valid ) {

		my $obt = getbacktrack( $X, $Y, $Z );
		print "clearbacktrack: $X $Y $Z old: $obt\n" if $debug3;

		$mazegrid[$X][$Y][$Z] =
			(($mazegrid[$X][$Y][$Z] | $backmask) ^ $backmask);
	};
};

#------------------------------------------------------------------------------
# setbacktrack - set backtrack value for cell

sub setbacktrack {

	my ( $X, $Y, $Z, $backdir ) = @_;

	my $obt = getbacktrack( $X, $Y, $Z );
	print "setbacktrack: $X $Y $Z to $backdir (previously: $obt)\n" if $debug3;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		$mazegrid[$X][$Y][$Z] =
			((($mazegrid[$X][$Y][$Z] | $backmask) ^ $backmask) | ($backdir << $backshft ));
	};
};

#------------------------------------------------------------------------------
# getbacktrack - get backtrack value for cell

sub getbacktrack {
	my ( $X, $Y, $Z ) = @_;
	my $backdir;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $checkcell = $mazegrid[$X][$Y][$Z];

		$backdir = ( ( $checkcell & $backmask ) >> $backshft );
	};

	return( $backdir );
};

#------------------------------------------------------------------------------
# setobjidx - set object index/count values

sub setobjidx {
	my ( $X, $Y, $Z, $objidx, $objct ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	$objidx = 0 if ! $objidx;
	$objct = 0 if ! $objct;

	if ( $valid ) {
		my $checkcell = $objmazegrid[$X][$Y][$Z];
		$checkcell = ((($checkcell | $objindexmask) ^ $objindexmask) | (($objidx << $objindexshft) & $objindexmask));
		$checkcell = ((($checkcell | $objcountmask) ^ $objcountmask) | (($objct << $objcountshft) & $objcountmask));
		$objmazegrid[$X][$Y][$Z] = $checkcell;
	};
	
	return( $valid );
};

#------------------------------------------------------------------------------
# setobjvals - set object cell counters

sub setobjvals {
	my ( $X, $Y, $Z, $aobjthr, $tobjthr ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	$aobjthr = 0 if ! $aobjthr;
	$tobjthr = 0 if ! $tobjthr;

	if ( $valid ) {
		my $checkcell = $objmazegrid[$X][$Y][$Z];
		$checkcell = ((($checkcell | $tobjthrmask) ^ $tobjthrmask) | (($tobjthr << $tobjthrshft) & $tobjthrmask));
		$checkcell = ((($checkcell | $aobjthrmask) ^ $aobjthrmask) | (($aobjthr << $aobjthrshft) & $aobjthrmask));
		$objmazegrid[$X][$Y][$Z] = $checkcell;
	};
	
	return( $valid );
};


#------------------------------------------------------------------------------
# getobjvals - get object cell counters

sub getobjvals {
	my ( $X, $Y, $Z ) = @_;
	my ( $aobjthr, $tobjthr, $objidx, $objct );
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $checkcell = $objmazegrid[$X][$Y][$Z];

		$aobjthr = ( ( $checkcell & $aobjthrmask ) >> $aobjthrshft );
		$tobjthr = ( ( $checkcell & $tobjthrmask ) >> $tobjthrshft );
		$objidx = ( ( $checkcell & $objindexmask ) >> $objindexshft );
		$objct = ( ( $checkcell & $objcountmask ) >> $objcountshft );
	};

	return( $aobjthr, $tobjthr, $objidx, $objct );
};

#------------------------------------------------------------------------------
# getcellinfo - get the binary information for a cell

sub getcellinfo {
	my ( $X, $Y, $Z ) = @_;
	my ( $celluse, $pathava, $backdir, $segment, $roomid, $dist );
	my ( $feffectlvl, $feffecttype );
	my ( $ceffectlvl, $ceffecttype );
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $checkcell = $mazegrid[$X][$Y][$Z];
		my $auxcheckcell = $auxmazegrid[$X][$Y][$Z];
		my $distcheckcell = $distmazegrid[$X][$Y][$Z];

		$celluse    = ( ( $checkcell & $cellusemask ) >> $celluseshft );
		$pathava    = ( ( $checkcell & $pathmask ) >> $pathshft );
		$backdir    = ( ( $checkcell & $backmask ) >> $backshft );
		$segment    = ( ( $auxcheckcell & $segmentmask ) >> $segmentshft );
		$roomid     = ( ( $auxcheckcell & $roomidmask ) >> $roomidshft );
		$dist       = ( ( $distcheckcell & $distmask ) >> $distshft );
		$feffectlvl   = ( ( $distcheckcell & $felevlmask ) >> $felevlshft );
		$feffecttype  = ( ( $distcheckcell & $fetypemask ) >> $fetypeshft );
		$ceffectlvl   = ( ( $distcheckcell & $celevlmask ) >> $celevlshft );
		$ceffecttype  = ( ( $distcheckcell & $cetypemask ) >> $cetypeshft );

		print "getcellinfo: $X $Y $Z valid $valid use $celluse path $pathava bd $backdir rseg $segment " if $debug3;
		print "rid $roomid dist $dist flvl $feffectlvl ftype $feffecttype clvl $ceffectlvl ctype $ceffecttype\n" if $debug3;
	} else {
		print "getcellinfo: invalid location at $X $Y $Z\n" if $debug3;
	};

	return( $valid, $celluse, $pathava, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype );
};

#------------------------------------------------------------------------------
# printansimaze - output the ascii maze with ansi color codes

sub printansimaze {
	open(OUTPUT, ">$fileprefix.ans");
	my $ocolor = -1;
	foreach my $yinc (0..$ymazesize-1) {
	    my $leveltype = $levelinfo[$yinc][0];
	    print OUTPUT "\nmaze level $yinc - $levelclass[$leveltype][0]\n\n";
	    foreach my $zinc (0..($zmazesize * 2 )) {
	    	foreach my $xinc (0..($xmazesize * 2 )) {
			my $char=$asciigrid[$xinc][$yinc][$zinc];
			my $color=$colorgrid[$xinc][$yinc][$zinc];
			my $fg = ( $color & 7 );
			my $bg = (( $color >> 3 ) & 7 );
			my $hi = (( $color >> 6 ) & 1 );
			$char = '?' if ( "X$char" eq "X" );

			if ( $color == $ocolor ) {
				print OUTPUT "$char";
			} else {
				printf OUTPUT "[%1d;4%1d;3%1dm%s",$hi,$bg,$fg,$char;
			};
			$ocolor = $color;
		}
	    print OUTPUT "\n";
	    $ocolor = -1;
	    }
	print OUTPUT "[0m\n";
	}
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printasciimaze - output the ascii maze

sub printasciimaze {
	open(OUTPUT, ">$fileprefix.txt");
	my $char;
	foreach my $yinc (0..$ymazesize-1) {
	    my $leveltype = $levelinfo[$yinc][0];
	    print OUTPUT "\nmaze level $yinc - $levelclass[$leveltype][0]\n\n";
	    foreach my $zinc (0..($zmazesize * 2 )) {
	    	foreach my $xinc (0..($xmazesize * 2 )) {
			$char=$asciigrid[$xinc][$yinc][$zinc];
			$char = '?' if ( "X$char" eq "X" );
			print OUTPUT "$char";
		}
	    print OUTPUT "\n";
	    }
	print OUTPUT "\n";
	}
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printbackdirmap - print a grid of backtrack fields

sub printbackdirmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nBacktrack map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $backtrack = getbacktrack( $xinc, $yinc, $zinc );
		print OUTPUT  "." if $backtrack == 0;
		print OUTPUT  "<" if $backtrack == 1;
		print OUTPUT  ">" if $backtrack == 2;
		print OUTPUT  "^" if $backtrack == 3;
		print OUTPUT  "v" if $backtrack == 4;
		print OUTPUT  "d" if $backtrack == 5;
		print OUTPUT  "u" if $backtrack == 6;
		print OUTPUT  "?" if $backtrack == 7;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printceffecttype - print a grid of ceiling effect type information

sub printceffecttype {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nCeiling effect type field map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xinc, $yinc, $zinc );
		print OUTPUT "." if (! $ceffectlvl);
		printf OUTPUT '%1d', $ceffecttype if $ceffectlvl;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printfeffecttype - print a grid of floor effect type information

sub printfeffecttype {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nFloor effect type field map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ($feffectlvl, $feffecttype) = getfeffectlvl( $xinc, $yinc, $zinc );
		print OUTPUT "." if (! $feffectlvl);
		printf OUTPUT '%1d', $feffecttype if $feffectlvl;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printceffectlvl - print a grid of ceiling effect level information

sub printceffectlvl {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nCeiling effect level field map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xinc, $yinc, $zinc );
		print OUTPUT "." if (! $ceffectlvl);
		printf OUTPUT '%1d', $ceffectlvl if $ceffectlvl;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printfeffectlvl - print a grid of floor effect level information

sub printfeffectlvl {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nFloor effect level field map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ($feffectlvl, $feffecttype) = getfeffectlvl( $xinc, $yinc, $zinc );
		print OUTPUT "." if (! $feffectlvl);
		printf OUTPUT '%1d', $feffectlvl if $feffectlvl;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printobjtthrmap - print a grid of treasure object threshold fields

sub printobjtthrmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nTreasure object threshold map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $objtthr = (( $objmazegrid[$xinc][$yinc][$zinc] & $tobjthrmask ) >> $tobjthrshft );
		print OUTPUT " . " if ! $objtthr;
		printf OUTPUT '%2x ', $objtthr if $objtthr;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printobjathrmap - print a grid of architecture object threshold fields

sub printobjathrmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nArchitectural object threshold map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $objathr = (( $objmazegrid[$xinc][$yinc][$zinc] & $aobjthrmask ) >> $aobjthrshft );
		print OUTPUT " . " if ! $objathr;
		printf OUTPUT '%2x ', $objathr if $objathr;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printcellspc - print a grid of hallway special fields

sub printcellspc {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nCell special field map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $cellspc = getcellspc( $xinc, $yinc, $zinc );
		print OUTPUT " . " if ! $cellspc;
		printf OUTPUT '%2x ', $cellspc if $cellspc;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printpathmap - print a grid of room path id fields

sub printpathmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nRoom path flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $path = getpathflags( $xinc, $yinc, $zinc );
		print OUTPUT "  ." if ! $path;
		printf OUTPUT '%3d', $path if $path;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printsegmentmap - print a grid of room segment id fields

sub printsegmentmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nRoom segment id map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $segment = getsegment( $xinc, $yinc, $zinc );
		print OUTPUT "  ." if ! $segment;
		printf OUTPUT '%3d', $segment if $segment;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printhallclassmap - print a grid of hallclass fields

sub printhallclassmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nHallway class map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $hall = gethallid( $xinc, $yinc, $zinc );
		my $hallclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
		print OUTPUT "  ." if ! $hallclass;
		printf OUTPUT '%3d', $hallclass if $hallclass;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printthreadmap - print a grid of cell thread ownership

sub printthreadmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nThread Cell Ownership map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $threadfield = $thrmazegrid[$xinc][$yinc][$zinc];
		my ( $thread, $multthreads ) = ( 0, 0 );
		foreach my $bit ( 0..31 ) {
			if ( $threadfield & ( 1 << $bit ) ) {
				$multthreads = 1 if ( $thread != 0 );
				$thread = ( $bit + 1 );
			}
		}
		my $char = '?';
		$char = "." if $thread == 0;
		$char = "0" if $thread == 1;
		$char = "1" if $thread == 2;
		$char = "2" if $thread == 3;
		$char = "3" if $thread == 4;
		$char = "4" if $thread == 5;
		$char = "5" if $thread == 6;
		$char = "6" if $thread == 7;
		$char = "7" if $thread == 8;
		$char = "8" if $thread == 9;
		$char = "9" if $thread == 10;
		$char = "A" if $thread == 11;
		$char = "B" if $thread == 12;
		$char = "C" if $thread == 13;
		$char = "D" if $thread == 14;
		$char = "E" if $thread == 15;
		$char = "F" if $thread == 16;
		$char = "G" if $thread == 17;
		$char = "H" if $thread == 18;
		$char = "I" if $thread == 19;
		$char = "J" if $thread == 20;
		$char = "K" if $thread == 21;
		$char = "L" if $thread == 22;
		$char = "M" if $thread == 23;
		$char = "N" if $thread == 24;
		$char = "O" if $thread == 25;
		$char = "P" if $thread == 26;
		$char = "Q" if $thread == 27;
		$char = "R" if $thread == 28;
		$char = "S" if $thread == 29;
		$char = "T" if $thread == 30;
		$char = "U" if $thread == 31;
		$char = "V" if $thread == 32;
		$char = "*" if $multthreads;
		print OUTPUT "$char";
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printobjcountmap - print a grid of object counts

sub printobjcountmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nObject count map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $objcount = (( $objmazegrid[$xinc][$yinc][$zinc] & $objcountmask ) >> $objcountshft );
		print OUTPUT "." if ! $objcount;
		printf OUTPUT '%1d', $objcount if $objcount;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printfevmap - print a grid of fev fields

sub printfevmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nFloor Elevation Variance map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $fevvalue = getfev( $xinc, $yinc, $zinc );
		print OUTPUT "." if ! $fevvalue;
		printf OUTPUT '%1d', $fevvalue if $fevvalue;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printvhemap - print a grid of vhe fields

sub printvhemap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nVertical Hallway Expansion id map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $vheflags = getvhe( $xinc, $yinc, $zinc );
		print OUTPUT "." if ! $vheflags;
		printf OUTPUT '%1d', $vheflags if $vheflags;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printhallgstylemap - print a grid of hallway gstyle fields

sub printhallgstylemap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nHallway global style map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ( $gstyle, $lstyle ) = gethallstyle( $xinc, $yinc, $zinc );
		print OUTPUT "." if ! $gstyle;
		printf OUTPUT '%1x', $gstyle if $gstyle;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printhalllstylemap - print a grid of hallway lstyle fields

sub printhalllstylemap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nHallway local style map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ( $gstyle, $lstyle ) = gethallstyle( $xinc, $yinc, $zinc );
		print OUTPUT "." if ! $lstyle;
		printf OUTPUT '%1x', $lstyle if $lstyle;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printhallidmap - print a grid of hallid fields

sub printhallidmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nHallway id map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $hallid = gethallid( $xinc, $yinc, $zinc );
		print OUTPUT "  ." if ! $hallid;
		printf OUTPUT '%3d', $hallid if $hallid;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printroomidmap - print a grid of roomid fields

sub printroomidmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nRoom id map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $roomid = getroomid( $xinc, $yinc, $zinc );
		print OUTPUT "  ." if ! $roomid;
		printf OUTPUT '%3d', $roomid if $roomid;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printledgeflags - print a grid of ledge fields

sub printledgeflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "Ledge flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $ledge = (( $adjmazegrid[$xinc][$yinc][$zinc] & $ledgemask ) >> $ledgeshft );
		print OUTPUT "." if ! $ledge;
		printf OUTPUT '%1x', $ledge if $ledge;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printuseflags - print a grid of use flag fields

sub printuseflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "Use flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $used = (( $mazegrid[$xinc][$yinc][$zinc] & $cellusemask ) >> $celluseshft );
		print OUTPUT "." if ! $used;
		printf OUTPUT '%1x', $used if $used;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printothruflags - print a grid of original thruflag fields

sub printothruflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nOriginal Passthru flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $thru = (( $mazegrid[$xinc][$yinc][$zinc] & $othrumask ) >> $othrushft );
		print OUTPUT "." if ! $thru;
		printf OUTPUT '%1x', $thru if $thru;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printodoorflags - print a grid of original doorflag fields

sub printodoorflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nOriginal Door flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $door = (( $mazegrid[$xinc][$yinc][$zinc] & $odoormask ) >> $odoorshft );
		print OUTPUT "." if ! $door;
		printf OUTPUT '%1x', $door if $door;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printthruflags - print a grid of thruflag fields

sub printthruflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nPassthru flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $thru = (( $mazegrid[$xinc][$yinc][$zinc] & $thrumask ) >> $thrushft );
		print OUTPUT "." if ! $thru;
		printf OUTPUT '%1x', $thru if $thru;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printdoorflags - print a grid of doorflag fields

sub printdoorflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nDoor flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $door = (( $mazegrid[$xinc][$yinc][$zinc] & $doormask ) >> $doorshft );
		print OUTPUT "." if ! $door;
		printf OUTPUT '%1x', $door if $door;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printdoorgroups - print a grid of doorgroup fields

sub printdoorgroups {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nDoor group map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $doorgp = getdoorgp( $xinc, $yinc, $zinc );
		print OUTPUT "." if ! $doorgp;
		printf OUTPUT '%1x', $doorgp if $doorgp;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printdiagpathflags - print a grid of diagonal path flags

sub printdiagpathflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nDiagonal path flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $diag = (( $mazegrid[$xinc][$yinc][$zinc] & $diagpathmask ) >> $diagpathshft );
		print OUTPUT "." if ! $diag;
		print OUTPUT "1" if $diag;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printpridoorflags - print a grid of pridoorflag fields

sub printpridoorflags {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nPriority Door flag map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $door = (( $adjmazegrid[$xinc][$yinc][$zinc] & $pridoormask ) >> $pridoorshft );
		print OUTPUT "." if ! $door;
		printf OUTPUT '%1x', $door if $door;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printseed - print the seed value

sub printseed {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nSeed: $seed\n\n" if $seed;
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printobjidxmap - print a grid of object index fields

sub printobjidxmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nObject index map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $objidx = (( $objmazegrid[$xinc][$yinc][$zinc] & $objindexmask ) >> $objindexshft );
		printf OUTPUT '%4x', $objidx;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# printdistmap - print a grid of distance fields

sub printdistmap {
	open(OUTPUT, ">>$fileprefix.diag");
	print OUTPUT "\nDistance field map\n\n";
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my $dist = (( $distmazegrid[$xinc][$yinc][$zinc] & $distmask ) >> $distshft );
		printf OUTPUT '%4x', $dist;
	    }
	    print OUTPUT "\n";
	  }
	print OUTPUT "\n\n";
        }
	close( OUTPUT );
};

#------------------------------------------------------------------------------
# randomnumberlist - generate a randomized list of numbers

sub randomnumberlist {
	my ( $maxnum ) = @_;

	my @rnumlist = (1..$maxnum);

	my @randnums;

	while (@rnumlist) {
		push @randnums, splice(@rnumlist, rand(@rnumlist), 1);
	};
	return @randnums;
};

#------------------------------------------------------------------------------
# randomroomclasslist - generate a list of random rooms matching a special bit

sub randomroomclasslist {
	my ( $entry, $flagbit ) = @_;
	my @roommatches;
	my @randroomlist;

	my $found = 0;
	foreach my $roomtype ( 0..$maxroomclass ) {
		next if ! $roomclass[$roomtype][$entry];
		next if ! (($roomclass[$roomtype][$entry]>>$flagbit)&1);
		$found += 1;
		push ( @roommatches, $roomtype );
	}

	# while (@roommatches) { push @randroomlist, splice(@roommatches, rand(@roommatches), 1); };
	# return @randroomlist;
	return ( $found, splice(@roommatches, rand(@roommatches), 1)) if $found;
	return (0, 0);
};

#------------------------------------------------------------------------------
# randomdirectionlist - generate a list of random directions

sub randomdirectionlist {
	my ( $roomid, $X, $Y, $Z) = @_;

	# this will always prioritize random N/S/E/W directions over U/D directions

	my @availdirs;
	my @rnumlist = (1..4);

	my $segment = getsegment( $X, $Y, $Z );
	my $vheflags = getvhe( $X, $Y, $Z );

	# determine if the level allows vertical directions
	my ( $valid_b7, $levelspc_b7) = getlevelflag( $Y, 7 );
	my ( $ulvalid_b7, $ulevelspc_b7) = getlevelflag( $Y-1, 7 );
	my ( $dlvalid_b7, $dlevelspc_b7) = getlevelflag( $Y+1, 7 );

	# determine if the hallway allows vertical directions
	my ( $valid_b0, $hallspc_b0) = gethallflag( $X, $Y, $Z, 0 );
	my ( $uhvalid_b0, $uhallspc_b0) = gethallflag( $X, $Y-1, $Z, 0 );
	my ( $dhvalid_b0, $dhallspc_b0) = gethallflag( $X, $Y+1, $Z, 0 );

	my ( $start, $end, $extended ) = ( 20,19,0 );

	# determine if we have any upward diagonal directions available
	if (( $segment & 16 ) == 0 && $vheflags == 0b100 ) {
		$extended = 1;
		$start = 16;
		my $valid2 = checkbounds( $X, $Y-1, $Z );
		my $valid3 = checkbounds( $X, $Y-2, $Z );
		my $segment2 = getsegment( $X, $Y-1, $Z ) & 16 if ( $valid2 );
		my $segment3 = getsegment( $X, $Y-2, $Z ) & 16 if ( $valid3 );
		$start = 12 if ( $valid2 && ! $segment2 );
		$start = 8 if ( $valid2 && $valid3 && ! $segment2 && ! $segment3);
	};

	# determine if we have any downward diagonal directions available
	if (( $segment & 32 ) == 0 && $vheflags == 0b100 ) {
		$extended = 1;
		$end = 23;
		my $valid2 = checkbounds( $X, $Y+1, $Z );
		my $valid3 = checkbounds( $X, $Y+2, $Z );
		my $segment2 = getsegment( $X, $Y+1, $Z ) & 32 if ( $valid2 );
		my $segment3 = getsegment( $X, $Y+2, $Z ) & 32 if ( $valid3 );
		$end = 27 if ( $valid2 && ! $segment2 );
		$end = 31 if ( $valid2 && $valid3 && ! $segment2 && ! $segment3);
	};

	@rnumlist = ( 1..4,$start..$end ) if ( $extended );

	# randomize the direction list
	while (@rnumlist) {
		push @availdirs, splice(@rnumlist, rand(@rnumlist), 1);
	};

	# only allow up/down if we are in a hallway and if the level allows it
	if ( $roomid == 0 && $updowndirs && ( ! $levelspc_b7 ) && ( ! $hallspc_b0 )) {
		if (int(rand(2))) {
			push (@availdirs, 5) if ((! $ulevelspc_b7 )&&(! $uhallspc_b0 ));
			push (@availdirs, 6) if ((! $dlevelspc_b7 )&&(! $dhallspc_b0 ));
		} else {
			push (@availdirs, 6) if ((! $dlevelspc_b7 )&&(! $dhallspc_b0 ));
			push (@availdirs, 5) if ((! $ulevelspc_b7 )&&(! $uhallspc_b0 ));
		};
	}

	return( @availdirs );
};

#------------------------------------------------------------------------------
# getmazedirection - convert numeric direction to actual relative coordinates

sub getmazedirection {

	my $direction = $_[0];

	# use direction number to determine X/Y/Z movement
	# 1..6 = west/east/north/south/up/down
	# 8..11 = west/east/north/south of upper vhe +3
	# 12..15 = west/east/north/south of upper vhe +2
	# 16..19 = west/east/north/south of upper vhe +1
	# 20..23 = west/east/north/south of lower vhe +1
	# 24..27 = west/east/north/south of lower vhe +2
	# 28..31 = west/east/north/south of lower vhe +3

	my ( $XI,$YI,$ZI ) = (0, 0, 0 );
	$XI = -1 if $direction == 1;
	$XI = 1  if $direction == 2;
	$ZI = -1 if $direction == 3;
	$ZI = 1  if $direction == 4;
	$YI = -1 if $direction == 5;
	$YI = 1  if $direction == 6;

	print "getmazedirection for $direction is $XI $YI $ZI\n" if ( $direction < 8 && $debug3 );
	return( $XI, $YI, $ZI ) if ( $direction < 8 );

	$XI = -1 if ($direction & 0x03) == 0;
	$XI = 1  if ($direction & 0x03) == 1;
	$ZI = -1 if ($direction & 0x03) == 2;
	$ZI = 1  if ($direction & 0x03) == 3;

	$YI = -3 if (($direction >= 8) && ($direction <= 11));
	$YI = -2 if (($direction >= 12) && ($direction <= 15));
	$YI = -1 if (($direction >= 16) && ($direction <= 19));
	$YI =  1 if (($direction >= 20) && ($direction <= 23));
	$YI =  2 if (($direction >= 24) && ($direction <= 27));
	$YI =  3 if (($direction >= 28) && ($direction <= 31));

	print "getmazedirection for $direction is $XI $YI $ZI\n" if $debug3;

	return( $XI, $YI, $ZI );
};

#------------------------------------------------------------------------------
# getdirmasks - generate the bit masks for a numeric direction

sub getdirmasks {
	# use direction number to determine forward/reverse masks

	my $dir = $_[0];
	my $odir = $_[0];
	$dir -= 27 if ( $dir >= 28 );
	$dir -= 23 if ( $dir >= 24 );
	$dir -= 19 if ( $dir >= 20 );
	$dir -= 15 if ( $dir >= 16 );
	$dir -= 11 if ( $dir >= 12 );
	$dir -= 7  if ( $dir >= 8 );

	my ( $FM,$RM, $SFM, $SRM ) = (0, 0 );
	$FM=(1<<($dir-1+$pathshft) & $pathmask ) if $dir > 0;
	$RM=(1<<((($dir-1)^1)+$pathshft) & $pathmask ) if $dir > 0;
	$SFM=(1<<($dir-1+$segmentshft) & $segmentmask ) if $dir > 0;
	$SRM=(1<<((($dir-1)^1)+$segmentshft) & $segmentmask ) if $dir > 0;

	return( $FM, $RM, $SFM, $SRM );
};

#------------------------------------------------------------------------------
# addrooms - generate and verify random rooms

sub addrooms {

	# limit room creation to a specified range
	my ( $fromlevel, $tolevel ) = @_;
	my $numlevels = ( $tolevel - $fromlevel + 1 );

	my ( $xroomsize, $yroomsize, $zroomsize );
	my ( $xroomcorner, $yroomcorner, $zroomcorner );
	my ( $xfcorner, $yfcorner, $zfcorner );

	# add rooms specified by -placeroom and -placelevel options.
	if ( $setroomcount != 0 ) {
		foreach my $setroom ( 1..$setroomcount ) {
			my $rmx = $setrooms[ $setroom ][0];
			my $rmy = $setrooms[ $setroom ][1];
			my $rmz = $setrooms[ $setroom ][2];
			my $rmxs = $setrooms[ $setroom ][3];
			my $rmys = $setrooms[ $setroom ][4];
			my $rmzs = $setrooms[ $setroom ][5];
			my $rspc = $setrooms[ $setroom ][6];

			print "placeroom $rmx $rmy $rmz size $rmxs $rmys $rmzs rspc $rspc\n" if $debug2;

			# skip this if specified room is outside of level range
			next if ($rmy < $fromlevel || $rmy > $tolevel);
			
			# add a room entry to the room list
			my $room = addrooment( $rmx, $rmy, $rmz, $rmxs, $rmys, $rmzs, $rspc );

			# build room into the array
			buildroom( $room, $rspc ) if ( $room );
		};
	};

	# add rooms specified by -bitmaproom options.
	if ( $bmroomcount != 0 ) {
		foreach my $bmroom ( 1..$bmroomcount ) {
			my $bmx = $bmrooms[ $bmroom ][0];
			my $bmy = $bmrooms[ $bmroom ][1];
			my $bmz = $bmrooms[ $bmroom ][2];
			my $bmid = $bmrooms[ $bmroom ][3];
			my $bmflags = $bmrooms[ $bmroom ][4];
			my $bmrclass = $bmrooms[ $bmroom ][5];

			# skip this if bitmap room is outside of level range
			next if ($bmy < $fromlevel || $bmy > $tolevel);
			
			placebmroom( $bmx, $bmy, $bmz, $bmid, $bmflags, $bmrclass );
		};
	};

	# add noroom blocks specified by -noroomblock options
	if ( $noroomcount != 0 ) {
		foreach my $noroom ( 1..$noroomcount ) {
			my $nrx = $norooms[ $noroom ][0];
			my $nry = $norooms[ $noroom ][1];
			my $nrz = $norooms[ $noroom ][2];
			my $nrxs = $norooms[ $noroom ][3];
			my $nrys = $norooms[ $noroom ][4];
			my $nrzs = $norooms[ $noroom ][5];

			placenoroomblock( $nrx, $nry, $nrz, $nrxs, $nrys, $nrzs );
		};
	};

	my @roomaddorder;
	my $roomaddordermax = -1;

	# determine what order we add the varous room types
	foreach my $roomtype ( 0..$maxroomclass ) {

		my $order = $roomclass[$roomtype][21];

		# skip adding rooms for this room type if we have none listed to auto-add.
		next if (! $roomclass[$roomtype][7] && ! $dungeonmode);
		next if (! $roomclass[$roomtype][6] && $dungeonmode);

		# skip adding rooms if we specify a zero room placement order
		next if ( ! $order );

		$roomaddordermax += 1;
		$roomaddorder[$roomaddordermax] = ( ( $order * 1000 ) + $roomtype );
	};

	# sort the room placement order list
	@roomaddorder = sort {$a <=> $b} @roomaddorder; 

	# add random rooms as defined in the room class array
	foreach my $orderinfo ( 0..$roomaddordermax ) {

		# grab the room type out of the placement order info
		my $roomtype = $roomaddorder[$orderinfo] % 1000;
		my $order = int( $roomaddorder[$orderinfo] / 1000 );

		# skip adding rooms for this room type if we have none listed to auto-add.
		next if (! $roomclass[$roomtype][7] && ! $dungeonmode);
		next if (! $roomclass[$roomtype][6] && $dungeonmode);

		my $roomstoadd = $roomclass[$roomtype][7] if ! $dungeonmode;
		$roomstoadd = $roomclass[$roomtype][6] if $dungeonmode;

		my $spcsel = $roomtype;

		# get room class attributes for this room type.
		my ( $valid_b34, $roomspc_b34) = getroomspcflag( $roomtype, 34 );
		my ( $valid_b33, $roomspc_b33) = getroomspcflag( $roomtype, 33 );
		my ( $valid_b32, $roomspc_b32) = getroomspcflag( $roomtype, 32 );
		my ( $valid_b31, $roomspc_b31) = getroomspcflag( $roomtype, 31 );
		my ( $valid_b27, $roomspc_b27) = getroomspcflag( $roomtype, 27 );
		my ( $valid_b17, $roomspc_b17) = getroomspcflag( $roomtype, 17 );
		my ( $valid_b16, $roomspc_b16) = getroomspcflag( $roomtype, 16 );
		my ( $valid_b15, $roomspc_b15) = getroomspcflag( $roomtype, 15 );
		my ( $valid_b14, $roomspc_b14) = getroomspcflag( $roomtype, 14 );
		my ( $valid_b2, $roomspc_b2) = getroomspcflag( $roomtype, 2 );
		my ( $valid_b42, $roomspc_b42) = getroomspcflag( $roomtype, 42 );
		my ( $valid_b43, $roomspc_b43) = getroomspcflag( $roomtype, 43 );

		# get adjacentrooms setting.
		my $adjacentroomflag = $adjacentrooms;
		$adjacentroomflag = $roomspc_b32 if $roomspc_b32;

		# skip this room type if it is not allowed in dungeon mode
		next if ( $roomspc_b15 && $dungeonmode );

		my ( $xminsize, $yminsize, $zminsize, $xmaxsize, $ymaxsize, $zmaxsize ) =
			getroomclasssizes( $roomtype );

		# get the custom room name
		my $specialname = $roomclass[$roomtype][17];

		# skip this room type if it wouldn't fit into the maze at all.
		next if ( $yminsize > $ymazesize );

		# number of rooms to add is per-level if room special flag bit 17 is set.
		$roomstoadd *= ($ymazesize-$xmaxsize+1) if $roomspc_b17;

		foreach my $roominc ( 1..$roomstoadd ) {
			my $success = 0;

			# override the default room placement attempts if the room class has a setting.
			my $placementattempts = $roomplacetrys;
			$placementattempts = $roomclass[$roomtype][18] if $roomclass[$roomtype][18];

			foreach my $attempt ( 1..$placementattempts ) {

			    # generate random room size based on room class
			    ( $xroomsize, $yroomsize, $zroomsize ) = ( $xminsize,$yminsize,$zminsize );
			    $xroomsize = int(rand($xmaxsize-$xminsize+1))+$xminsize if $xmazesize > 1;
			    $yroomsize = int(rand($ymaxsize-$yminsize+1))+$yminsize if $ymazesize > 1;
			    $zroomsize = int(rand($zmaxsize-$zminsize+1))+$zminsize if $zmazesize > 1;
			    $yroomsize = $numlevels if $yroomsize > $numlevels;

			    # limit random-sized rooms to single-height in dungeon mode (excluding towers).
			    $yroomsize = 1 if ( $dungeonmode && ! $roomspc_b33 );

			    # adjust the room size to be square if required
			    $xroomsize = $zroomsize if ( $roomspc_b34 );

			    # check if custom room sizing/positioning is required for room class
			    if ( $roomspc_b31 ) {
				# custom room sizing/positioning

				if ( "$specialname" eq "dynriver" ) {
				# underground river placement

					# choose a position to start at
					$yroomcorner = $fromlevel + int(rand($numlevels-$yminsize+1)) if $numlevels > 1;
					$yroomcorner = $fromlevel if $numlevels == 1;
					if ( $roomedgebuffer && ! $roomspc_b43 ) {
						$xroomcorner = int(rand($xmazesize-1))+1 if $xmazesize > 1;
						$zroomcorner = int(rand($zmazesize-1))+1 if $zmazesize > 1;
					} else {
						$xroomcorner = int(rand($xmazesize+1)) if $xmazesize > 1;
						$zroomcorner = int(rand($zmazesize+1)) if $zmazesize > 1;
					};

					# abandon this attempt if starting position has a conflict
					next if ! checkbounds( $xroomcorner, $yroomcorner, $zroomcorner);
					my $cellval = getroomid( $xroomcorner, $yroomcorner, $zroomcorner );
					my $celluse = getcelluse( $xroomcorner, $yroomcorner, $zroomcorner );
					next if ( $cellval != 0 || $celluse != 0 ) ;

					# grab the level class for the room corner
					my $yrclevelclass = getlevelspc( $yroomcorner );
					my $yrclevelalias = getlevelalias( $yrclevelclass );

					# get level attributes
					my ( $valid_b3, $levelspc_b3) = getlevelflag( $yroomcorner, 3 );
					my ( $valid_b4, $levelspc_b4) = getlevelflag( $yroomcorner, 4 );
					my ( $valid_b6, $levelspc_b6) = getlevelflag( $yroomcorner, 6 );
					my ( $valid_b10, $levelspc_b10) = getlevelflag( $yroomcorner, 10 );
					my ( $valid_b11, $levelspc_b11) = getlevelflag( $yroomcorner, 11 );

					# skip this if the level disallows random room placement..
					next if ($levelspc_b3 );
					# ... or multi-height non-access rooms...
					next if ($levelspc_b4 && (! $roomspc_b27 ) && $yroomsize > 1 );
					# ... or any non-access rooms...
					next if ($levelspc_b6 && (! $roomspc_b27 ));
					# ... or requires level/room compatibility.
					next if ($roomspc_b33 && (! $levelspc_b10));
					next if ($levelspc_b10 && (! $roomspc_b33));
					# ... or disallows room bases.
					next if ($levelspc_b11);

					my $end = 0;
					my $start = 0;
					my ( $xpos, $ypos, $zpos ) = ( 0, 0, 0 );
					my ( $xc, $yc, $zc ) = ( $xroomcorner, $yroomcorner, $zroomcorner );
					my $numsegs = 0;
					$roomcoordcount = 0;

					foreach my $ylevel ( $yroomcorner .. ( $ymazesize - 1 )) {

						# look for a placement direction for river segment
						my @dirlist = &randomdirectionlist(1, $xc+$xpos, $yc+$ypos, $zc+$zpos);
						my ( $type, $dir, $XI, $YI, $ZI ) = ( 0, 0, 0, 0, 0 );
						my $xloc = $xc + $xpos;
						my $yloc = $yc + $ypos;
						my $zloc = $zc + $zpos;
						foreach my $checkdir ( @dirlist ) {
							$dir = $checkdir;
							( $XI, $YI, $ZI ) = getmazedirection($checkdir);
							# check if first position is valid
							if ( $ylevel == $yroomcorner ) {
								# check two horizontal positions
								my $ch_valid = checkbounds( $xloc+$XI, $yloc, $zloc+$ZI );
								my $ch_celluse = getcelluse( $xloc+$XI, $yloc, $zloc+$ZI );
								my $ch_roomid = getroomid( $xloc+$XI, $yloc, $zloc+$ZI );
								next if ( !$ch_valid || $ch_celluse || $ch_roomid );
								my $ch2_valid = checkbounds( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
								my $ch2_celluse = getcelluse( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
								my $ch2_roomid = getroomid( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
								next if ( !$ch2_valid || $ch2_celluse || $ch2_roomid );
								# check lower position
								my $chl_valid = checkbounds( $xloc+$XI+$XI, $yloc+1, $zloc+$ZI+$ZI );
								my $chl_celluse = getcelluse( $xloc+$XI+$XI, $yloc+1, $zloc+$ZI+$ZI );
								my $chl_roomid = getroomid( $xloc+$XI+$XI, $yloc+1, $zloc+$ZI+$ZI );
								next if ( !$chl_valid || $chl_celluse || $chl_roomid );
								$type = 1;
								$start = 1;
							} elsif ( $ylevel == ($ymazesize - 1 ) ) {
								# check two horizontal positions
								my $ch_valid = checkbounds( $xloc+$XI, $yloc, $zloc+$ZI );
								my $ch_celluse = getcelluse( $xloc+$XI, $yloc, $zloc+$ZI );
								my $ch_roomid = getroomid( $xloc+$XI, $yloc, $zloc+$ZI );
								next if ( !$ch_valid || $ch_celluse || $ch_roomid );
								my $ch2_valid = checkbounds( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
								my $ch2_celluse = getcelluse( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
								my $ch2_roomid = getroomid( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
								next if ( !$ch2_valid || $ch2_celluse || $ch2_roomid );
								$type = 4;
							} else {
								if ( int(rand(100)) > 20 ) {
									# 80% chance of a single-drop

									# check one horizontal position
									my $ch_valid = checkbounds( $xloc+$XI, $yloc, $zloc+$ZI );
									my $ch_celluse = getcelluse( $xloc+$XI, $yloc, $zloc+$ZI );
									my $ch_roomid = getroomid( $xloc+$XI, $yloc, $zloc+$ZI );
									next if ( !$ch_valid || $ch_celluse || $ch_roomid );
									# check the lower segment
									my $chl_valid = checkbounds( $xloc+$XI, $yloc+1, $zloc+$ZI );
									my $chl_celluse = getcelluse( $xloc+$XI, $yloc+1, $zloc+$ZI );
									my $chl_roomid = getroomid( $xloc+$XI, $yloc+1, $zloc+$ZI );
									next if ( !$chl_valid || $chl_celluse || $chl_roomid );
									$type = 2;
								} else {
									# 20% chance of a double-drop

									# check drop
									my $ch_valid = checkbounds( $xloc, $yloc+1, $zloc );
									my $ch_celluse = getcelluse( $xloc, $yloc+1, $zloc );
									my $ch_roomid = getroomid( $xloc, $yloc+1, $zloc );
									next if ( !$ch_valid || $ch_celluse || $ch_roomid );

									# check second drop
									my $ch2_valid = checkbounds( $xloc+$XI, $yloc+1, $zloc+$ZI );
									my $ch2_celluse = getcelluse( $xloc+$XI, $yloc+1, $zloc+$ZI );
									my $ch2_roomid = getroomid( $xloc+$XI, $yloc+1, $zloc+$ZI );
									$type = 3 if ( $ch2_valid && !$ch2_celluse && !$ch2_roomid );

									# check the lower segment
									my $ch3_valid = checkbounds( $xloc+$XI, $yloc+2, $zloc+$ZI );
									my $ch3_celluse = getcelluse( $xloc+$XI, $yloc+2, $zloc+$ZI );
									my $ch3_roomid = getroomid( $xloc+$XI, $yloc+2, $zloc+$ZI );
									next if ( !$ch3_valid || $ch3_celluse || $ch3_roomid );
								}
							};

							last;
						};

						if ( $type == 0 ) {
						    # we couldn't add a regular segment, try adding an ending segment
						    foreach my $checkdir ( @dirlist ) {
							$dir = $checkdir;
							( $XI, $YI, $ZI ) = getmazedirection($checkdir);
							# check if first position is valid
							my $ch_valid = checkbounds( $xloc+$XI, $yloc, $zloc+$ZI );
							my $ch_celluse = getcelluse( $xloc+$XI, $yloc, $zloc+$ZI );
							my $ch_roomid = getroomid( $xloc+$XI, $yloc, $zloc+$ZI );
							next if ( !$ch_valid || $ch_celluse || $ch_roomid );
							# check if second position is valid
							my $ch2_valid = checkbounds( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
							my $ch2_celluse = getcelluse( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
							my $ch2_roomid = getroomid( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
							next if ( !$ch2_valid || $ch2_celluse || $ch2_roomid);
							$type = 4;
							last;
						    };
						};

						# add the coordinate, segment type, and direction to the list
						$roomcoordcount += 1;
						$roomcoordlist[$roomcoordcount][0] = $type;
						$roomcoordlist[$roomcoordcount][1] = $xloc;
						$roomcoordlist[$roomcoordcount][2] = $yloc;
						$roomcoordlist[$roomcoordcount][3] = $zloc;
						$roomcoordlist[$roomcoordcount][4] = $dir;
						$roomcoordlist[$roomcoordcount][5] = $xpos;
						$roomcoordlist[$roomcoordcount][6] = $ypos;
						$roomcoordlist[$roomcoordcount][7] = $zpos;
						$roomcoordlist[$roomcoordcount][8] = 0 if ( ! $roomcoordlist[$roomcoordcount][8] );
						$roomcoordlist[$roomcoordcount][9] = 0 if ( ! $roomcoordlist[$roomcoordcount][9] );
						$roomcoordlist[$roomcoordcount][10] = 0 if ( ! $roomcoordlist[$roomcoordcount][10] );

						if ( $type ) {
							# increment the coordinates depending on the segment type
							if ( $type == 1 ) {
								$xpos += ( $XI * 2 );
								$ypos += 1;
								$zpos += ( $ZI * 2 );
								$numsegs += 1;
							} elsif ( $type == 2 ) {
								$xpos += $XI;
								$ypos += 1;
								$zpos += $ZI;
								$numsegs += 1;
							} elsif ( $type == 3 ) {
								$xpos += $XI;
								$ypos += 2;
								$zpos += $ZI;
								$numsegs += 2;
							} elsif ( $type == 4 ) {
								$xpos += ( $XI * 2 );
								$zpos += ( $ZI * 2 );
								$end = 1;
								$numsegs += 1;
							};
							$xloc = $xc + $xpos;
							$yloc = $yc + $ypos;
							$zloc = $zc + $zpos;

							$roomcoordlist[$roomcoordcount][8] = $xpos;
							$roomcoordlist[$roomcoordcount][9] = $ypos;
							$roomcoordlist[$roomcoordcount][10] = $zpos;
						}

						last if $end;
					}
					# abort this attempt if we didn't meet the minimum length or could not start or end it
					next if ( ( $numsegs < $yminsize ) || ! $end || ! $start );

					$success = 1;

					my ($lx, $ly, $lz, $ux, $uy, $uz ) = ( 0, 0, 0, 0, 0, 0 );

					foreach my $ent ( 1 .. $roomcoordcount ) {
						$lx = $roomcoordlist[$ent][5] if $roomcoordlist[$ent][5] < $lx;
						$ly = $roomcoordlist[$ent][6] if $roomcoordlist[$ent][6] < $ly;
						$lz = $roomcoordlist[$ent][7] if $roomcoordlist[$ent][7] < $lz;
						$lx = $roomcoordlist[$ent][8] if $roomcoordlist[$ent][8] < $lx;
						$ly = $roomcoordlist[$ent][9] if $roomcoordlist[$ent][9] < $ly;
						$lz = $roomcoordlist[$ent][10] if $roomcoordlist[$ent][10] < $lz;

						$ux = $roomcoordlist[$ent][5] if $roomcoordlist[$ent][5] > $ux;
						$uy = $roomcoordlist[$ent][6] if $roomcoordlist[$ent][6] > $uy;
						$uz = $roomcoordlist[$ent][7] if $roomcoordlist[$ent][7] > $uz;
						$ux = $roomcoordlist[$ent][8] if $roomcoordlist[$ent][8] > $ux;
						$uy = $roomcoordlist[$ent][9] if $roomcoordlist[$ent][9] > $uy;
						$uz = $roomcoordlist[$ent][10] if $roomcoordlist[$ent][10] > $uz;
					};
					$xroomcorner = $xc + $lx;
					$yroomcorner = $yc + $ly;
					$zroomcorner = $zc + $lz;
					$xroomsize = 0 - $lx + 1 + $ux;
					$yroomsize = 0 - $ly + 1 + $uy;
					$zroomsize = 0 - $lz + 1 + $uz;
				};
			    } else {
				# regular room sizing/positioning

				# choose room location based on room class and room size
				$yroomcorner = $fromlevel + int(rand($numlevels-$yroomsize+1)) if $numlevels > 1;
				$yroomcorner = $fromlevel if $numlevels == 1;

				# align room floor with bottom level if room special flag bit 14 is set.
				$yroomcorner = ($tolevel-$yroomsize+1) if ( $roomspc_b14 && ! $invertlevels);
				$yroomcorner = $fromlevel if ( $roomspc_b14 && $invertlevels);

				# use non-random round-robin Y placement if room special flag bit 16 is set.
				$yroomcorner = (($roomtype + $roominc) % ($numlevels-$yroomsize+1)) if ( $roomspc_b16 );

				# grab the level class for the room corner
				my $yrclevelclass = getlevelspc( $yroomcorner );
				my $yrclevelalias = getlevelalias( $yrclevelclass );

				# 50/50 chance of swapping X/Z if room special flag bit 2 is set.
				( $xroomsize, $zroomsize ) = ( $zroomsize, $xroomsize ) if (int(rand(2)) && $roomspc_b2 );

				# adjust X/Z corners based on roomedgebuffer option setting.
				if ( $roomedgebuffer && ! $roomspc_b43 ) {
					$xroomcorner = int(rand($xmazesize-$xroomsize-1))+1 if $xmazesize > 1;
					$zroomcorner = int(rand($zmazesize-$zroomsize-1))+1 if $zmazesize > 1;
				} else {
					$xroomcorner = int(rand($xmazesize-$xroomsize+1)) if $xmazesize > 1;
					$zroomcorner = int(rand($zmazesize-$zroomsize+1)) if $zmazesize > 1;
				};

				my $overlap = 0;
				# determine the far corner
				$xfcorner=( $xroomcorner+$xroomsize-1 );
				$yfcorner=( $yroomcorner+$yroomsize-1 );
				$zfcorner=( $zroomcorner+$zroomsize-1 );

				# adjust the checking ranges based on the adjacentroomflag option setting.
				my ( $xrangestart, $xrangeend, $zrangestart, $zrangeend ) =
					( $xroomcorner-1, $xfcorner+1, $zroomcorner-1, $zfcorner+1);
				( $xrangestart, $xrangeend, $zrangestart, $zrangeend ) =
					( $xroomcorner, $xfcorner, $zroomcorner, $zfcorner) if $adjacentroomflag;
		
				# check to see if room overlaps another room
				foreach my $yinc ($yroomcorner .. $yfcorner) {
          	  			foreach my $xinc ($xrangestart..$xrangeend) {
            		    			foreach my $zinc ($zrangestart..$zrangeend) {
							next if ! checkbounds( $xinc, $yinc, $zinc);
							my $cellval = getroomid( $xinc, $yinc, $zinc );
							my $celluse = getcelluse( $xinc, $yinc, $zinc );
							$overlap = 1 if ( $cellval != 0 || $celluse != 0 ) ;
			    			};
					};

					# get level attributes
					my ( $valid_b3, $levelspc_b3) = getlevelflag( $yinc, 3 );
					my ( $valid_b4, $levelspc_b4) = getlevelflag( $yinc, 4 );
					my ( $valid_b6, $levelspc_b6) = getlevelflag( $yinc, 6 );
					my ( $valid_b10, $levelspc_b10) = getlevelflag( $yinc, 10 );
					my ( $valid_b11, $levelspc_b11) = getlevelflag( $yinc, 11 );
					my $ylevelclass = getlevelspc( $yinc );
					my $ylevelalias = getlevelalias( $ylevelclass );

					# simulate an overlap if the level disallows random room placement..
					$overlap = 1 if ($levelspc_b3 );
					# ... or multi-height non-access rooms...
					$overlap = 2 if ($levelspc_b4 && (! $roomspc_b27 ) && $yroomsize > 1 );
					# ... or any non-access rooms...
					$overlap = 3 if ($levelspc_b6 && (! $roomspc_b27 ));
					# ... or if room would cross between incompatible level types...
					$overlap = 4 if (($ylevelclass != $yrclevelclass) && ($ylevelclass != $yrclevelalias) &&
							 ($ylevelalias != $yrclevelclass) && ($ylevelalias != $yrclevelalias));
					# ... or requires level/room compatibility...
					$overlap = 5 if ($roomspc_b33 && (! $levelspc_b10));
					$overlap = 6 if ($levelspc_b10 && (! $roomspc_b33));
					# ... or disallows room bases.
					$overlap = 7 if ($levelspc_b11 && ( $yinc == $yfcorner ));
        	  		};

				# make sure room is within maze area
				my $valid = 0;
				$valid = checkbounds( $xroomcorner, $yroomcorner, $zroomcorner );
				next if $valid == 0;
				$valid = checkbounds( $xfcorner, $yfcorner, $zfcorner );
				next if $valid == 0;

				# try again if room overlaps another
				next if $overlap != 0;

				# reject room if it will conflict with any noroom-flagged cells.
				my $nrbconflict =
					setroomidgrid( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, 0, $roomtype );
				next if $nrbconflict;
		
				# we found a good location for the room
				$success = 1;

				# see if we can slide the room into a corner to make more space for more rooms
				if ( $denseroompacking || $roomspc_b42 ) {
				    my ($xmoveinc, $zmoveinc) = (-1, -1);
				    if ( $choosecorner ) {

					# choose the nearest corner if choosecorner option is set
					my $right = $xmazesize - $xfcorner - 1;
					my $bottom = $zmazesize - $zfcorner - 1;

					$xmoveinc = 1 if $right < $xroomcorner;
					$zmoveinc = 1 if $bottom < $zroomcorner;

					# if we have an equal distance between two sides, pick that direction randomly
					$xmoveinc = 1 if (($right = $xroomcorner) && int(rand(2)));
					$zmoveinc = 1 if (($bottom = $zroomcorner) && int(rand(2)));
				    } else {
					# pick a random diagonal direction if choosecorner is not set
					my $movedir=int(rand(4));
					($xmoveinc, $zmoveinc) = (-1, -1);
					($xmoveinc, $zmoveinc) = ( -1, 1) if $movedir == 1;
					($xmoveinc, $zmoveinc) = ( 1, -1) if $movedir == 2;
					($xmoveinc, $zmoveinc) = ( 1, 1) if $movedir == 3;
				    };

					my $nomoves = 0;
					my ($xmovement, $zmovement) = ( 0,0);

					do {
						$nomoves = 1;
						my ( $xrange, $zrange) = ($xrangestart - 1, $zrangestart - 1);
						$xrange = ($xrangeend + 1) if $xmoveinc > 0;
						$zrange = ($zrangeend + 1) if $zmoveinc > 0;

						my $xmove = 1;
						foreach my $zinc ( $zrangestart..$zrangeend ) {
						    foreach my $yinc ( $yroomcorner .. $yfcorner) {
							if ( ! checkbounds( $xrange, $yinc, $zinc)) {
								$xmove = 0;
								last;
							};
							my $cellval = getroomid( $xrange, $yinc, $zinc );
							my $celluse = getcelluse( $xrange, $yinc, $zinc );
							my $cellnrb = getnrflag( $xrange, $yinc, $zinc );
							$xmove = 0 if ( $cellval != 0 || $celluse != 0 || $cellnrb != 0 ) ;
						    }
						}
						if ( $xmove ) {
							$xrangestart += $xmoveinc;
							$xrangeend += $xmoveinc;
							$xmovement += $xmoveinc;
							$nomoves = 0;
						};

						my $zmove = 1;
						foreach my $xinc ( $xrangestart..$xrangeend ) {
						    foreach my $yinc ( $yroomcorner .. $yfcorner) {
							if ( ! checkbounds( $xinc, $yinc, $zrange)) {
								$zmove = 0;
								last;
							};
							my $cellval = getroomid( $xinc, $yinc, $zrange );
							my $celluse = getcelluse( $xinc, $yinc, $zrange );
							my $cellnrb = getnrflag( $xinc, $yinc, $zrange );
							$zmove = 0 if ( $cellval != 0 || $celluse != 0 || $cellnrb != 0 ) ;
						    }
						}
						if ( $zmove ) {
							$zrangestart += $zmoveinc;
							$zrangeend += $zmoveinc;
							$zmovement += $zmoveinc;
							$nomoves = 0;
						};
					} while ( $nomoves == 0 );
					print "denseroompacking movement possible $xmovement $zmovement\n" if $debug2;

					$xroomcorner += $xmovement;
					$zroomcorner += $zmovement;
				};
			    };
		
			    # add a room entry to the room list
			    my $addedroom = addrooment( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, $spcsel );
		
			    # build room into the binary array
			    buildroom( $addedroom, $spcsel ) if ( $addedroom );
		
			    last;
	    		}
			# abandon adding any more rooms of this room type if we have failed to add a room
			# we ignore this if the room type has special bit 17 set.
	    		last if ($success == 0 && ! $roomspc_b17);

			# abandon adding rooms if we have maxxed out the roomid bit field.
	    		last if $totalrooms == ( $roomidmask >> $roomidshft );
		}
	}
};

#------------------------------------------------------------------------------
# addrooment - add an entry to the room array

sub addrooment {
	my ($X, $Y, $Z, $XS, $YS, $ZS, $roomspc) = @_;

	# abort adding the room if the roomid bit field is maxxed out.
	return 0 if $totalrooms == ( $roomidmask >> $roomidshft );

	$totalrooms += 1;
	my $room = $totalrooms;

	print "addrooment room $room at $X $Y $Z size $XS $YS $ZS rspc $roomspc\n" if $debug2;

	# 0/1/2=room corner coord, 3/4/5=room size, 6/7/8=room entrance coord,
	# 9=room init flag, 10=door count, 11=room class, 12=previous primary door,
	# 13=room style, 14=room attribute bits 0-31, 15=room attribute bits 32-63,
	# 16=room name, 17=interior class

	$roominfo[$room][0]=$X;
	$roominfo[$room][1]=$Y;
	$roominfo[$room][2]=$Z;
	$roominfo[$room][3]=$XS;
	$roominfo[$room][4]=$YS;
	$roominfo[$room][5]=$ZS;
	$roominfo[$room][6]=0;
	$roominfo[$room][7]=0;
	$roominfo[$room][8]=0;
	$roominfo[$room][9]=0;
	$roominfo[$room][10]=0;
	$roominfo[$room][11]=$roomspc;
	$roominfo[$room][12]=0;
	$roominfo[$room][13]='';
	$roominfo[$room][14]=0x00000000;
	$roominfo[$room][15]=0x00000000;
	$roominfo[$room][16]=$roomclass[$roomspc][0];
	$roominfo[$room][17]=0;

	# override level name if we are using a level-wide room type
	my ( $valid_b23, $roomspc_b23) = getroomspcflag( $roomspc, 23 );
	my ( $valid_b26, $roomspc_b26) = getroomspcflag( $roomspc, 26 );

	my $level = ($Y + $YS - 1);
	$level -= 1 if ($roomspc_b23 || $roomspc_b26);

	# set bits for long/short horizontal dimensions and vertical dimensions.
	my ( $ldim, $sdim ) = ( $XS, $ZS );
	( $ldim, $sdim ) = ( $sdim, $ldim ) if ( $ldim < $sdim );
	setroomattrib( $room, 0 ) if ( $sdim == 1 );
	setroomattrib( $room, 1 ) if ( $sdim == 2 );
	setroomattrib( $room, 2 ) if ( $sdim == 3 );
	setroomattrib( $room, 3 ) if ( $sdim > 3 );
	setroomattrib( $room, 4 ) if ( $ldim == 1 );
	setroomattrib( $room, 5 ) if ( $ldim == 2 );
	setroomattrib( $room, 6 ) if ( $ldim == 3 );
	setroomattrib( $room, 7 ) if ( $ldim > 3 );
	setroomattrib( $room, 8 ) if ( $YS == 1 );
	setroomattrib( $room, 9 ) if ( $YS == 2 );
	setroomattrib( $room, 10 ) if ( $YS == 3 );
	setroomattrib( $room, 11 ) if ( $YS > 3 );

	print "addrooment added room $room\n" if $debug3;

	return( $room );
};

#------------------------------------------------------------------------------
# setroomchars - set room characteristics

sub setroomchars {
	my ($room, $style) = @_;

	# make sure we are working with a valid room
	return 0 if ! $roominfo[$room][4];

	$style = "0" if ! $style;

	print "setroomchars room $room style $style\n" if $debug2;

	$roominfo[$room][13]=$style;

	return( 1 );
}

#------------------------------------------------------------------------------
# getroomvars - get style variants for a room class

sub getroomvars {
	my ($roomspc) = @_;

	# make sure we are working with a valid room class
	return 0 if ! $roomclass[$roomspc][0];

	my $roomstyle=$roomclass[$roomspc][19];
	$roomstyle = 0 if ! $roomstyle;
	my @style = split(',', $roomstyle );

	print "getroomvars roomspc $roomspc style &style\n" if $debug2;

	return @style;
}

#------------------------------------------------------------------------------
# getroomchars - get room characteristics

sub getroomchars {
	my ($room) = @_;

	# make sure we are working with a valid room
	return 0 if ! $roominfo[$room][4];

	my $roomstyle=$roominfo[$room][13];
	$roomstyle = 0 if ! $roomstyle;
	my @style = split(',', $roomstyle );

	print "getroomchars room $room style &style\n" if $debug2;

	return @style;
}
#------------------------------------------------------------------------------
# buildroom - build room in array

sub buildroom {
	my ( $room, $roomspc ) = @_;

	# abort building room if we have an invalid room number
	return 0 if ! $room;

	my ( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize ) =
		getroompos( $room );

	print "buildroom room $room roomspc $roomspc\n" if $debug2;

	# mark cells with room ID
	setroomidgrid( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, $room, $roomspc );

	my ( $room_fill, $room_cctr, $room_cnrs, $room_sctr ) = getdoorfillflag( $roomspc );
	my ( $thru_fill, $thru_cctr, $thru_cnrs, $thru_sctr ) = getthrufillflag( $roomspc );

	# swap top/bottom fill patterns if invertlevels is enabled.
	$room_fill = 2 if ( $invertlevels && $room_fill == 1 );
	$room_fill = 1 if ( $invertlevels && $room_fill == 2 );
	$room_fill = 6 if ( $invertlevels && $room_fill == 7 );
	$room_fill = 7 if ( $invertlevels && $room_fill == 6 );
	$thru_fill = 2 if ( $invertlevels && $thru_fill == 1 );
	$thru_fill = 1 if ( $invertlevels && $thru_fill == 2 );
	$thru_fill = 6 if ( $invertlevels && $thru_fill == 7 );
	$thru_fill = 7 if ( $invertlevels && $thru_fill == 6 );

	my $xfcorner=( $xroomcorner+$xroomsize-1 );
	my $yfcorner=( $yroomcorner+$yroomsize-1 );
	my $zfcorner=( $zroomcorner+$zroomsize-1 );

	# place door flags and clear use flags for possible door openings
	foreach my $yinc ($yroomcorner .. $yfcorner) {

	# skip standard door fills if custom fill type if specified
	last if ( $room_fill == 15 );

		foreach my $xinc ($xroomcorner .. $xfcorner) {
		    foreach my $zinc ($zroomcorner .. $zfcorner) {
			my $cellroomid = getroomid( $xinc, $yinc, $zinc );
			next if $cellroomid != $room;

			# bottom fill only fill type
			next if ( $room_fill == 1 && $yinc != $yfcorner );

			# top fill only fill type
			next if ( $room_fill == 2 && $yinc != $yroomcorner );

			# bottom/top fill only fill type
			next if ( $room_fill == 3 && $yinc != $yroomcorner && $yinc != $yfcorner );

			# no-fill fill type
			next if ( $room_fill == 4 );

			# corner fill only fill type
			next if ( $room_fill == 5 && ( $xinc != $xroomcorner && $xinc != $xfcorner ) &&
				( $zinc != $zroomcorner && $zinc != $zfcorner ));

			# no bottom fill type
			next if ( $room_fill == 6 && $yinc == $yfcorner );

			# no top fill type
			next if ( $room_fill == 7 && $yinc == $yroomcorner );

			# clear the cell use mask and set the door flags
			setdoorflag( $xinc, $yinc, $zinc, 1);
		    }
		}
	}

	# place thru flags and clear use flags for possible passthru openings
	foreach my $yinc ($yroomcorner .. $yfcorner) {

		# skip room modifications if passthrus are not enabled
		last if ( ! $passthrus );

		# skip standard thru fills if custom fill type if specified
		last if ( $thru_fill == 15 );

		foreach my $xinc ($xroomcorner .. $xfcorner) {
		    foreach my $zinc ($zroomcorner .. $zfcorner) {
			my $cellroomid = getroomid( $xinc, $yinc, $zinc );
			next if $cellroomid != $room;

			# bottom fill only fill type
			next if ( $thru_fill == 1 && $yinc != $yfcorner );

			# top fill only fill type
			next if ( $thru_fill == 2 && $yinc != $yroomcorner );

			# bottom/top fill only fill type
			next if ( $thru_fill == 3 && $yinc != $yroomcorner && $yinc != $yfcorner );

			# no-fill fill type
			next if ( $thru_fill == 4 );

			# corner fill only fill type
			next if ( $thru_fill == 5 && ( $xinc != $xroomcorner && $xinc != $xfcorner ) &&
				( $zinc != $zroomcorner && $zinc != $zfcorner ));

			# no bottom fill type
			next if ( $thru_fill == 6 && $yinc == $yfcorner );

			# no top fill type
			next if ( $thru_fill == 7 && $yinc == $yroomcorner );

			# set the passthru flag.
			setthruflag( $xinc, $yinc, $zinc, 1);
		    }
		}
	}

	my ( $valid_b12, $roomspc_b12) = getroomspcflag( $roomspc, 12 );
	my ( $valid_b11, $roomspc_b11) = getroomspcflag( $roomspc, 11 );

	my $oddshape = 0;

	# open paths between room cells
	foreach my $YI ( 0..($yroomsize-1)) {
	    foreach my $ZI ( 0..($zroomsize-1)) {
		foreach my $XI ( 0..($xroomsize-1)) {

			my $xcoord = ( $xroomcorner + $XI );
			my $ycoord = ( $yroomcorner + $YI );
			my $zcoord = ( $zroomcorner + $ZI );

			# skip this location if it does not belong to this room
			my $roomid = getroomid( $xcoord, $ycoord, $zcoord );
			if ( $roomid != $room ) {
				$oddshape = 1;
				next;
			};

			# clear out all walls for this room cell if it isn't a dungeon room
			clearallpaths( $xcoord, $ycoord, $zcoord ) if ( ! $roomspc_b12 && ! $roomspc_b11 );

			# add walls back based on room cell adjacency
			my $path = 0;
			foreach my $dir ( 1..6 ) {
				my ($xdir, $ydir, $zdir) = getmazedirection( $dir );
				my $xcheck = $xcoord + $xdir;
				my $ycheck = $ycoord + $ydir;
				my $zcheck = $zcoord + $zdir;

				my $roomid = 0;

				# get adjacent room id, if the cell is within the array
				my $valid = checkbounds( $xcheck, $ycheck, $zcheck );
				$roomid = getroomid( $xcheck, $ycheck, $zcheck ) if $valid;

				if ( $roomid != $room ) {
					# set the wall flag if the adjacent cell does not belong to this room
					setpath($xcoord, $ycoord, $zcoord, $dir);
					my $pathval = getpathflags( $xcoord, $ycoord, $zcoord );
				};

				# set room attribute bits if room has multiple ceiling or floor levels
				setroomattrib( $room, 12 ) if ( $dir == 6 && $roomid != $room && $YI != ($yroomsize-1) );
				setroomattrib( $room, 13 ) if ( $dir == 5 && $roomid != $room && $YI != 0 );
			}

			# set new wall configuration and wall reference for cell
			my $pathval = getpathflags( $xcoord, $ycoord, $zcoord );
			setsegment( $xcoord, $ycoord, $zcoord, $pathval );

			# build cell adjacency value for room cells
			my $ADJ = 0;
			foreach my $YD ( -1, 0, 1 ) {
			    foreach my $XD ( -1, 0, 1 ) {
				foreach my $ZD ( -1, 0, 1 ) {
					my $adjroomid = getroomid( $xcoord+$XD, $ycoord+$YD, $zcoord+$ZD );
					my $adjval = 0;
					if ( $roomid == $adjroomid ) {
						$ADJ = (($ADJ<<1)|1);
					} else {
						$ADJ = ($ADJ<<1);
					}
				}
			    }
			}
			my $adjoldval = ( $adjmazegrid[$xcoord][$ycoord][$zcoord] );
			$adjoldval = 0 if ! $adjoldval;
			my $adjval = (((($adjoldval >> $adjshft ) & $adjmask) ^ $adjmask ) & $ADJ);

			$adjmazegrid[$xcoord][$ycoord][$zcoord] = (( $adjval & $adjmask ) << $adjshft );
		    }
		}
	}

	# set the appropriate room attribute if we determine room is a non-standard shape
	setroomattrib( $room, 31 ) if ( $oddshape );

	# clear the door flags for the room center
	foreach my $yinc ($yroomcorner .. $yfcorner) {
		if ( $xroomsize > 1 && $zroomsize > 1 ) {
			foreach my $xinc ($xroomcorner+1 .. $xfcorner-1) {
				foreach my $zinc ($zroomcorner+1 .. $zfcorner-1) {
					next if ( $room_cctr );
					next if $room != getroomid( $xinc, $yinc, $zinc);
					cleardoorflag( $xinc, $yinc, $zinc, 1 );
				}
			}
		} elsif ( $xroomsize > 1 ) {
			foreach my $xinc ($xroomcorner+1 .. $xfcorner-1) {
				next if ( $room_cctr );
				next if $room != getroomid( $xinc, $yinc, $zroomcorner);
				cleardoorflag( $xinc, $yinc, $zroomcorner, 1 );
			}
		} else {
			foreach my $zinc ($zroomcorner+1 .. $zfcorner-1) {
				next if ( $room_cctr );
				next if $room != getroomid( $xroomcorner, $yinc, $zinc);
				cleardoorflag( $xroomcorner, $yinc, $zinc, 1 );
			}
		}

		# clear the door flags for the room corners if corner exits are not allowed.
		if (! $room_cnrs) {
			cleardoorflag( $xroomcorner, $yinc, $zroomcorner, 1 );
			cleardoorflag( $xfcorner, $yinc, $zroomcorner, 1 );
			cleardoorflag( $xroomcorner, $yinc, $zfcorner, 1 );
			cleardoorflag( $xfcorner, $yinc, $zfcorner, 1 );
		};
	};

	# clear the thru flags for the room center
	foreach my $yinc ($yroomcorner .. $yfcorner) {

		# skip room modifications if passthrus are not enabled
		last if ( ! $passthrus );

		if ( $xroomsize > 1 && $zroomsize > 1 ) {
			foreach my $xinc ($xroomcorner+1 .. $xfcorner-1) {
				foreach my $zinc ($zroomcorner+1 .. $zfcorner-1) {
					next if ( $thru_cctr );
					next if $room != getroomid( $xinc, $yinc, $zinc);
					clearthruflag( $xinc, $yinc, $zinc, 1 );
				}
			}
		} elsif ( $xroomsize > 1 ) {
			foreach my $xinc ($xroomcorner+1 .. $xfcorner-1) {
				next if ( $thru_cctr );
				next if $room != getroomid( $xinc, $yinc, $zroomcorner);
				clearthruflag( $xinc, $yinc, $zroomcorner, 1 );
			}
		} else {
			foreach my $zinc ($zroomcorner+1 .. $zfcorner-1) {
				next if ( $thru_cctr );
				next if $room != getroomid( $xroomcorner, $yinc, $zinc);
				clearthruflag( $xroomcorner, $yinc, $zinc, 1 );
			}
		}

		# clear the thru flags for the room corners if corner exits are not allowed.
		if (! $thru_cnrs) {
			clearthruflag( $xroomcorner, $yinc, $zroomcorner, 1 );
			clearthruflag( $xfcorner, $yinc, $zroomcorner, 1 );
			clearthruflag( $xroomcorner, $yinc, $zfcorner, 1 );
			clearthruflag( $xfcorner, $yinc, $zfcorner, 1 );
		};
	};

	spcroomfill( $room, $roomspc );
};

#------------------------------------------------------------------------------
# setroomidgrid - set roomids on cells determined by room class settings

sub setroomidgrid {
	my ( $xc, $yc, $zc, $xs, $ys, $zs, $room, $roomspc ) = @_;

	my ( $valid_b8, $roomspc_b8) = getroomspcflag( $roomspc, 8 );
	my ( $valid_b23, $roomspc_b23) = getroomspcflag( $roomspc, 23 );
	my ( $valid_b26, $roomspc_b26) = getroomspcflag( $roomspc, 26 );
	my ( $valid_b31, $roomspc_b31) = getroomspcflag( $roomspc, 31 );
	my ( $room_fill, $room_cctr, $room_cnrs, $room_sctr ) = getdoorfillflag( $roomspc );

	my $specialname = $roomclass[$roomspc][17];

	# swap top/bottom fill patterns if invertlevels is enabled.
	$room_fill = 2 if ( $invertlevels && $room_fill == 1 );
	$room_fill = 1 if ( $invertlevels && $room_fill == 2 );

	my $xfc=( $xc+$xs-1 );
	my $yfc=( $yc+$ys-1 );
	my $zfc=( $zc+$zs-1 );

	# clear the noroom bit conflict flag
	my $nrbconflict = 0;

	# designate room cell ownership
	if ( $roomspc_b31 ) {
		# room requires custom sizing/positioning

		if ( "$specialname" eq "dynriver" ) {
			foreach my $ent ( 1 .. $roomcoordcount ) {
				my $type = $roomcoordlist[$ent][0];
				my $xloc = $roomcoordlist[$ent][1];
				my $yloc = $roomcoordlist[$ent][2];
				my $zloc = $roomcoordlist[$ent][3];
				my $dir = $roomcoordlist[$ent][4];
				my ( $XI, $YI, $ZI ) = getmazedirection($dir);

				# combine segment type and direction into a cellspc value to use
				my $cellmarker = 16 + ((( $type - 1 ) << 2 ) + ( $dir - 1 ));

				setroomid( $xloc, $yloc, $zloc, $room );
				setcellspc( $xloc, $yloc, $zloc, $cellmarker );

				if ( $type == 1 ) {
					setroomid( $xloc+$XI, $yloc, $zloc+$ZI, $room );
					setroomid( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI, $room );

					# set the upper door flag
					setdoorflag( $xloc, $yloc, $zloc );

				} elsif ( $type == 2 ) {
					setroomid( $xloc+$XI, $yloc, $zloc+$ZI, $room );
				} elsif ( $type == 3 ) {
					setroomid( $xloc, $yloc+1, $zloc, $room );
					setroomid( $xloc+$XI, $yloc+1, $zloc+$ZI, $room );
				} elsif ( $type == 4 ) {
					setroomid( $xloc+$XI, $yloc, $zloc+$ZI, $room );
					setroomid( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI, $room );

					# set the lower door flag
					setdoorflag( $xloc+$XI+$XI, $yloc, $zloc+$ZI+$ZI );
				};
			};

			foreach my $yinc ($yc .. $yfc) {
			    foreach my $xinc ($xc .. $xfc) {
				foreach my $zinc ($zc .. $zfc) {
				    my $ch_roomid = getroomid( $xinc, $yinc, $zinc );
				    next if ( $ch_roomid != $room );

				    if ($room) {
					my $nrbit = getnrflag( $xinc, $yinc, $zinc );
					$nrbconflict = 1 if ( $nrbit );

					# check if we need to convert any pit traps in the way
					my $cspc = getcellspc( $xinc, $yinc, $zinc );
					settrap( $xinc, $yinc-1, $zinc, 1, 0) if ( $cspc == 11 && ! $invertlevels);
					settrap( $xinc, $yinc+1, $zinc, 1, 0) if ( $cspc == 11 && $invertlevels);

					# clear any hall special flags if they are not for custom room use
					setcellspc( $xinc, $yinc, $zinc, 0) if ( $cspc < 16 || $cspc > 31 );

					my $door = getdoorflag( $xinc, $yinc, $zinc );
					if ( ! $door ) {
						# set the use flag of the cell if the door flag is not set
						setuseflag( $xinc, $yinc, $zinc);
					};
				    };
				};
			    };
			};
		};
	} else {
	    # room uses standard sizing/positioning
	    foreach my $yinc ($yc .. $yfc) {
		foreach my $xinc ($xc .. $xfc) {
		    foreach my $zinc ($zc .. $zfc) {

			# only select corners of top level if room bit 8 flag enabled for room type
			next if ( $roomspc_b8 && $yinc == $yc && (( $xinc != $xc && $xinc != $xfc )
				|| ( $zinc != $zc && $zinc != $zfc )));

			# select specific corners of top/bottom level if room bit 26 is enabled for the room type
			if ( $roomspc_b26 ) {
				# NE/SW corners on top
				next if ($yinc == $yfc && (($xinc != $xfc && $zinc != $zc) ||
					($xinc != $xc && $zinc != $zfc )));
				# NW/SE corners on bottom
				next if ($yinc == $yc && (($xinc != $xc && $zinc != $zc) ||
					($xinc != $xfc && $zinc != $zfc )));
			};

			# only select corners of bottom level if room bit 23 flag enabled for room type
			next if ( $roomspc_b23 && $yinc == $yfc && (( $xinc != $xc && $xinc != $xfc )
				|| ( $zinc != $zc && $zinc != $zfc )));

			# set the conflict flag if we have a noroom bit set on a cell we want to use
			my $nrbit = getnrflag( $xinc, $yinc, $zinc );
			$nrbconflict = 1 if ( $nrbit );

			if ($room) {
				# check if we need to convert any pit traps in the way
				my $cspc = getcellspc( $xinc, $yinc, $zinc );
				settrap( $xinc, $yinc-1, $zinc, 1, 0) if ( $cspc == 11 && ! $invertlevels);
				settrap( $xinc, $yinc+1, $zinc, 1, 0) if ( $cspc == 11 && $invertlevels);

				# clear any hall special flags
				setcellspc( $xinc, $yinc, $zinc, 0);
				
				# set the roomid of the cell
				setroomid( $xinc, $yinc, $zinc, $room );
				setuseflag( $xinc, $yinc, $zinc);
			};
		    }
		};
	    }
	};
	return( $nrbconflict );
};

#------------------------------------------------------------------------------
# placenoroomblock - set an area with noroom flags

sub placenoroomblock {
	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = @_;
	my $xfc=( $xc+$xs-1 );
	my $yfc=( $yc+$ys-1 );
	my $zfc=( $zc+$zs-1 );

	foreach my $yinc ($yc .. $yfc) {
		foreach my $xinc ($xc .. $xfc) {
		    foreach my $zinc ($zc .. $zfc) {
			setnrflag( $xinc, $yinc, $zinc );
		    }
		}
	}
};

#------------------------------------------------------------------------------
# setroomattrib - set room attributes

sub setroomattrib {
	my ( $room, $bit ) = @_;

	# attributes 0-31	0x00000001	bit  0:	short dimension = 1
	# 			0x00000002	bit  1:	short dimension = 2
	# 			0x00000004	bit  2:	short dimension = 3
	# 			0x00000008	bit  3:	short dimension > 3
	# 			0x00000010	bit  4:	long dimension = 1
	# 			0x00000020	bit  5:	long dimension = 2
	# 			0x00000040	bit  6:	long dimension = 3
	# 			0x00000080	bit  7:	long dimension > 3
	# 			0x00000100	bit  8:	vertical height = 1
	# 			0x00000200	bit  9:	vertical height = 2
	# 			0x00000400	bit 10:	vertical height = 3
	# 			0x00000800	bit 11:	vertical height > 3
	#			0x00001000	bit 12: room has multi-level floors
	#			0x00002000	bit 13: room has multi-level ceilings
	#			0x00004000	bit 14: room has floor effects
	#			0x00008000	bit 15: room has ceiling effects
	#			0x00010000	bit 16: room has ground-level access
	#			0x00020000	bit 17: room has upper-level access
	#			0x00040000	bit 18: room has vertical access
	#			0x00080000	bit 19: room has room-to-room access
	#			0x00100000	bit 20: room contains ground-level passthrus
	#			0x00200000	bit 21:	room contains elevated passthrus
	#			0x00400000	bit 22: 
	#			0x00800000	bit 23: 
	#			0x01000000	bit 24: room connected to finished hallways
	#			0x02000000	bit 25: room connected to utility hallways
	#			0x04000000	bit 26: room connected to unfinished hallways
	#			0x08000000	bit 27: room connected to railway
	#			0x10000000	bit 28: 
	#			0x20000000	bit 29: 
	#			0x40000000	bit 30: 
	#			0x80000000	bit 31: room has an irregular shape
	#
	# attributes 32-63	0x00000001	bit 32: room has floor-level door access
	#			0x00000002	bit 33: room has floor-level arch access
	#			0x00000004	bit 34: room has floor-level entryway access
	#			0x00000008	bit 35: room has floor-level other access
	# 			0x00000010	bit 36: room has elevated door access
	#			0x00000020	bit 37: room has elevated arch access
	#			0x00000040	bit 38: room has elevated entryway access
	#			0x00000080	bit 39: room has elevated other access
	#			0x00000100	bit 40: room contains intrusive ground-level door/arch/entryway extensions
	#			0x00000200	bit 41: room contains intrusive elevated door/arch/entryway extensions
	#			0x00000400	bit 42: room contains non-intrusive ground-level door/arch/entryway extensions
	#			0x00000800	bit 43: room contains non-intrusive elevated door/arch/entryway extensions
	#

	my $range = 0;

	if ( $bit >= 0 && $bit <= 31 ) {
		$range = 14;
	} elsif ( $bit >= 32 && $bit <= 63 ) {
		$range = 15;
		$bit -= 32;
	} else {
		print "setroomattrib: invalid bit $bit specified." if ( $debug3 );
		return( 0 );
	};

	# set the specific bit value
	my $old = $roominfo[$room][$range];
	$old = 0 if ( ! $old );
	$roominfo[$room][$range] = ( $roominfo[$room][$range] | ( 1 << $bit ) );

	printf( "setroomattrib: Added bit $range/$bit to room $room, %08x -> %08x\n", $old, $roominfo[$room][$range] ) if ( $debug3 );

	return( 1 );
};

#------------------------------------------------------------------------------
# addsparsehuts - sparsely fill room with random huts

sub addsparsehuts {
	my ( $room, $roomspc ) = @_;

	# get placement information about the room
	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $room );

	my $xf = $xc + $xs - 1;
	my $yf = $yc + $ys - 1;
	my $zf = $zc + $zs - 1;

	my ( $valid_b23, $roomspc_b23) = getroomspcflag( $roomspc, 23 );
	my ( $valid_b26, $roomspc_b26) = getroomspcflag( $roomspc, 26 );

	my $success = 0;

	# lookup the room class for the first room with the random hut bit set
	my ( $found_hut, $hutroom ) = scanforroomflag( 20 );
	return if ! $found_hut;

	my ( $valid_b2, $roomspc_b2) = getroomspcflag( $hutroom, 2 );
	my $numhuts = int( $xs * $zs * $hutdensity / 100 );

	my ( $xroomsize, $yroomsize, $zroomsize );
	my ( $xroomcorner, $yroomcorner, $zroomcorner );
	my ( $xfcorner, $yfcorner, $zfcorner );

	# limit the number of huts if we are running out of available room IDs.
	if (($totalrooms + $numhuts + $ymazesize) > ($roomidmask>>$roomidshft)) {
		$numhuts = (($roomidmask>>$roomidshft) - $totalrooms - $ymazesize);
	};

	# get room sizes for the hut class
	my ( $xminsize, $yminsize, $zminsize, $xmaxsize, $ymaxsize, $zmaxsize ) =
		getroomclasssizes( $hutroom );

	foreach my $hutinc ( 1..$numhuts ) {
		foreach my $attempt ( 1..$roomplacetrys ) {

			# generate random room size based on room class
			( $xroomsize, $yroomsize, $zroomsize ) = ( $xminsize,$yminsize,$zminsize );
			$xroomsize = int(rand($xmaxsize-$xminsize+1))+$xminsize;
			$yroomsize = int(rand($ymaxsize-$yminsize+1))+$yminsize;
			$zroomsize = int(rand($zmaxsize-$zminsize+1))+$zminsize;
			$yroomsize = $ys if $yroomsize > $ys;

			# 50/50 chance of swapping X/Z if room special flag bit 2 is set.
			( $xroomsize, $zroomsize ) = ( $zroomsize, $xroomsize ) if (int(rand(2)) && $roomspc_b2 );

			$xroomcorner = $xc + int(rand($xs-$xroomsize-1))+1;
			$zroomcorner = $zc + int(rand($zs-$zroomsize-1))+1;
			$yroomcorner = $yf if ( ! $roomspc_b23 && ! $roomspc_b26 );
			$yroomcorner = $yf-1 if ( $roomspc_b23 || $roomspc_b26 );

			my $overlap = 0;

			# determine the far corner
			$xfcorner=( $xroomcorner+$xroomsize-1 );
			$yfcorner=( $yroomcorner+$yroomsize-1 );
			$zfcorner=( $zroomcorner+$zroomsize-1 );

			my ( $xrangestart, $xrangeend, $zrangestart, $zrangeend ) =
				( $xroomcorner-1, $xfcorner+1, $zroomcorner-1, $zfcorner+1);

			# check to see if room overlaps another room
			foreach my $yinc (($yroomcorner) .. ($yfcorner)) {
          	  		foreach my $xinc ($xrangestart..$xrangeend) {
            	    			foreach my $zinc ($zrangestart..$zrangeend) {
						if (! checkbounds( $xinc, $yinc, $zinc)) {
							$overlap = 1;
							next;
						}
						my $cellval = getroomid( $xinc, $yinc, $zinc );
						my $celluse = getcelluse( $xinc, $yinc, $zinc );
						$overlap = 1 if ( $cellval != $room || $celluse != 0 ) ;
		    			};
				};
        	  	};


			# make sure room is within maze area
			my $valid = 0;
			$valid = checkbounds( $xroomcorner, $yroomcorner, $zroomcorner );
			next if $valid == 0;
			$valid = checkbounds( $xfcorner, $yfcorner, $zfcorner );
			next if $valid == 0;

			# try again if room overlaps another
			next if $overlap == 1;

			# reject room if it will conflict with any noroom-flagged cells.
			my $nrbconflict = setroomidgrid( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, 0, $hutroom );
			next if $nrbconflict;

			# we found a good location for the room
			$success = 1;

			# add a room entry to the room list
			my $addedroom = addrooment( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, $hutroom );

			# build room into the array
			buildroom( $addedroom, $hutroom ) if ($addedroom);

			last;
		};
		# abandon adding any more huts if we have failed to add a room
    		last if $success == 0;
	};
};

#------------------------------------------------------------------------------
# adddensehuts - densely fill room with huts


sub adddensehuts {
	my ( $room, $roomspc ) = @_;

	# get placement information about the room
	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $room );

	my $xf = $xc + $xs - 1;
	my $yf = $yc + $ys - 1;
	my $zf = $zc + $zs - 1;

	my ( $valid_b23, $roomspc_b23) = getroomspcflag( $roomspc, 23 );
	my ( $valid_b26, $roomspc_b26) = getroomspcflag( $roomspc, 26 );
	my ( $valid_b18, $roomspc_b18) = getroomspcflag( $roomspc, 18 );

	my ( $xposstart, $zposstart ) = ( $xc+1, $zc+1);
	( $xposstart, $zposstart ) = ( $xc, $zc) if $roomspc_b18;

	foreach my $pass ( 1, 2) {
		foreach my $xloc ( $xposstart..$xf ) {
		    next if (($xloc-$xc)&1 && ! $roomspc_b18 );
		    foreach my $zloc ( $zposstart..$zf ) {
		        next if (($zloc-$zc)&1 && ! $roomspc_b18 );

			# we use random hut classes for the first pass, and the small hut classes for the second pass
			my ( $hut_found, $hutroom ) = randomroomclasslist(4,21) if $pass == 1;
			( $hut_found, $hutroom ) = randomroomclasslist( 4,22 ) if $pass == 2;

			my ( $valid_b2, $roomspc_b2) = getroomspcflag( $hutroom, 2 );

			my ( $xroomsize, $yroomsize, $zroomsize );
			my ( $xroomcorner, $yroomcorner, $zroomcorner );
			my ( $xfcorner, $yfcorner, $zfcorner );

			# get room sizes for the hut class
			my ( $xminsize, $yminsize, $zminsize, $xmaxsize, $ymaxsize, $zmaxsize ) =
				getroomclasssizes( $hutroom );

			# generate random room size based on room class
			( $xroomsize, $yroomsize, $zroomsize ) = ( $xminsize,$yminsize,$zminsize );
			$xroomsize = int(rand($xmaxsize-$xminsize+1))+$xminsize;
			$yroomsize = int(rand($ymaxsize-$yminsize+1))+$yminsize;
			$zroomsize = int(rand($zmaxsize-$zminsize+1))+$zminsize;
			$yroomsize = $ys if $yroomsize > $ys;

			# 50/50 chance of swapping X/Z if room special flag bit 2 is set.
			( $xroomsize, $zroomsize ) = ( $zroomsize, $xroomsize ) if (int(rand(2)) && $roomspc_b2 );

			$xroomcorner = $xloc;
			$zroomcorner = $zloc;
			$yroomcorner = $yf if ( ! $roomspc_b23 && ! $roomspc_b26 );
			$yroomcorner = $yf-1 if ( $roomspc_b23 && $roomspc_b26 );

			my $overlap = 0;

			# determine the far corner
			$xfcorner=( $xroomcorner+$xroomsize-1 );
			$yfcorner=( $yroomcorner+$yroomsize-1 );
			$zfcorner=( $zroomcorner+$zroomsize-1 );

			my ( $xrangestart, $xrangeend, $zrangestart, $zrangeend ) =
				( $xroomcorner-1, $xfcorner+1, $zroomcorner-1, $zfcorner+1);

			# check to see if room overlaps another room
			foreach my $yinc (($yroomcorner) .. ($yfcorner)) {
				foreach my $xinc ($xrangestart..$xrangeend) {
					foreach my $zinc ($zrangestart..$zrangeend) {
						if (! checkbounds( $xinc, $yinc, $zinc)) {
							$overlap = 1;
							next;
						}
						my $cellval = getroomid( $xinc, $yinc, $zinc );
						my $celluse = getcelluse( $xinc, $yinc, $zinc );
						$overlap = 1 if ( $cellval != $room || $celluse != 0 ) ;
					};
				};
			};

			# make sure room is within maze area
			my $valid = 0;
			$valid = checkbounds( $xroomcorner, $yroomcorner, $zroomcorner );
			next if $valid == 0;
			$valid = checkbounds( $xfcorner, $yfcorner, $zfcorner );
			next if $valid == 0;

			# try again if room overlaps another
			next if $overlap == 1;

			# reject room if it will conflict with any noroom-flagged cells.
			my $nrbconflict = setroomidgrid( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, 0, $hutroom );
			next if $nrbconflict;

			# add a room entry to the room list
			my $addedroom = addrooment( $xroomcorner, $yroomcorner, $zroomcorner, $xroomsize, $yroomsize, $zroomsize, $hutroom );

			# build room into the array
			buildroom( $addedroom, $hutroom ) if ($addedroom);

		    }
		}
	};
};

#------------------------------------------------------------------------------
# addcanals - fill room with canal level

sub addcanals {
	# addcanals really works better with odd-sized canal areas

	my ( $room, $auxval ) = @_;

	my $roomspc=0;

	my ( $xc, $yc, $zc, $xs, $ys, $zs ) = ( 0,$auxval,0,$xmazesize,1,$zmazesize);

	if ( $room ) {
		$roomspc = $auxval;
		# get placement information about the room
		( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $room );
		print "$xc $yc $zc $xs $ys $zs\n" if ( $debug2 );
	};

	# determine far corner coordinates of room
	my $xf = $xc + $xs - 1;
	my $yf = $yc + $ys - 1;
	my $zf = $zc + $zs - 1;

	# find the center of the main canal room
	my $xctr = ( $xc + int($xs/2));
	my $zctr = ( $zc + int($zs/2));

	# determine the size of the canal grid
	my $xcgrid = ((int($xs/2))/$canalxspace);
	my $zcgrid = ((int($zs/2))/$canalzspace);

	# set the internal canal rooms to the height of the main canal room
	my $canalyroom = $ys;
	my $canalyloc = $yf;
	print "canalyroom: $canalyroom canalyloc: $canalyloc\n" if ( $debug2 );

	if ( $room ) {
		# adjust the height/corner of the canal rooms if room special bits 8 or 23 are set.
		my ( $valid_b8, $roomspc_b8) = getroomspcflag( $roomspc, 8 );
		my ( $valid_b23, $roomspc_b23) = getroomspcflag( $roomspc, 23 );
		my ( $valid_b26, $roomspc_b26) = getroomspcflag( $roomspc, 26 );
		$canalyroom -= 1 if ($roomspc_b8 && ! $roomspc_b26);
		$canalyroom -= 1 if ($roomspc_b23 && ! $roomspc_b26);
		$canalyroom -= 2 if $roomspc_b26;
		$canalyloc -=1 if ($roomspc_b23 || $roomspc_b26);
	};

	foreach my $xg ( 1..$xcgrid ) {
	    foreach my $zg ( 1..$zcgrid ) {
		# pick a random canal room type for this room
		my ( $canal_found, $canalroom ) = randomroomclasslist(4,25);

		# determine the room corners within the grid
		my $xcleft = ( $xctr - ( $xg * $canalxspace) + 1);
		my $xcright = ( $xctr + ( $xg * $canalxspace) - $canalxroom);
		my $zctop = ( $zctr - ( $zg * $canalzspace) + 1);
		my $zcbottom = ( $zctr + ( $zg * $canalzspace) - $canalzroom);

		# add the rooms to each quadrant if we have no noroom bit conflicts
		my $nrbc1 = addrooment( $xcleft, $canalyloc, $zctop, $canalxroom, $canalyroom, $canalzroom, 0, $canalroom );
		if ($nrbc1 == 0 ) {
			my $room = addrooment( $xcleft, $canalyloc, $zctop, $canalxroom, $canalyroom, $canalzroom, $canalroom );
			buildroom( $room, $canalroom ) if ( $room );
		}

		my $nrbc2 = addrooment( $xcright, $canalyloc, $zctop, $canalxroom, $canalyroom, $canalzroom, 0, $canalroom );
		if ($nrbc2 == 0 ) {
			my $room = addrooment( $xcright, $canalyloc, $zctop, $canalxroom, $canalyroom, $canalzroom, $canalroom );
			buildroom( $room, $canalroom ) if ( $room );
		}

		my $nrbc3 = addrooment( $xcleft, $canalyloc, $zcbottom, $canalxroom, $canalyroom, $canalzroom, 0, $canalroom );
		if ($nrbc3 == 0 ) {
			my $room = addrooment( $xcleft, $canalyloc, $zcbottom, $canalxroom, $canalyroom, $canalzroom, $canalroom );
			buildroom( $room, $canalroom ) if ( $room );
		}

		my $nrbc4 = addrooment( $xcright, $canalyloc, $zcbottom, $canalxroom, $canalyroom, $canalzroom, 0, $canalroom );
		if ($nrbc4 == 0 ) {
			my $room = addrooment( $xcright, $canalyloc, $zcbottom, $canalxroom, $canalyroom, $canalzroom, $canalroom );
			buildroom( $room, $canalroom ) if ( $room );
		}
	    }
	}
};

#------------------------------------------------------------------------------
# spcroomfill - perform custom operations on special rooms

sub spcroomfill {
	my ( $room, $roomspc ) = @_;

	# loosly fill room with huts if room special flag bit 18 is set
	my ( $valid_b18, $roomspc_b18) = getroomspcflag( $roomspc, 18 );
	addsparsehuts( $room, $roomspc) if ( $roomspc_b18 );

	# densely fill room with huts if room special flag bit 19 is set
	my ( $valid_b19, $roomspc_b19) = getroomspcflag( $roomspc, 19 );
	adddensehuts( $room, $roomspc) if ( $roomspc_b19 );

	# fill room with canals if room special flag bit 24 is set
	my ( $valid_b24, $roomspc_b24) = getroomspcflag( $roomspc, 24 );
	addcanals( $room, $roomspc ) if ( $roomspc_b24 );

	# select random style if room is a large spiral staircase
	my ( $lsrcid, $lsname ) = getroomident( "Large Staircase" );
	if ( $roomspc == $lsrcid ) {
		my @roomvars = getroomvars( $roomspc );
		my $roomvari = int( rand( $roomvars[0] ) );
		setroomchars( $room, "$roomvari" );
	};

	# select random style if room is a spiral staircase
	my ( $ssrcid, $ssname ) = getroomident( "Spiral Staircase" );
	if ( $roomspc == $ssrcid ) {
		my @roomvars = getroomvars( $roomspc );
		my $roomvari = int( rand( $roomvars[0] ) );
		setroomchars( $room, "$roomvari" );
	};

	# select random characteristics if room is a tower
	my ( $valid_b33, $roomspc_b33) = getroomspcflag( $roomspc, 33 );
	if ( $roomspc_b33 ) {

	    my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $room );
	    my $yfc=( $yc+$ys-1 );

	    my $towertype = 0;

	    my @towerclasslist = &randomnumberlist( $maxtowerclass + 1 );
	    foreach my $towercltype ( @towerclasslist ) {

		# get tower class characteristics
		my ( $towerid, $topvars, $midvars, $botvars, $xsize, $zsize, $yminsize, $ymaxsize ) = gettowerinfo( $towercltype - 1 );

		# skip if this room does not fit the requirements for this tower type
		next if ( $xs != $xsize || $zs != $zsize || $ys < $yminsize || $ys > $ymaxsize );

		$towertype = $towercltype - 1;
		last;
	    };

	    my ( $towerid, $topvars, $midvars, $botvars, $xsize, $zsize, $yminsize, $ymaxsize ) = gettowerinfo( $towertype );

	    my $roomchars = "$towertype";

	    # choose bottom variant
	    my $botvari = 1 + int( rand( $botvars ));
	    $roomchars .= ",$botvari";

	    # choose middle variants
	    if ( $ys > 2 ) {
			foreach my $inc ( 1 .. $ys - 2 ) {
				my $midvari = 1 + int( rand( $midvars ));
				$roomchars .= ",$midvari";
			};
	    };

	    # choose top variant
	    my $topvari = 1 + int( rand( $topvars ));
	    $roomchars .= ",$topvari";

	    setroomchars( $room, $roomchars );
	};
};

#------------------------------------------------------------------------------
# clearledgeflag - clear the ledge flag

sub clearledgeflag {
	my ( $X, $Y, $Z ) = @_;
	print "clearledgeflag at $X $Y $Z\n" if $debug3;
	$adjmazegrid[$X][$Y][$Z] =
		(($adjmazegrid[$X][$Y][$Z] | $ledgemask)^$ledgemask);
};

#------------------------------------------------------------------------------
# setledgeflag - set the ledge flag

sub setledgeflag {
	my ( $X, $Y, $Z ) = @_;
	print "setledgeflag at $X $Y $Z\n" if $debug3;
	$adjmazegrid[$X][$Y][$Z] =
		($adjmazegrid[$X][$Y][$Z] | $ledgemask);
};

#------------------------------------------------------------------------------
# getledgeflag - get the ledge flag

sub getledgeflag {
	my ( $X, $Y, $Z ) = @_;
	my $ledgeflag = (($adjmazegrid[$X][$Y][$Z] & $ledgemask) >> $ledgeshft);
	$ledgeflag = 0 if ! $ledgeflag;
	print "getledgeflag at $X $Y $Z is $ledgeflag\n" if $debug3;
	return( $ledgeflag );
};

#------------------------------------------------------------------------------
# clearuseflag - clear the cell use flag

sub clearuseflag {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	$mazegrid[$X][$Y][$Z] =
		(($mazegrid[$X][$Y][$Z] | $cellusemask)^$cellusemask);
	return 1;
};

#------------------------------------------------------------------------------
# setuseflag - set the cell use flag

sub setuseflag {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | $cellusemask);
	return 1;
};

#------------------------------------------------------------------------------
# cleardoorflag - clear the door flag and set the cell use flag

sub cleardoorflag {
	my ($X, $Y, $Z, $celluse ) = @_;
	print "cleardoorflag at $X $Y $Z\n" if $debug3;
	my $cellval = $mazegrid[$X][$Y][$Z];
	$cellval = 0 if ! $cellval;
	if ( $celluse ) {
		$mazegrid[$X][$Y][$Z] = (($cellval|$doormask)^($doormask)) | $cellusemask;
	} else {
		$mazegrid[$X][$Y][$Z] = (($cellval|$doormask)^($doormask));
	};
	return 1;
};

#------------------------------------------------------------------------------
# clearthruflag - clear the thru flag and optionally set the cell use flag

sub clearthruflag {
	my ($X, $Y, $Z, $celluse ) = @_;
	print "clearthruflag at $X $Y $Z\n" if $debug3;
	my $cellval = $mazegrid[$X][$Y][$Z];
	$cellval = 0 if ! $cellval;
	if ( $celluse ) {
		$mazegrid[$X][$Y][$Z] = (($cellval|$thrumask)^($thrumask)) | $cellusemask;
	} else {
		$mazegrid[$X][$Y][$Z] = (($cellval|$thrumask)^($thrumask));
	};
	return 1;
};

#------------------------------------------------------------------------------
# cleardoorgroup - clear all door flags associated with the specified location
sub cleardoorgroup {
	my ($X, $Y, $Z, $celluse ) = @_;

	print "cleardoorgroup at $X $Y $Z\n" if $debug2;

	# verify that the coordinates are valid
	my $valid = checkbounds( $X, $Y, $Z );
	return 0 if ! $valid;

	# verify that we are on a room cell
	my $roomid = getroomid( $X, $Y, $Z );
	return 0 if ! $roomid;

	# verify that we have a door flag to clear
	my $doorflag = getdoorflag( $X, $Y, $Z );
	# return 0 if ! $doorflag;

	# get the room dimensions
	my ( $xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze ) = getroompos( $roomid ) if $roomid;

	my $doorgp = getdoorgp( $X, $Y, $Z );
	cleardoorflag( $X, $Y, $Z, $celluse );

	for my $xinc ( $xc .. ( $xc + $xs - 1 ) ) {
	    last if ( ! $doorgp );
	    for my $yinc ( $yc .. ( $yc + $ys - 1 ) ) {
		for my $zinc ( $zc .. ( $zc + $zs - 1 ) ) {
			my $doorflag2 = getdoorflag( $xinc, $yinc, $zinc );
			# next if ( ! $doorflag );
			my $roomid2 = getroomid( $xinc, $yinc, $zinc );
			next if ( $roomid != $roomid2 );
			my $doorgp2 = getdoorgp( $xinc, $yinc, $zinc );
			next if ( $doorgp2 != $doorgp );
			cleardoorflag( $xinc, $yinc, $zinc, $celluse );
		}
	    }
	};
	print "cleardoorgroup at $X $Y $Z room $roomid group $doorgp\n" if $debug3;
};

#------------------------------------------------------------------------------
# getdoorgp - get the door flag group of the requested cell

sub getdoorgp {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my $doorgp = (($mazegrid[$X][$Y][$Z] & $doorgpmask ) >> $doorgpshft );
	print "getdoorgp at $X $Y $Z returned gp $doorgp\n" if $debug2;
	return( $doorgp );
};

#------------------------------------------------------------------------------
# setdoorgp - set the door flag group for a cell

sub setdoorgp {
	my ( $X, $Y, $Z, $doorgp ) = @_;
	print "setdoorgp of $X $Y $Z to $doorgp\n" if $debug2;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | (( $doorgp << $doorgpshft) & $doorgpmask));
};

#------------------------------------------------------------------------------
# getpridoorflag - get the priority door flag of the requested cell

sub getpridoorflag {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my $doorflag = (($adjmazegrid[$X][$Y][$Z] & $pridoormask ) >> $pridoorshft );
	return( $doorflag );
};

#------------------------------------------------------------------------------
# setpridoorflag - set the priority door flag

sub setpridoorflag {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	$adjmazegrid[$X][$Y][$Z] = ($adjmazegrid[$X][$Y][$Z] | $pridoormask);
	return 1;
};

#------------------------------------------------------------------------------
# getdoorflag - get the door flag of the requested cell

sub getdoorflag {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my $doorflag = (($mazegrid[$X][$Y][$Z] & $doormask ) >> $doorshft );
	return( $doorflag );
};

#------------------------------------------------------------------------------
# getthruflag - get the thru flag of the requested cell

sub getthruflag {
	my ($X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my $thruflag = (($mazegrid[$X][$Y][$Z] & $thrumask ) >> $thrushft );
	return( $thruflag );
};

#------------------------------------------------------------------------------
# setdoorflag - set the door flag and clear the cell use flag

sub setdoorflag {
	my ($X, $Y, $Z, $clearcelluse ) = @_;
	if ( $clearcelluse ) {
		$mazegrid[$X][$Y][$Z] =
			(($mazegrid[$X][$Y][$Z] | $cellusemask )^$cellusemask) | $doormask | $odoormask ;
	} else {
		$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | $doormask | $odoormask );
	};
};


#------------------------------------------------------------------------------
# setthruflag - set the thru flag and optionally clear the cell use flag

sub setthruflag {
	my ($X, $Y, $Z, $clearcelluse ) = @_;
	if ( $clearcelluse ) {
		$mazegrid[$X][$Y][$Z] =
			(($mazegrid[$X][$Y][$Z] | $cellusemask )^$cellusemask) | $thrumask | $othrumask ;
	} else {
		$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | $thrumask | $othrumask );
	};
};

#------------------------------------------------------------------------------
# clearfev - clear floor elevation variance value for a cell

sub clearfev {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = (($mazegrid[$X][$Y][$Z] | $fevmask)^$fevmask );

	return( 1 );
};

#------------------------------------------------------------------------------
# clearvhe - clear vertical hallway extension flags

sub clearvhe {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = (($mazegrid[$X][$Y][$Z] | $vhemask)^$vhemask );

	return( 1 );
};

#------------------------------------------------------------------------------
# getfev - get floor elevation variance value

sub getfev {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my $fevvalue = (($mazegrid[$X][$Y][$Z] & $fevmask) >> $fevshft);

	return( $fevvalue );
};

#------------------------------------------------------------------------------
# getvhesseg - get vertical hallway extension segment transitions for a cell

sub getvhesseg {

	my ( $X, $Y, $Z ) = @_;

	my $vheflags = getvhe( $X, $Y, $Z );
	my $segment = getsegment( $X, $Y, $Z );
	my $cellspc = getcellspc( $X, $Y, $Z );
	my ( $lssegid, $ussegid, $ssegid ) = ( 0, 0, 0 );
	my ( $adjsegment1, $adjsegment2, $adjsegment3, $adjsegment4 ) = ( -1, -1, -1, -1 );
	my ( $adjroomid1, $adjroomid2, $adjroomid3, $adjroomid4 ) = ( 0, 0, 0, 0 );
	my ( $adjcellspc1, $adjcellspc2, $adjcellspc3, $adjcellspc4 ) = ( 0, 0, 0, 0 );

	# adjust the segments if crossovers are set
	$segment = ($segment | (1 + 2) ) if ( $cellspc == 2 );
	$segment = ($segment | (4 + 8) ) if ( $cellspc == 3 );
	$segment = ($segment | 1 ) if ( $cellspc == 4 );
	$segment = ($segment | 2 ) if ( $cellspc == 5 );
	$segment = ($segment | 4 ) if ( $cellspc == 6 );
	$segment = ($segment | 8 ) if ( $cellspc == 7 );

	# adjust the upper/lower sections of unusual vhe-to-vhe transitions
	if (( $segment & 48 ) != 48 ) {
		if ( ! ($segment & 1) ) {
			$adjsegment1 = ( getsegment( $X-1, $Y, $Z ) & 48 );
			$adjroomid1 = getroomid( $X-1, $Y, $Z );
			$adjcellspc1 = getcellspc( $X-1, $Y, $Z );

			# if we are adjacent to a passthru, make it appear as having floor/ceiling segments
			$adjsegment1 = ( $adjsegment1 | 48 ) if ( ( $adjcellspc1 >= 32 ) && ( $adjcellspc1 <= 39 ) );

			if ( $adjroomid1 ) {
				$ssegid += 1;
			} else {
				$ssegid += 1 if (( $adjsegment1 & 48) == 48 );
			};
			$ussegid = ( $ussegid | 1 ) if (( $adjsegment1 & 16 ) && ( ! ( $segment & 16 )));
			$lssegid = ( $lssegid | 1 ) if (( $adjsegment1 & 32 ) && ( ! ( $segment & 32 )));
		};
		if ( ! ($segment & 2) ) {
			$adjsegment2 = ( getsegment( $X+1, $Y, $Z ) & 48 );
			$adjroomid2 = getroomid( $X+1, $Y, $Z );
			$adjcellspc2 = getcellspc( $X+1, $Y, $Z );

			# if we are adjacent to a passthru, make it appear as having floor/ceiling segments
			$adjsegment2 = ( $adjsegment2 | 48 ) if ( ( $adjcellspc2 >= 32 ) && ( $adjcellspc2 <= 39 ) );

			if ( $adjroomid2 ) {
				$ssegid += 2;
			} else {
				$ssegid += 2 if (( $adjsegment2 & 48) == 48 );
			};
			$ussegid = ( $ussegid | 2 ) if (( $adjsegment2 & 16 ) && ( ! ( $segment & 16 )));
			$lssegid = ( $lssegid | 2 ) if (( $adjsegment2 & 32 ) && ( ! ( $segment & 32 )));
		};
		if ( ! ($segment & 4) ) {
			$adjsegment3 = ( getsegment( $X, $Y, $Z-1 ) & 48 );
			$adjroomid3 = getroomid( $X, $Y, $Z-1 );
			$adjcellspc3 = getcellspc( $X, $Y, $Z-1 );

			# if we are adjacent to a passthru, make it appear as having floor/ceiling segments
			$adjsegment3 = ( $adjsegment3 | 48 ) if ( ( $adjcellspc3 >= 32 ) && ( $adjcellspc3 <= 39 ) );

			if ( $adjroomid3 ) {
				$ssegid += 4;
			} else {
				$ssegid += 4 if (( $adjsegment3 & 48) == 48 );
			};
			$ussegid = ( $ussegid | 4 ) if (( $adjsegment3 & 16 ) && ( ! ( $segment & 16 )));
			$lssegid = ( $lssegid | 4 ) if (( $adjsegment3 & 32 ) && ( ! ( $segment & 32 )));
		};
		if ( ! ($segment & 8) ) {
			$adjsegment4 = ( getsegment( $X, $Y, $Z+1 ) & 48 );
			$adjroomid4 = getroomid( $X, $Y, $Z+1 );
			$adjcellspc4 = getcellspc( $X, $Y, $Z+1 );

			# if we are adjacent to a passthru, make it appear as having floor/ceiling segments
			$adjsegment4 = ( $adjsegment4 | 48 ) if ( ( $adjcellspc4 >= 32 ) && ( $adjcellspc4 <= 39 ) );

			if ( $adjroomid4 ) {
				$ssegid += 8;
			} else {
				$ssegid += 8 if (( $adjsegment4 & 48) == 48 );
			};
			$ussegid = ( $ussegid | 8 ) if (( $adjsegment4 & 16 ) && ( ! ( $segment & 16 )));
			$lssegid = ( $lssegid | 8 ) if (( $adjsegment4 & 32 ) && ( ! ( $segment & 32 )));
		};
	};

	# used for debugging cell-specific vhe short-segment issues
	# if ( $X == 15 && $Y == 7 && $Z == 9 ) {
	# 	print "$X $Y $Z\tlss $lssegid\tuss $ussegid\tss $ssegid\tvhe $vheflags\ta1 $adjsegment1 a2 $adjsegment2 a3 $adjsegment3 a4 $adjsegment4\n";
	# };

	return( $lssegid, $ussegid, $ssegid );
};

#------------------------------------------------------------------------------
# getvhe - get vertical hallway extension flags

sub getvhe {
	my ( $X, $Y, $Z ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	my $vheflags = (($mazegrid[$X][$Y][$Z] & $vhemask) >> $vheshft);

	return( $vheflags );
};

#------------------------------------------------------------------------------
# setfev - set floor elevation variance value

sub setfev {
	my ( $X, $Y, $Z, $fevvalue ) = @_;
	print "setfev of $X $Y $Z to $fevvalue\n" if $debug2;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | (( $fevvalue << $fevshft) & $fevmask));
		# ((($mazegrid[$X][$Y][$Z] | $fevmask)^$fevmask )|(($fevvalue<<$fevshft) & $fevmask));
};

#------------------------------------------------------------------------------
# setvhe - set vertical hallway extension flags

sub setvhe {
	my ( $X, $Y, $Z, $vheflags ) = @_;
	print "setvhe of $X $Y $Z to $vheflags\n" if $debug2;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] = ($mazegrid[$X][$Y][$Z] | (( $vheflags << $vheshft) & $vhemask));
		# ((($mazegrid[$X][$Y][$Z] | $vhemask)^$vhemask )|(($vheflags<<$vheshft) & $vhemask));
};

#------------------------------------------------------------------------------
# sethalllstyle - set the hallway local style field

sub sethalllstyle {
	my ( $X, $Y, $Z, $lstyle ) = @_;
	print "sethalllstyle at $X $Y $Z to $lstyle\n" if $debug2;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] =
		((($mazegrid[$X][$Y][$Z] | $lstylemask)^$lstylemask )|(($lstyle<<$lstyleshft) & $lstylemask));
};

#------------------------------------------------------------------------------
# sethallgstyle - set the hallway global style field

sub sethallgstyle {
	my ( $X, $Y, $Z, $gstyle ) = @_;
	print "sethallgstyle at $X $Y $Z to $gstyle\n" if $debug2;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$mazegrid[$X][$Y][$Z] =
		((($mazegrid[$X][$Y][$Z] | $gstylemask)^$gstylemask )|(($gstyle<<$gstyleshft) & $gstylemask));
};

#------------------------------------------------------------------------------
# sethallid - set the special hallway identifier field

sub sethallid {
	my ( $X, $Y, $Z, $hall, $doorflag, $noinc ) = @_;
	print "sethallid of $hall at $X $Y $Z\n" if $debug2;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));

	$auxmazegrid[$X][$Y][$Z] =
		((($auxmazegrid[$X][$Y][$Z] | $hallidmask)^$hallidmask )|(($hall<<$hallidshft) & $hallidmask));

	if ( $noinc == 0 ) {
		# Increment the cell or door counters
		if ( $doorflag ) {
			my $dctr = gethallinfo( $X, $Y, $Z, 0, 4 ) + 1;
			sethallinfo( $X, $Y, $Z, 0, 4, $dctr );
		} else {
			my $cctr = gethallinfo( $X, $Y, $Z, 0, 5 ) + 1;
			sethallinfo( $X, $Y, $Z, 0, 5, $cctr );
			# print "sethallid: cell counter incremented to $cctr for $hall\n";
		};
	};
};

#------------------------------------------------------------------------------
# setcellspc - set the special cell identifier field

sub setcellspc {
	my ( $X, $Y, $Z, $cellspc ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	$auxmazegrid[$X][$Y][$Z] =
		(($auxmazegrid[$X][$Y][$Z] | $cellspcmask)^$cellspcmask )|($cellspc<<$cellspcshft & $cellspcmask);
	print "cellspc $cellspc at $X $Y $Z\n" if $debug3;
};

#------------------------------------------------------------------------------
# setsegment - set the segment ID of the cell

sub setsegment {
	my ($X, $Y, $Z, $segment ) = @_;
	my $oldseg = (($auxmazegrid[$X][$Y][$Z] & $segmentmask) >> $segmentshft );

	$auxmazegrid[$X][$Y][$Z] =
		(($auxmazegrid[$X][$Y][$Z] | $segmentmask)^$segmentmask )|($segment<<$segmentshft & $segmentmask);

	print "setsegment of $X $Y $Z to $segment, previously $oldseg\n" if $debug3;
};

#------------------------------------------------------------------------------
# setroomid - set the room ID of the cell

sub setroomid {
	my ($X, $Y, $Z, $roomid ) = @_;
	return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
	$auxmazegrid[$X][$Y][$Z] =
		(($auxmazegrid[$X][$Y][$Z] | $roomidmask)^$roomidmask )|($roomid<<$roomidshft & $roomidmask)
};

#------------------------------------------------------------------------------
# getroomid - get the room ID of the cell

sub getroomid {
		my ($X, $Y, $Z ) = @_;
		return ( 0 ) if (! checkbounds( $X, $Y, $Z ));
		my $roomid = (($auxmazegrid[$X][$Y][$Z] & $roomidmask) >> $roomidshft );
		print "getroomid for $X $Y $Z returns $roomid\n" if $debug3;
		return( $roomid );
};


#------------------------------------------------------------------------------
# settrap - generate a random trap

sub settrap {
	my ( $X, $Y, $Z, $traptype, $distance, $thread ) = @_;
	my ( $celluse, $cellpath, $roomid, $cellspc );
	print "settrap at $X $Y $Z type $traptype\n" if $debug2;
	my $YI = 1;
	$YI = -1 if ($invertlevels);

	# determine if we are allowed to have hallway traps on this level or hallway type
	my ( $valid_b1, $levelspc_b1) = getlevelflag( $Y, 1 );
	my ( $hvalid_b1, $hallspc_b1) = gethallflag( $X, $Y, $Z, 1 );
	$roomid = getroomid( $X, $Y, $Z );
	my $hall = gethallid( $X, $Y, $Z );
	my ( $hallgstyle, $halllstyle ) = gethallstyle( $X, $Y, $Z );

	# skip this spot if cell is not suitable for a trap.
	my ($feffectlvl, $feffecttype) = getfeffectlvl($X, $Y, $Z );
	return 0 if ($feffectlvl || $feffecttype);

	# skip adding trap if we are now allowed on this level or in this hallway type
	return 0 if ($roomid != 0);
	return 0 if ($hallspc_b1 == 1 );
	return 0 if ($levelspc_b1 == 1 );

	if ( $traptype == 2 || $traptype == 3 ) {
		# bypass adding trap if we are not allowed to have deep/shallow pits on lower level or hallway
		my ( $valid_b5, $levelspc_b5) = getlevelflag( $Y+$YI, 5 );
		my ( $valid_b2, $hallspc_b2) = gethallflag( $X, $Y+$YI, $Z, 2 );
		return 0 if ( $levelspc_b5 || $hallspc_b2);

		# check if we have enough room for a shallow/deep pit trap
		my $valid = checkbounds( $X, $Y+$YI, $Z );
		return 0 if (! $valid );

		$celluse = getcelluse( $X, $Y+$YI, $Z );
		$cellpath = getpathflags( $X, $Y+$YI, $Z );
		$roomid = getroomid( $X, $Y+$YI, $Z );
		$cellspc = getcellspc( $X, $Y+$YI, $Z );

		# check if the lower cell is suitable for a pit trap
		if ( $traptype == 3 ) {
			# suitable for a deep pit trap?
			return 0 if ( $celluse || ($cellpath & 63 != 63) || $roomid || $cellspc );
		} else {
			# suitable for a shallow pit trap?
			return 0 if (($cellpath & 16 != 16) || $roomid || $cellspc && ! $invertlevels );
			return 0 if (($cellpath & 32 != 32) || $roomid || $cellspc && $invertlevels );
		};
	};

	# get cell info
	$cellspc = getcellspc( $X, $Y, $Z );
	$cellpath = getpathflags( $X, $Y, $Z );
	$roomid = getroomid( $X, $Y, $Z );
	return 0 if ($cellspc || (($cellpath & 32) != 32) && (! $invertlevels) );
	return 0 if ($cellspc || (($cellpath & 16) != 16) && ($invertlevels) );
	return 0 if (($cellpath & 16 != 16) && ! $roomid && (! $invertlevels));
	return 0 if (($cellpath & 32 != 32) && ! $roomid && ($invertlevels));

	if ( $traptype == 1 ) {
		# non-pit trap

		# identify the trap cell
		setcellspc( $X, $Y, $Z, 8 );

	} elsif ( $traptype == 2 ) {
		# shallow pit

		# identify the trap and pit cells
		setcellspc( $X, $Y, $Z, 9 );
		setcellspc( $X, $Y+$YI, $Z, 10 );

	} elsif ( $traptype == 3 ) {
		# deep pit

		# identify the trap and pit cells
		setcellspc( $X, $Y, $Z, 9 );
		setcellspc( $X, $Y+$YI, $Z, 11 );

		# mark pit as used
		setcelluse( $X, $Y+$YI, $Z );

		# set the hallway ID on the pit
		sethallid( $X, $Y+$YI, $Z, $hall, 0, 0 );
		sethallgstyle( $X, $Y+$YI, $Z, $hallgstyle );

		# ( the cell will be opened when the trap is rendered )
		# open path between the trap and pit cells
		# openpath( $X, $Y, $Z, 6, 0, 0 ) if (! $invertlevels);
		# openpath( $X, $Y, $Z, 5, 0, 0 ) if ($invertlevels);

		# zero the backtrack of the pit.
		setbacktrack( $X, $Y+$YI, $Z, 0);

		# set the distance of the pit to the same as the trap
		setcelldist( $X, $Y+$YI, $Z, $distance, $thread);
	}
	print "settrap at $X $Y $Z successful\n" if $debug3;
};

#------------------------------------------------------------------------------
# gettrapodds - determine the odds of traps

sub gettrapodds {

	my $random = 1 + rand(100);
	return 1 if ( $random <= ( $trapodds ));
	return 2 if ( $random <= ( $trapodds + $pittrapodds ));
	return 3 if ( $random <= ( $trapodds + $pittrapodds + $deeppittrapodds ));
	return 0;
};

#------------------------------------------------------------------------------
# getfevodds - determine the odds of starting/stopping a floor elevation variance

sub getfevodds {
	return 0 if ( ! $fev_enabled );

	my ( $X, $Y, $Z ) = @_;
	my $hall = gethallid( $X, $Y, $Z );
	my $fevvalue = getfev( $X, $Y, $Z );
	my $maxfevvalue = gethallinfo( $X, $Y, $Z, 1, 19 );
	my $fevstartodds = gethallinfo( $X, $Y, $Z, 1, 20 );
	my $fevchgodds = gethallinfo( $X, $Y, $Z, 1, 21 );

	my ($rfevfound, $rfevflag) = gethallflag( $X, $Y, $Z, 23 );

	my $newfevvalue = $fevvalue;

	my $random1 = 1 + rand(100);
	my $random2 = int( rand(100));

	if ( $fevvalue == 0 ) {
		$newfevvalue += 1 if ( $random1 <= $fevstartodds );
	} else {
		if ( $random1 <= $fevchgodds ) {
			if ( $rfevflag ) {
				$newfevvalue = int( $random2 * ( $maxfevvalue + 1 ) / 100 );
			} else {
				$newfevvalue += 1 if ( $random2 < 50 );
				$newfevvalue -= 1 if ( $random2 >= 50 );
			};
		};
	};

	$newfevvalue = 0 if ( $newfevvalue < 0 );
	$newfevvalue = $maxfevvalue if ( $newfevvalue > $maxfevvalue );

	print "getfevodds old: $fevvalue new: $newfevvalue\n" if $debug2;

	return( $newfevvalue );
};


#------------------------------------------------------------------------------
# getvheodds - determine the odds of starting/stopping vertical hallway extension

sub getvheodds {
	return 0 if ( ! $vhe_enabled );

	my ( $X, $Y, $Z ) = @_;
	my $hall = gethallid( $X, $Y, $Z );
	my $hclass = gethallinfo( $X, $Y, $Z, 0, 0);
	my $segment = getsegment( $X, $Y, $Z );

	my $vhestartodds = gethallinfo( $X, $Y, $Z, 1, 16 );
	my $vhechangeodds = gethallinfo( $X, $Y, $Z, 1, 17 );
	my $vheupdefault = gethallinfo( $X, $Y, $Z, 1, 32 );
	my $vhedowndefault = gethallinfo( $X, $Y, $Z, 1, 33 );
	my ( $valid_b21, $hallspc_b21 ) = gethallflag( $X, $Y, $Z, 21 );

	# my $vhestate = 0;
	my $vhestate = 3 ^ ( $segment >> 4 );
	my $vheustate = ($vhestate & 1 );
	my $vhedstate = (($vhestate & 2 ) >> 1);

	# determine the current VHE state
	if ( $vheustate) {
		my ( $segment2, $valid2 ) = getsegment( $X, $Y-1, $Z ) & 16;
		my ( $segment3, $valid3 ) = getsegment( $X, $Y-2, $Z ) & 16;
		$segment2 = 16 if ( ! $valid2 );
		$segment3 = 16 if ( ! $valid3 );
		$vheustate = 2 if ( ! $segment2 );
		$vheustate = 3 if ( ! $segment2 && ! $segment3);
	};
	if ( $vhedstate) {
		my ( $segment2, $valid2 ) = getsegment( $X, $Y+1, $Z ) & 32;
		my ( $segment3, $valid3 ) = getsegment( $X, $Y+2, $Z ) & 32;
		$segment2 = 32 if ( ! $valid2 );
		$segment3 = 32 if ( ! $valid3 );
		$vhedstate = 2 if ( ! $segment2 );
		$vhedstate = 3 if ( ! $segment2 && ! $segment3);
	};

	my ( $newvheustate, $newvhedstate ) = ( $vheustate, $vhedstate );

	my ($ufound, $uflag) = gethallflag( $X, $Y, $Z, 4 );
	my ($dfound, $dflag) = gethallflag( $X, $Y, $Z, 5 );
	my $vheumax = gethallinfo( $X, $Y, $Z, 1, 30 );
	my $vhedmax = gethallinfo( $X, $Y, $Z, 1, 31 );

	my $random1 = 1 + rand(100);
	my $random2 = 1 + rand(100);
	my $random3 = 1 + rand(100);
	my $random4 = 1 + rand(100);

	if ( $vheustate && ($random1 <= $vhechangeodds)) {
		$newvheustate += 1 if ( $random3 <= 50 );
		$newvheustate -= 1 if ( $random3 > 50 );
	} elsif ( ! $vheustate && ($random1 <= $vhestartodds) && $uflag) {
		$newvheustate = $vheupdefault;
		$newvheustate = int(($random3 - 1) / 100 * ( $vheumax + 1 )) if ( ! $vheupdefault );
	};
	if ( $vhedstate && ($random2 <= $vhechangeodds)) {
		$newvhedstate += 1 if ( $random4 <= 50 );
		$newvhedstate -= 1 if ( $random4 > 50 );
	} elsif ( ! $vhedstate && ($random2 <= $vhestartodds) && $dflag) {
		$newvhedstate = $vhedowndefault;
		$newvhedstate = int(($random4 - 1) / 100 * ( $vhedmax + 1 )) if ( ! $vhedowndefault );
	};

	$newvheustate = $vheupdefault if ( $hallspc_b21 && $vheupdefault );
	$newvhedstate = $vhedowndefault if ( $hallspc_b21 && $vhedowndefault );

	$newvheustate = $vheumax if ( $newvheustate > $vheumax );
	$newvhedstate = $vhedmax if ( $newvhedstate > $vhedmax );
	$newvheustate = 0 if ( $newvheustate < 0 );
	$newvhedstate = 0 if ( $newvhedstate < 0 );

	print "getvheodds: old: $vheustate/$vhedstate new: $newvheustate/$newvhedstate\n" if $debug2;
	# print "getvheodds: $X $Y $Z hi/lo: $vheumax/$vhedmax old: $vheustate/$vhedstate new: $newvheustate/$newvhedstate\n" if ( $newvheustate > 1);

	return( $newvheustate, $newvhedstate, $vheustate, $vhedstate );
};

#------------------------------------------------------------------------------
# getobjodds - determine the odds of placing objects

sub getobjodds {
	my ( $cc_aobjthr, $cc_tobjthr, $cc_objidx, $cc_objct, $cc_roomid ) = @_;

	my $roomspc = getroomspc( $cc_roomid ) if $cc_roomid;
	my ( $valid_b35, $roomspc_b35) = getroomspcflag( $roomspc, 35 ) if $cc_roomid;

	my $new_aobjthr = $cc_aobjthr + 1;
	my $new_tobjthr = $cc_tobjthr + 1;

	my ( $new_objidx, $new_objct ) = ( $cc_objidx, $cc_objct );

	# random numbers used for object placement
	my $trandom = int(rand( $tobj_div ) * $tobj_rmult );
	my $arandom = int(rand( $aobj_div ) * $aobj_rmult );

	# random numbers used to determine value of object to place
	my $ttrandom = int( ($cc_tobjthr/2) + rand( $cc_tobjthr/2 ));
	my $atrandom = int( ($cc_aobjthr/2) + rand( $cc_aobjthr/2 ));

	my ( $aobj_match, $tobj_match ) = ( 0,0 );

	# determine if we trigger a treasure or architectural object match
	$aobj_match = 1 if ( $arandom < $cc_aobjthr );
	$tobj_match = 1 if ( $trandom < $cc_tobjthr );

	# always trigger a treasure object match if we enter a room with roomspc bit 35 set.
	$tobj_match = 1 if $roomspc_b35;

	# clear any matches if we have already matched this location.
	( $tobj_match, $aobj_match ) = (0, 0) if $cc_objct;

	my $objtype="X";
	my $objvalue=0;

	# reduce the aobj threshold counter if we have an aobj match
	if ( $aobj_match && ! $tobj_match ) {

		$objtype = "A";
		$objvalue = $atrandom;

		$new_aobjthr -= $objvalue;

		$total_aobj += 1;
	};

	# reduce the tobj threshold counter if we have a tobj match
	if ( $tobj_match && ! $aobj_match ) {

		$objtype = "T";
		$objvalue = $ttrandom;

		$new_tobjthr -= $objvalue;

		$total_tobj += 1;
	};

	# reduce both threshold counters if we have an aobj/tobj match
	if ( $tobj_match && $aobj_match ) {

		$objtype = "AT";

		$objvalue = $atrandom if ( $atrandom <= $ttrandom );
		$objvalue = $ttrandom if ( $ttrandom < $atrandom );

		$new_aobjthr -= $objvalue;
		$new_tobjthr -= $objvalue;

		$total_atobj += 1;
	};
	
	$new_aobjthr = 0 if ( $new_aobjthr < 0 );
	$new_tobjthr = 0 if ( $new_tobjthr < 0 );

	if ( $tobj_match || $aobj_match ) {
		# set a new index value if necessary and increment the object count
		if ( ! $new_objidx ) {
			$max_objidx += 1 ;
			$new_objidx = $max_objidx;
		}
		$new_objct += 1;

		# record the object
		$objindex[$new_objidx][0]=$new_objct;
		$objindex[$new_objidx][$new_objct]="$objtype,$objvalue";
	};

	return( $new_aobjthr, $new_tobjthr, $new_objidx, $new_objct, $aobj_match | $tobj_match );
};

#------------------------------------------------------------------------------
# geteffectodds - determine the odds of floor/ceiling effects

sub geteffectodds {
	my ( $cc_feffectlvl, $cc_feffecttype, $cc_ceffectlvl, $cc_ceffecttype, $roomflag ) = @_;
	my ( $new_feffectlvl, $new_feffecttype) = ( $cc_feffectlvl, $cc_feffecttype );
	my ( $new_ceffectlvl, $new_ceffecttype) = ( $cc_ceffectlvl, $cc_ceffecttype );

	my $random = rand(100);
	my $random2 = rand(100);

	# floor effect
	if ( $cc_feffectlvl == 0 ) {
		if ( $random <= $startfceffect ) {
			# determine what floor effect type we should use

			$new_feffectlvl = 1;
			$new_feffecttype = 0;

			my $feffectodds = 0;
			foreach my $feffectclassnum ( 1..$maxfeffectclass ) {
				$feffectodds += $feffectclass[$feffectclassnum][7];
				if ( $random2 <= $feffectodds ) {
					$new_feffecttype = $feffectclassnum;
					last;
				};
			};
		};
	} else {
		# determine if we should increase or decrease the floor effect level

		if ( $random >= (100-$feffectclass[$cc_feffecttype][12]) ) {
			# increase feffect
			$new_feffectlvl += 1;
		} elsif ( $random <= $feffectclass[$cc_feffecttype][13] ) {
			# decrease feffect
			$new_feffectlvl -= 1;
		};
	};

	$random = rand(100);
	$random2 = rand(100);

	# ceiling effect
	if ( $cc_ceffectlvl == 0 ) {
		if ( $random <= $startfceffect ) {
			# determine what ceiling effect type we should use

			$new_ceffectlvl = 1;
			$new_ceffecttype = 0;

			my $ceffectodds = 0;
			foreach my $ceffectclassnum ( 1..$maxceffectclass ) {
				$ceffectodds += $ceffectclass[$ceffectclassnum][7];
				if ( $random2 <= $ceffectodds ) {
					$new_ceffecttype = $ceffectclassnum;
					last;
				};
			};
		};
	} else {
		# determine if we should increase or decrease the ceiling effect level

		if ( $random >= (100-$ceffectclass[$cc_ceffecttype][12]) ) {
			# increase feffect
			$new_ceffectlvl += 1;
		} elsif ( $random <= $ceffectclass[$cc_ceffecttype][13] ) {
			# decrease feffect
			$new_ceffectlvl -= 1;
		};
	};

	my $maxfeffectlvl = $feffectclass[$new_feffecttype][8];
	my $maxceffectlvl = $ceffectclass[$new_ceffecttype][8];

	# basic bounds check
	$new_feffectlvl = 0 if ( $new_feffectlvl < 0 );
	$new_feffectlvl = $maxfeffectlvl if ( $new_feffectlvl > $maxfeffectlvl );
	$new_ceffectlvl = 0 if ( $new_ceffectlvl < 0 );
	$new_ceffectlvl = $maxceffectlvl if ( $new_ceffectlvl > $maxceffectlvl );

	# disallow adjacent maximum floor effect levels if we have floor effect class flag bit 4 set.
	my ( $fvalid_b4, $fflag_b4) = getfeffectspcflag( $new_feffecttype, 4 );
	$new_feffectlvl -= 1 if ( ( $cc_feffectlvl == $maxfeffectlvl ) && ( $new_feffectlvl == $maxfeffectlvl ) && $fflag_b4 );

	# disallow adjacent maximum ceiling effect levels if we have ceiling effect class flag bit 4 set.
	my ( $cvalid_b4, $cflag_b4) = getceffectspcflag( $new_ceffecttype, 4 );
	$new_ceffectlvl -= 1 if ( ( $cc_ceffectlvl == $maxceffectlvl ) && ( $new_ceffectlvl == $maxceffectlvl ) && $cflag_b4 );

	# disallow maximum floor effect level in rooms if we have floor effect class flag bit 8 set.
	my ( $fvalid_b8, $fflag_b8) = getfeffectspcflag( $new_feffecttype, 8 );
	$new_feffectlvl -= 1 if ( ( $new_feffectlvl == $maxfeffectlvl ) && $fflag_b8 && $roomflag );

	# disallow maximum ceiling effect level in rooms if we have ceiling effect class flag bit 8 set.
	my ( $cvalid_b8, $cflag_b8) = getceffectspcflag( $new_ceffecttype, 8 );
	$new_ceffectlvl -= 1 if ( ( $new_ceffectlvl == $maxceffectlvl ) && $cflag_b8 && $roomflag );

	# disallow floor effect type in rooms if we have floor effect class flag bit 7 set.
	my ( $fvalid_b7, $fflag_b7) = getfeffectspcflag( $new_feffecttype, 7 );
	$new_feffectlvl = 0 if ( $fflag_b7 && $roomflag );

	# disallow ceiling effect type in rooms if we have ceiling effect class flag bit 7 set.
	my ( $cvalid_b7, $cflag_b7) = getceffectspcflag( $new_ceffecttype, 7 );
	$new_ceffectlvl = 0 if ( $cflag_b7 && $roomflag );

	print "geteffectodds old flvl $cc_feffectlvl ftype $cc_feffecttype " if $debug2;
	print "new flvl $new_feffectlvl ftype $new_feffecttype b4 $fflag_b4 b8 $fflag_b8 max $maxfeffectlvl room $roomflag\n" if $debug2;
	print "geteffectodds old clvl $cc_ceffectlvl ctype $cc_ceffecttype " if $debug2;
	print "new clvl $new_ceffectlvl ctype $new_ceffecttype b4 $cflag_b4 b8 $cflag_b8 max $maxceffectlvl room $roomflag\n" if $debug2;

	# verify that the new floor effect level is within the proper range
	$new_feffectlvl = ($felevlmask>>$felevlshft) if ($new_feffectlvl > ($felevlmask>>$felevlshft));
	$new_feffectlvl = $maxfeffectlvl if ( $new_feffectlvl > $maxfeffectlvl );
	$new_feffectlvl = 0 if ( $new_feffectlvl < 0 );
	$new_feffecttype = 0 if ( $new_feffectlvl == 0 );

	# verify that the new ceiling effect level is within the proper range
	$new_ceffectlvl = ($celevlmask>>$celevlshft) if ($new_ceffectlvl > ($celevlmask>>$celevlshft));
	$new_ceffectlvl = $maxceffectlvl if ( $new_ceffectlvl > $maxceffectlvl );
	$new_ceffectlvl = 0 if ( $new_ceffectlvl < 0 );
	$new_ceffecttype = 0 if ( $new_ceffectlvl == 0 );

	return($new_feffectlvl, $new_feffecttype, $new_ceffectlvl, $new_ceffecttype);
};

#------------------------------------------------------------------------------
# clearceffecttype - clear the cell ceiling effect type field

sub clearceffecttype {
	my ($X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $field = $distmazegrid[$X][$Y][$Z];
		$distmazegrid[$X][$Y][$Z] = (($field | $cetypemask)^$cetypemask);
		print "clearceffecttype at $X $Y $Z\n" if $debug2;
	}
};

#------------------------------------------------------------------------------
# clearceffectlvl - clear the cell ceiling effect level field

sub clearceffectlvl {
	my ($X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $field = $distmazegrid[$X][$Y][$Z];
		$distmazegrid[$X][$Y][$Z] = (($field | $celevlmask)^$celevlmask);
		print "clearceffectlvl at $X $Y $Z\n" if $debug2;
	}
};

#------------------------------------------------------------------------------
# clearfeffecttype - clear the cell floor effect type field

sub clearfeffecttype {
	my ($X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $field = $distmazegrid[$X][$Y][$Z];
		$distmazegrid[$X][$Y][$Z] = (($field | $fetypemask)^$fetypemask);
		print "clearfeffecttype at $X $Y $Z\n" if $debug2;
	}
};

#------------------------------------------------------------------------------
# clearfeffectlvl - clear the cell floor effect level field

sub clearfeffectlvl {
	my ($X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $field = $distmazegrid[$X][$Y][$Z];
		$distmazegrid[$X][$Y][$Z] = (($field | $felevlmask)^$felevlmask);
		print "clearfeffectlvl at $X $Y $Z\n" if $debug2;
	}
};

#------------------------------------------------------------------------------
# setceffectlvl - set the cell ceiling effect level field

sub setceffectlvl {
	my ($X, $Y, $Z, $ceffectlvl, $ceffecttype ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );
	print "setceffectlvl input $X $Y $Z level $ceffectlvl type $ceffecttype\n" if $debug3;

	# determine room allows ceiling effects
	my $roomid = getroomid( $X, $Y, $Z );
	my $roomspc = getroomspc( $roomid );
	my ( $valid_b6, $roomspc_b6) = getroomspcflag( $roomspc, 6 );

	# determine if hallway allows ceiling effects
	my ( $valid_b33, $hallspc_b33) = gethallflag( $X, $Y, $Z, 33 );

	# determine if level allows ceiling effects
	my ( $valid_b0, $levelspc_b0) = getlevelflag( $Y, 0 );

	# set ceiling effect level to zero if ceiling effects are not allowed by the level or room class.
	($ceffectlvl, $ceffecttype) = (0, 0) if ( $roomspc_b6 || $levelspc_b0 || $hallspc_b33);

	# if cell is valid and ceiling effects are allowed set the ceiling effect level.
	if ( $valid && $allowceffects ) {
		my $field = (($distmazegrid[$X][$Y][$Z]|$celevlmask|$cetypemask)^($celevlmask|$cetypemask));
		$distmazegrid[$X][$Y][$Z] = ($field|($ceffectlvl<<$celevlshft)|($ceffecttype<<$cetypeshft));
		print "setceffectlvl set $X $Y $Z to level $ceffectlvl type $ceffecttype\n" if $debug2;
	}
};

#------------------------------------------------------------------------------
# getceffectlvl - get the cell ceiling effect level field

sub getceffectlvl {
	my ($X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $ceffectlvl = (($distmazegrid[$X][$Y][$Z] & $celevlmask) >> $celevlshft );
		my $ceffecttype = (($distmazegrid[$X][$Y][$Z] & $cetypemask) >> $cetypeshft );
		print "getceffectlvl at $X $Y $Z ceffectlvl $ceffectlvl ceffecttype $ceffecttype\n" if $debug3;
		return( $ceffectlvl, $ceffecttype );
	}
	print "getceffectlvl not valid at $X $Y $Z\n" if $debug3;
};

#------------------------------------------------------------------------------
# setfeffectlvl - set the cell floor effect level field

sub setfeffectlvl {
	my ($X, $Y, $Z, $feffectlvl, $feffecttype ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );
	print "setfeffectlvl input $X $Y $Z level $feffectlvl type $feffecttype\n" if $debug3;

	# determine room allows floor effects
	my $roomid = getroomid( $X, $Y, $Z );
	my $roomspc = getroomspc( $roomid );
	my ( $valid_b6, $roomspc_b6) = getroomspcflag( $roomspc, 6 );

	# determine if hallway allows floor effects
	my ( $valid_b32, $hallspc_b32) = gethallflag( $X, $Y, $Z, 32 );

	# determine if level allows floor effects
	my ( $valid_b0, $levelspc_b0) = getlevelflag( $Y, 0 );

	# set floor effect level to zero if floor effects are not allowed by the level or room class.
	($feffectlvl, $feffecttype) = (0, 0) if ( $roomspc_b6 || $levelspc_b0 || $hallspc_b32);

	# if cell is valid and floor effects are allowed set the floor effect level.
	if ( $valid && $allowfeffects ) {
		my $field = (($distmazegrid[$X][$Y][$Z]|$felevlmask|$fetypemask)^($felevlmask|$fetypemask));
		$distmazegrid[$X][$Y][$Z] = ($field|($feffectlvl<<$felevlshft)|($feffecttype<<$fetypeshft));
		print "setfeffectlvl set $X $Y $Z to level $feffectlvl type $feffecttype\n" if $debug2;
	}
};

#------------------------------------------------------------------------------
# getfeffectlvl - get the cell floor effect level field

sub getfeffectlvl {
	my ($X, $Y, $Z ) = @_;
	my $valid = checkbounds( $X, $Y, $Z );

	if ( $valid ) {
		my $feffectlvl = (($distmazegrid[$X][$Y][$Z] & $felevlmask) >> $felevlshft );
		my $feffecttype = (($distmazegrid[$X][$Y][$Z] & $fetypemask) >> $fetypeshft );
		print "getfeffectlvl at $X $Y $Z feffectlvl $feffectlvl feffecttype $feffecttype\n" if $debug3;
		return( $feffectlvl, $feffecttype );
	}
	print "getfeffectlvl not valid at $X $Y $Z\n" if $debug3;
};

#------------------------------------------------------------------------------
# gethallid - get the hallway id field

sub gethallid {
		my ($X, $Y, $Z) = @_;
		return ( 0 ) if (! checkbounds( $X, $Y, $Z));
		my $hall = (($auxmazegrid[$X][$Y][$Z] & $hallidmask) >> $hallidshft );
		print "gethallid at $X $Y $Z hallid $hall\n" if $debug3;
		return( $hall );
};

#------------------------------------------------------------------------------
# gethallstyle - get the hallway style fields

sub gethallstyle {
		my ($X, $Y, $Z) = @_;
		return ( 0 ) if (! checkbounds( $X, $Y, $Z));

		my $gstyle = (($mazegrid[$X][$Y][$Z] & $gstylemask) >> $gstyleshft );
		my $lstyle = (($mazegrid[$X][$Y][$Z] & $lstylemask) >> $lstyleshft );

		print "gethallstyle at $X $Y $Z gstyle $gstyle lstyle $lstyle\n" if $debug3;
		return( $gstyle, $lstyle );
};

#------------------------------------------------------------------------------
# getcellspc - get the special cell identifer field
#
# current cellspc values:
# 0=none, 1=maze beginning, 2-7=crossovers, 8-15=unused, 16-31=custom room segment type
# 32-63=unused

sub getcellspc {
		my ($X, $Y, $Z) = @_;
		return ( 0 ) if (! checkbounds( $X, $Y, $Z));
		my $cellspc = (($auxmazegrid[$X][$Y][$Z] & $cellspcmask) >> $cellspcshft );
		print "getcellspc at $X $Y $Z cellspc $cellspc\n" if $debug3;
		return( $cellspc );
};

#------------------------------------------------------------------------------
# getlevelspc - get the special level identifer field

sub getlevelspc {
		my $level = $_[0];
		$level = 0 if ! $level;

		my $levelspc = $levelinfo[$level][0];
		return 0 if ( ! $levelspc );

		$levelspc = 0 if ( ! $levelspc );
		print "getlevelspc for $level is $levelspc\n" if $debug3;
		return( $levelspc );
};

#------------------------------------------------------------------------------
# getycoord - get the Y scaled coordinate for a Y position

sub getycoord {
		my $ylevel = $_[0];

		my $ycoord = 0;

		for my $yinc ( 0 .. $ylevel ) {

			my $levelyscale = getyscale( $yinc );
			$ycoord += $levelyscale if $levelyscale;
		};
		$ycoord = ( $mc_yoffset - $ycoord ) + 1;

		print "getycoord for $ylevel is $ycoord\n" if $debug3;
		return( $ycoord );
};

#------------------------------------------------------------------------------
# getyscale - get the Y scale factor from the level information

sub getyscale {
		my $ylevel = $_[0];
		my $levelyscale = $levelinfo[$ylevel][1];
		print "getyscale for $ylevel is $levelyscale\n" if $debug3;
		return( $levelyscale );
};

#------------------------------------------------------------------------------
# getroomyscale - get the total scaled height for a room

sub getroomyscale {
		my $room = $_[0];

		my ( $xc, $yc, $zc, $xs, $ys, $zs ) = getroompos( $room );

		my $yfc=( $yc+$ys-1 );

		my $yrscale = 0;

		for my $yinc ( $yc .. $yfc ) {
			my $levelyscale = getyscale( $yinc );
			$levelyscale = 0 if ( ! $levelyscale );
			$yrscale += $levelyscale;
		};

		print "getyroomscale for room $room is $yrscale\n" if $debug3;
		return( $yrscale );
};

#------------------------------------------------------------------------------
# getlevelalias - get the level identifer alias field

sub getlevelalias {
		my $levelspc = $_[0];
		return 0 if ( ! $levelspc );
		my $levelalias = $levelclass[$levelspc][9];
		$levelalias = $levelspc if ( ! $levelalias );
		print "getlevelalias for $levelspc is $levelalias\n" if $debug3;
		return( $levelalias );
};

#------------------------------------------------------------------------------
# getroomspc - get the special room identifer field

sub getroomspc {
		my $room = $_[0];
		return 0 if ( ! $room );
		my $roomspc = $roominfo[$room][11];
		print "getroomspc for $room is $roomspc\n" if $debug3;
		return( $roomspc );
};

#------------------------------------------------------------------------------
# getsegment - get the room segment ID of the cell

sub getsegment {
		my ($X, $Y, $Z) = @_;
		my $valid = checkbounds( $X, $Y, $Z );
		my $segment = 0;
		if ( $valid ) {
			$segment = (($auxmazegrid[$X][$Y][$Z] & $segmentmask) >> $segmentshft );
			print "getsegment at $X $Y $Z segment $segment\n" if $debug3;
		} else {
			print "getsegment: invalid coordinates $X $Y $Z\n" if $debug3;
		};
		
		return( $segment );
};

#------------------------------------------------------------------------------
# getdoorinfo - get information about a door

sub getdoorinfo {
	my $door = $_[0];
	my $roomnum = $doorinfo[$door][0];
	my $doornum = $doorinfo[$door][1];
	my $xpos = $doorinfo[$door][2];
	my $ypos = $doorinfo[$door][3];
	my $zpos = $doorinfo[$door][4];
	my $dir = $doorinfo[$door][5];
	my $from = $doorinfo[$door][6];
	my $did = $doorinfo[$door][7];
	my $valid = $doorinfo[$door][8];
	my $class = $doorinfo[$door][9];

	print "getdoorinfo for door $door: pos $xpos $ypos $zpos room $roomnum " if $debug3;
	print "door $door dir $dir from $from did $did valid $valid class $class\n" if $debug3;

	return ( $xpos, $ypos, $zpos, $roomnum, $doornum, $dir, $from, $did, $valid, $class );
};

#------------------------------------------------------------------------------
# disabledoor - locate and disable door at coordinates

sub disabledoor {
	my ( $xl, $yl, $zl ) = @_;
	my ( $found, $udoor, $uroom) = ( 0, 0, 0 );
	foreach my $door ( 1 .. $totaldoors ) {
		my ($x, $y, $z, $room, $doornum, $dir, $from, $did, $valid ) = getdoorinfo( $door );
		if ($xl == $x && $yl == $y && $zl == $z) {
			$found = 1;
			$udoor = $door;
			$uroom = $room;
			last;
		};
	};
	$doorinfo[$udoor][8] = 0 if $found;

	print "disabledoor called for $xl $yl $zl, door not found in doorlist\n" if $debug2 && ! $found;
	print "disabledoor called for $xl $yl $zl, door $udoor of room $uroom is disabled\n" if $debug2 && $found;
}

#------------------------------------------------------------------------------
# lookupdoor - scan through door list for a particular door

sub lookupdoor {
	my ( $xl, $yl, $zl ) = @_;
	my ( $found, $udoor) = ( 0, 0 );
	foreach my $door ( 1 .. $totaldoors ) {
		my ($x, $y, $z, $room, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );
		if ($xl == $x && $yl == $y && $zl == $z) {
			$found = 1;
			$udoor = $did;
			last;
		};
	};

	print "lookupdoor at $xl $yl $zl found $found door $udoor\n" if $debug2;

	return ( $found, $udoor );
}

#------------------------------------------------------------------------------
# lookupadjdoor - look for doors leading into a particular cell, and return the first door found

sub lookupadjdoor {
	my ( $xl, $yl, $zl ) = @_;
	my ( $dirfound, $doorfound ) = ( 0, 0 );
	for my $dir ( 1 .. 6 ) {

		my ( $xi, $yi, $zi ) = getmazedirection( $dir );
		next if ( ! $xi && ! $yi && ! $zi );

		my ($doorvalid, $locdoor ) = lookupdoor( $xl+$xi, $yl+$yi, $zl+$zi );
		if ( $doorvalid ) {
		    my ($dx, $dy, $dz, $droom, $sdnum, $ddir, $from, $did, $valid, $doorclass ) = getdoorinfo( $locdoor );

		    my ( $xr, $yr, $zr ) = getmazedirection( $ddir );
		    next if ( ! $xr && ! $yr && ! $zr );

		    if ( ( $xr + $xi ) == 0 && ( $yr + $yi ) == 0 && ( $zr + $zi ) == 0 ) {
			$dirfound = $dir;
			$doorfound = $locdoor;
			last;
		    };
		};
	};
	if ( $dirfound ) {
		return( $dirfound, $doorfound );
	} else {
		return( 0, 0 );
	};
};

#------------------------------------------------------------------------------
# getrooment - get stored entrance position of a room

sub getrooment {
	my ( $room, $xmp, $ymp, $zmp )  = @_;
	my ( $xe, $ye, $ze );

	print "getrooment input room $room at $xmp $ymp $zmp\n" if $debug2;

	# search for door at this location
	my ($found, $locdoor ) = lookupdoor( $xmp, $ymp, $zmp );

	if ( $found ) {
		# lookup parent door field of current door
		my ($srcx, $srcy, $srcz, $srcroom, $srcdoornum, $srcdir, $from, $did, $valid, $doorclass ) = getdoorinfo( $locdoor );

		# lookup parent door info
		($xe, $ye, $ze, $srcroom, $srcdoornum, $srcdir, $from, $did, $valid, $doorclass ) = getdoorinfo( $from );

		# print "getrooment: setprimarydoor door $room at $xe $ye $ze to fromdoor $from\n" if $debug2;
		# print "getrooment " if $debug2;
		# setprimarydoor( $room, $xe, $ye, $ze, $from );
	} else {
		print "getrooment cantfind\n" if $debug2;
		# if we cannot find a door, use the last stored parent door for the room.
		my ( $xc, $yc, $zc, $xs, $ys, $zs );
		( $xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze ) = getroompos( $room );
	};
	print "getrooment: output $xe $ye $ze\n" if $debug2;

	return( $xe, $ye, $ze );
};
#------------------------------------------------------------------------------
# getroompos - get stored position of a room

sub getroompos {
	my $room = $_[0];
	my $xc = $roominfo[$room][0];
	my $yc = $roominfo[$room][1];
	my $zc = $roominfo[$room][2];
	my $xs = $roominfo[$room][3];
	my $ys = $roominfo[$room][4];
	my $zs = $roominfo[$room][5];
	my $xe = $roominfo[$room][6];
	my $ye = $roominfo[$room][7];
	my $ze = $roominfo[$room][8];

	print "getroompos: room $room at $xc $yc $zc size $xs $ys $zs ent $xe $ye $ze\n" if $debug3;

	return( $xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze );
};

#------------------------------------------------------------------------------
# printroominfo - print out room information

sub printroominfo {
	return if $totalrooms == 0;

	open(OUTPUT, ">$fileprefix-info.txt");

	print OUTPUT "Room Information\n\n";

	foreach my $room ( 1 .. $totalrooms ) {
		my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) =
			getroompos( $room );

		my $doorcount = $roominfo[$room][10];
		my $roomspc = $roominfo[$room][11];
		my $segment = getsegment( $xc, $yc, $zc );
		my $bitmapname = $roombitmaps[($roomspc & 0x7f)][0][ 1] if $roomspc & 0x80;

		printf OUTPUT 'Room %3d ', $room;
		printf OUTPUT 'Corner %3d %3d %3d ',$xc,$yc,$zc;
		printf OUTPUT 'Size %2d %2d %2d ',$xs,$ys,$zs;
		# printf OUTPUT 'Enter %3d %3d %3d ',$xe,$ye,$ze;
		printf OUTPUT 'Doors %1d ',$doorcount;

		# my $roomname = $roomclass[$roomspc][0];
		my $roomname = $roominfo[$room][16];
		print OUTPUT "($roomname)";
		# print OUTPUT "($bitmapname)" if ( $roomspc & 0x80 );

		print OUTPUT "\n";
	};
	print OUTPUT "\n";

	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printhallinfo - print out hall information

sub printhallinfo {
	return if $totalhalls == 0;

	open(OUTPUT, ">>$fileprefix-info.txt");

	print OUTPUT "Hallway Information\n\n";

	# print the hall data.
	foreach my $hall ( 1 .. $totalhalls ) {
		my $hallclass = $hallinfo[$hall][0][0];
		my $x = $hallinfo[$hall][0][1];
		my $y = $hallinfo[$hall][0][2];
		my $z = $hallinfo[$hall][0][3];
		my $numdoors = $hallinfo[$hall][0][4];
		my $numcells = $hallinfo[$hall][0][5];

		printf OUTPUT 'Hall %3d ', $hall;
		printf OUTPUT 'Location %3d %3d %3d ', $x, $y, $z;
		printf OUTPUT 'Doors %2d ', $numdoors;
		printf OUTPUT 'Cells %2d ', $numcells;
		print OUTPUT "($hallinfo[$hall][1][0]) " if ( $hallinfo[$hall][1][0] );
		print OUTPUT "\n";
	};
	print OUTPUT "\n";

	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printdoorinfo - print out door information

sub printdoorinfo {
	return if $totaldoors == 0;

	open(OUTPUT, ">>$fileprefix-info.txt");

	print OUTPUT "Door Information\n\n";

	# sort the door array for cleaner output
	# @doorinfo = sort {$a->[0] <=> $b->[0]} @doorinfo; 

	# print the door data.
	foreach my $door ( 1 .. $totaldoors ) {
		my ($x, $y, $z, $room, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );
		next if ! $valid;
		my $dhallid = gethallid( $x, $y, $z );
		printf OUTPUT 'Door ID %3d ', $did;
		printf OUTPUT 'Room %3d ', $room;
		printf OUTPUT 'Door %1d ', $doornum;
		printf OUTPUT 'Location %3d %3d %3d ', $x, $y, $z;
		printf OUTPUT 'Hall %3d ', $dhallid;
		printf OUTPUT 'Direction %1d ', $dir;
		# printf OUTPUT 'DoorID %1d ', $did;
		# printf OUTPUT 'From %1d ', $from;
		print OUTPUT "($doorclass[$doorclass][0]) " if ( $doorclass[$doorclass][0] );
		print OUTPUT "\n";
	};
	print OUTPUT "\n";
};

#------------------------------------------------------------------------------
# printrawdata - print raw maze data

sub printrawdata {
	open(OUTPUT, ">$fileprefix.raw");
	# print the maze information
	print OUTPUT "maze-information ";
	print OUTPUT "SEED=$seed ";
	print OUTPUT "MXS=$xmazesize MYS=$ymazesize MZS=$zmazesize ";
	print OUTPUT "MRXS=$xmaxroom MRYS=$ymaxroom MRZS=$zmaxroom ";
	print OUTPUT "LRXS=$xminroom LRYS=$yminroom LRZS=$zminroom ";
	print OUTPUT "HDV=$highdistval HDX=$xhighdist HDY=$yhighdist HDZ=$zhighdist ";
	# print OUTPUT "MSTX=$ximazestart MSTY=$yimazestart MSTZ=$zimazestart ";
	print OUTPUT "RCNT=$totalrooms DCNT=$totaldoors\n\n";

	my @rspcfnames=( "NVA","NRN","FXZ","IVS","MED","B05","NFL","1DR","TCO","ODP","NRS","DGW","DEX","NSF","BRB","DRD",
			 "RRY","RPL","LFH","TFH","RRH","RFH","RSH","BCO","FRC","ICR","AOC","B27","B28","B29","B30","B31",
			 "B32","B33","B34","B35","B36","B37","B38","B39","B40","B41","B42","B43","B44","B45","B46","B47",
			 "B48","B49","B50","B51","B52","B53","B54","B55","B56","B57","B58","B59","B60","B61","B62","B63" );
	my @dspcfnames=( "HID","TRP","NFL","PRO","SLD","OPN","WKC","STC","GFO","ELO","HZO","DNO","UPO","VTO","DWY","AWY",
			 "R2R","B17","B18","B19","B20","B21","B22","B23","B24","B25","B26","B27","B28","B29","B30","B31" );
	my @lspcfnames=( "NFH","TRP","NXO","NRR","SLR","PNA","NNA","NVA","B08","B09","B10","B11","B12","B13","B14","B15",
			 "B16","B17","B18","B19","B20","B21","B22","B23","B24","B25","B26","B27","B28","B29","B30","B31" );
	my @hspcfnames=( "NVA","TRP","NSP","B03","B04","B05","B06","B07","B08","B09","B10","B11","B12","B13","B14","B15",
			 "B16","B17","B18","B19","B20","B21","B22","B23","B24","B25","B26","B27","B28","B29","B30","B31" );

	# print the level information
	foreach my $level ( 0..$ymazesize-1) {
		my $leveltype = $levelinfo[$level][0];
		print OUTPUT "level-data ";
		print OUTPUT "LVID=$level LVNAME='$levelclass[$leveltype][0]' LCL=$leveltype ";
		print OUTPUT "\n";
	};
	print OUTPUT "\n";

	# print room class data, if any
	if ( $maxroomclass > 0) {
		foreach my $roomclass (0..$maxroomclass) {

			my $roomname		= $roomclass[$roomclass][ 0];
			my $roomminsize		= $roomclass[$roomclass][ 1];
			my $roommaxsize		= $roomclass[$roomclass][ 2];
			my $maxdoors		= $roomclass[$roomclass][ 3];
			my $roomspcflags	= $roomclass[$roomclass][ 4];
			my $roomdfill		= $roomclass[$roomclass][ 5];
			my $nummazerooms	= $roomclass[$roomclass][ 6];
			my $numdungrooms	= $roomclass[$roomclass][ 7];

			print OUTPUT "room-class ";
			print OUTPUT "RCID=$roomclass RCNAME='$roomname' RCMNS='$roomminsize' RCMXS='$roommaxsize' ";
			print OUTPUT "RCMXD=$maxdoors RCNMR=$nummazerooms RCNDR=$numdungrooms ";

			print OUTPUT "RCSF='";
			my $notfirst;
			for my $bit ( 0..63 ) {
		    		my ( $valid_bit, $roomspc_bit) = getroomspcflag( $roomclass, $bit );
				next if ( ! $roomspc_bit );
				print OUTPUT "," if ($notfirst);
				print OUTPUT "$rspcfnames[$bit]";
				$notfirst=1;
			};
			print OUTPUT "' ";

#			print OUTPUT "DCAF='";
#			$notfirst = 0;
#			for my $bit ( 0..31 ) {
#				my $value = (($roomdooraflags>>$bit)&1);
#				next if ( ! $value );
#				print OUTPUT "," if ($notfirst);
#				print OUTPUT "$dspcfnames[$bit]";
#				$notfirst=1;
#			};
#			print OUTPUT "' ";
#
#			print OUTPUT "DCRF='";
#			$notfirst = 0;
#			for my $bit ( 0..31 ) {
#				my $value = (($roomdoorrflags>>$bit)&1);
#				next if ( ! $value );
#				print OUTPUT "," if ($notfirst);
#				print OUTPUT "$dspcfnames[$bit]";
#				$notfirst=1;
#			};
#			print OUTPUT "' ";

			my ( $room_fill, $room_cctr, $room_cnrs, $room_sctr ) = getdoorfillflag( $roomclass );
			print OUTPUT "DCRMF=$room_fill DCRCC=$room_cctr DCRCN=$room_cnrs DCRSC=$room_sctr ";
			print OUTPUT "\n";
		};
		print OUTPUT "\n";
	};

	# print hall class data, if any
	if ( $maxhallclass > 0) {
		foreach my $hallclass (0..$maxhallclass) {

			# skip this class if it is not valid
			next if ! $hallclass[$hallclass][0][0];

			my $hallname		= $hallclass[$hallclass][0][ 0];
			my $hallspcflags	= $hallclass[$hallclass][0][ 1];
			my $hallminfeffect	= $hallclass[$hallclass][0][ 6];
			my $hallmaxfeffect	= $hallclass[$hallclass][0][ 7];
			my $hallcweight		= $hallclass[$hallclass][0][ 8];
			my $hallvhestartodds	= $hallclass[$hallclass][0][16];
			my $hallvhestopodds	= $hallclass[$hallclass][0][17];
			my $halldatasetname	= $hallclass[$hallclass][0][18];

			print OUTPUT "hall-class ";
                        print OUTPUT "HCID=$hallclass HCNAME='$hallname' HDCSNAME='$halldatasetname' ";

			print OUTPUT "HCRF='";
			my $notfirst = 0;
			for my $bit ( 0..31 ) {
				my $value = (($hallspcflags>>$bit)&1);
				next if ( ! $value );
				print OUTPUT "," if ($notfirst);
				print OUTPUT "$hspcfnames[$bit]";
				$notfirst=1;
			};
			print OUTPUT "'\n";
		}
		print OUTPUT "\n";
	};

	# print door class data, if any
	if ( $maxdoorclass > 0) {
		foreach my $doorclass (0..$maxdoorclass) {

			# skip this class if it is not valid
			next if ! $doorclass[$doorclass][0];

			my $doorname		= $doorclass[$doorclass][ 0];
			my $doorspcflags	= $doorclass[$doorclass][ 1];
			my $doorcweight		= $doorclass[$doorclass][ 8];

			print OUTPUT "door-class ";
                        print OUTPUT "DCID=$doorclass DCNAME='$doorname' DCWGT=$doorcweight ";

			print OUTPUT "DCRF='";
			my $notfirst = 0;
			for my $bit ( 0..31 ) {
				my $value = (($doorspcflags>>$bit)&1);
				next if ( ! $value );
				print OUTPUT "," if ($notfirst);
				print OUTPUT "$dspcfnames[$bit]";
				$notfirst=1;
			};
			print OUTPUT "'\n";
		}
		print OUTPUT "\n";
	};

	# print the room data, if any
	if ( $totalrooms > 0 ) {
	    foreach my $room ( 1 .. $totalrooms ) {
		my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) =
			getroompos( $room );
		my $doorcount = $roominfo[$room][10];
		my $roomspc = $roominfo[$room][11];
		my $rmdist = getcelldist( $xe, $ye, $ze);
		print OUTPUT "room-data RNUM=$room RX=$xc RY=$yc RZ=$zc RXS=$xs RYS=$ys RZS=$zs REX=$xe REY=$ye REZ=$ze ";
		print OUTPUT "RDST=$rmdist RDCNT=$doorcount RCL=$roomspc\n";
	    };
	    print OUTPUT "\n";
	};

	# print the hall data, if any.
	if ( $totalhalls > 0 ) {
		foreach my $hall ( 1 .. $totalhalls ) {
			my $hallclass = $hallinfo[$hall][0][0];
			my $x = $hallinfo[$hall][0][1];
			my $y = $hallinfo[$hall][0][2];
			my $z = $hallinfo[$hall][0][3];
			my $numdoors = $hallinfo[$hall][0][4];
			my $numcells = $hallinfo[$hall][0][5];

			print OUTPUT "hall-data HID=$hall HCID=$hallclass HX=$x HY=$y HZ=$z HDCNT=$numdoors HCCNT=$numcells\n";
		};
		print OUTPUT "\n";
	};

	# print the door data, if any.
	if ( $totaldoors > 0 ) {
		foreach my $door ( 1 .. $totaldoors ) {
			my ($x, $y, $z, $roomnum, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );
			next if ! $valid;
			print OUTPUT "door-data DID=$did RNUM=$roomnum DNUM=$doornum RDX=$x RDY=$y RDZ=$z DDIR=$dir FRD=$from DCL=$doorclass\n";
		};
		print OUTPUT "\n";
	};

	# print the cell-level data
	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $zinc (0 .. $zmazesize-1) {
            foreach my $xinc (0 .. $xmazesize-1) {
		my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
			getcellinfo( $xinc, $yinc, $zinc );
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $threadflags = $thrmazegrid[$xinc][$yinc][$zinc];
			my $hall = gethallid( $xinc, $yinc, $zinc );
			my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
			my $fev = getfev( $xinc, $yinc, $zinc );

			print OUTPUT "cell-data X=$xinc Y=$yinc Z=$zinc CB=$backdir CD=$dist FEV=$fev ";
			print OUTPUT "HID=$hall HC=$hclass " if $hall;
			print OUTPUT "CS=$cellspc VHE=$vheflags FL=$feffectlvl FT=$feffecttype CL=$ceffectlvl CT=$ceffecttype SEG=$segment ";

		foreach my $bit ( 32,16,8,4,2,1 ) {
			if (( $segment & $bit ) != 0 ) {
				print OUTPUT "SB$bit=X ";
			} else {
				print OUTPUT "SB$bit=_ ";
			};
		};
		print OUTPUT "PTH=$paths ";
		foreach my $bit ( 32,16,8,4,2,1 ) {
			if (( $paths & $bit ) != 0 ) {
				print OUTPUT "PB$bit=X ";
			} else {
				print OUTPUT "PB$bit=_ ";
			};
		}

		print OUTPUT "THR='";
		my $notfirst = 0;
		for my $bit ( 0..31 ) {
			my $value = (($threadflags>>$bit)&1);
			next if ( ! $value );
			print OUTPUT "," if ($notfirst);
			print OUTPUT "$bit";
			$notfirst=1;
		};
		print OUTPUT "' ";

		my $char = $asciigrid[$xinc*2+1][$yinc][$zinc*2+1];
		print OUTPUT "ASC='$char' ";

		# add the cell adjacency field if it is non-zero
		my $adjval = $adjmazegrid[$xinc][$yinc][$zinc] & 0x07ffffff;
		printf OUTPUT 'ADJ=%027b ', $adjval if $adjval;

		if ( $roomid != 0 ) {
			my $roomspc = getroomspc( $roomid );
			print OUTPUT "RID=$roomid RSPC=$roomspc ";
			my $doorflag = getdoorflag( $xinc, $yinc, $zinc );
			print OUTPUT "doorflag=1 " if $doorflag;
			my $pridoorflag = getpridoorflag( $xinc, $yinc, $zinc );
			print OUTPUT "pridoorflag=1 " if $pridoorflag;
			my $ledgeflag = getledgeflag( $xinc, $yinc, $zinc );
			print OUTPUT "ledgeflag=1 " if $ledgeflag;
		};
		print OUTPUT "\n";
	    };
	  }
	}
	print OUTPUT "\n\n";

	close(OUTPUT);
};

#------------------------------------------------------------------------------
# buildschtemp - output mce object templates of a particular scale
sub buildschtemp {

	open(BOUTPUT, ">$fileprefix-buildtempl.mce");
	open(IOUTPUT, ">$fileprefix-importtempl.mce");
	open(EOUTPUT, ">$fileprefix-exporttempl.mce");

	print BOUTPUT "dimension $mc_dim_template\n";
	print BOUTPUT "log $mc_log_template\n";
	print IOUTPUT "dimension $mc_dim_template\n";
	print IOUTPUT "log $mc_log_template\n";
	print EOUTPUT "dimension $mc_dim_template\n";
	print EOUTPUT "log $mc_log_template\n";

	my $xboxsize = 256;
	my $yboxsize = 127 - $mc_ytoffset;
	my $zboxsize = 256;
	my $ycoordl1 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 0 ));
	my $ycoordl2 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 1 ));
	my $ycoordl3 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 2 ));
	my $ycoordl4 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 3 ));
	my $ycoordl5 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 4 ));
	my $ycoordl6 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 5 ));
	my $scaflvl1 = ( $ycoordl1 + $mc_vscale + 1 );
	my $scaflvl2 = ( $ycoordl2 + $mc_vscale + 1 );
	my $scaflvl3 = ( $ycoordl3 + $mc_vscale + 1 );
	my $scaflvl4 = ( $ycoordl4 + $mc_vscale + 1 );
	my $scaflvl5 = ( $ycoordl5 + $mc_vscale + 1 );
	my $scaflvl6 = ( $ycoordl6 + $mc_vscale + 1 );
	my $scaflvl1a = ( $ycoordl1 + 3 );
	my $scaflvl2a = ( $ycoordl2 + 3 );
	my $scaflvl3a = ( $ycoordl3 + 3 );
	my $scaflvl4a = ( $ycoordl4 + 3 );
	my $scaflvl5a = ( $ycoordl5 + 3 );
	my $scaflvl6a = ( $ycoordl6 + 3 );

	# get dataset info
	my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
		$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( $defaultset );

	print "tfa $tfa bfa $bfa tsa $tsa bsa $bsa mfa $mfa msa $msa hcs $hcs hcf $hcf hfs $hfs hff $hff\n" if ( $debug2 );

	# adjust dataset path if alternate build is requested
	if ( $buildalt ) {
		$defaultset = "$defaultset/alt";
	};

	# adjust dataset info if FEV offset is requested
	if ( $buildfev ) {
		$ffs += $buildfev;
		$cfs -= $buildfev;
		$cfs = 0 if ( $cfs < 0 );
		$defaultset = "$defaultset/fev$buildfev";
	};

	if (( $vco + $ffs + $fss + $buildfev ) > int( $mc_vscale / 2 )) {
		print "Warning: Overall floor thickness will break VHE half-block functionality\n"
	};
	if (( $vco + $cfs + $css ) > int( $mc_vscale / 2 )) {
		print "Warning: Overall ceiling thickness will break VHE half-block functionality\n"
	};

	my $wallthick = $hco + $wss + $wfs;
	my $hallwidth = $mc_hscale - ( $wallthick * 2 );

	# clear area
	print BOUTPUT "fill 0 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print IOUTPUT "fill 0 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";

	# Add glass layers for scaffolding
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl1 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl2 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl3 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl4 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl5 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl6 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl1a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl2a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl3a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl4a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl5a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print BOUTPUT "fill 20 $mc_xtoffset $scaflvl6a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl1 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl2 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl3 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl4 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl5 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl6 $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl1a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl2a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl3a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl4a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl5a $mc_ztoffset $xboxsize 1 $zboxsize\n";
	print IOUTPUT "fill 20 $mc_xtoffset $scaflvl6a $mc_ztoffset $xboxsize 1 $zboxsize\n";

	# convert placeholder materials to flowing materials for exporting
	print EOUTPUT "replace 21 with 9 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 22 with 8 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 88 with 10 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 87 with 11 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";

	#------------------------------------------------------------------------------
	# build room segments
	#
	foreach my $seg ( 0..63 ) {
		my $hseg = ( $seg & 15 );
		my $vseg = ( ($seg & 48)>>4 );

		# coordinate of corner of object
		my $xcoord = ($mc_xtoffset + ($hseg * ($mc_hscale + 3)) + 3 );
		my $ycoord = $ycoordl1 + 1;
		my $zcoord = ($mc_ztoffset + (($vseg + 5) * ($mc_hscale + 3)) + 3 );
		my $zwcoord = ($mc_ztoffset + (($vseg + 9) * ($mc_hscale + 3)) + 3 );

		#------------------------------------------------------------------------------
		# room segments

		# base room coordinates
		my ( $xrc, $yrc, $zrc, $xrs, $yrs, $zrs ) = ( $xcoord, $ycoord, $zcoord, $mc_hscale, $mc_vscale, $mc_hscale );

		# output import/export lines
		print EOUTPUT "export $mc_schemroot/$defaultset/r$seg.schematic $xrc $yrc $zrc $xrs $yrs $zrs\n" if ( $seg );
		print IOUTPUT "import $mc_schemroot/$defaultset/r$seg.schematic $xrc $yrc $zrc\n" if ( $seg );

		# output solid base material block
		print BOUTPUT "fill $cmt $xrc $yrc $zrc $xrs $yrs $zrs\n";

		# insert glass base under material blocks
		print BOUTPUT "fill 20 $xrc $ycoordl1 $zrc $xrs 1 $zrs\n";
		print IOUTPUT "fill 20 $xrc $ycoordl1 $zrc $xrs 1 $zrs\n";

		# leave core walls where required
		$xrs -= $hco if ( $seg & 1 );
		$xrc += $hco if ( $seg & 1 );
		$xrs -= $hco if ( $seg & 2 );
		$zrs -= $hco if ( $seg & 4 );
		$zrc += $hco if ( $seg & 4 );
		$zrs -= $hco if ( $seg & 8 );
		$yrs -= $vco if ( $seg & 16 );
		$yrs -= $vco if ( $seg & 32 );
		$yrc += $vco if ( $seg & 32 );

		for my $order ( "wf", "cf", "ff", "ws", "cs", "fs", "op" ) {
		    if ( $order eq "wf" ) {

			# output wall fill block
			print BOUTPUT "fill $wft $xrc $yrc $zrc $xrs $yrs $zrs\n";

			# leave wall fill layers
			$xrs -= $wfs if ( $seg & 1 );
			$xrc += $wfs if ( $seg & 1 );
			$xrs -= $wfs if ( $seg & 2 );
			$zrs -= $wfs if ( $seg & 4 );
			$zrc += $wfs if ( $seg & 4 );
			$zrs -= $wfs if ( $seg & 8 );

		    } elsif ( $order eq "ws" ) {

			# output wall surface block
			print BOUTPUT "fill $wst $xrc $yrc $zrc $xrs $yrs $zrs\n";

			# leave wall surface layers
			$xrs -= $wss if ( $seg & 1 );
			$xrc += $wss if ( $seg & 1 );
			$xrs -= $wss if ( $seg & 2 );
			$zrs -= $wss if ( $seg & 4 );
			$zrc += $wss if ( $seg & 4 );
			$zrs -= $wss if ( $seg & 8 );

		    } elsif ( $order eq "cf" ) {

			# output ceiling fill block
			print BOUTPUT "fill $cft $xrc $yrc $zrc $xrs $yrs $zrs\n";

			# leave ceiling fill layers
			$yrs -= $cfs if ( $seg & 16 );

		    } elsif ( $order eq "ff" ) {

			# output floor fill block
			print BOUTPUT "fill $fft $xrc $yrc $zrc $xrs $yrs $zrs\n";

			# leave floor fill layers
			$yrs -= $ffs if ( $seg & 32 );
			$yrc += $ffs if ( $seg & 32 );

		    } elsif ( $order eq "cs" ) {

			# output ceiling surface block
			print BOUTPUT "fill $cst $xrc $yrc $zrc $xrs $yrs $zrs\n";

			# leave ceiling surface layers
			$yrs -= $css if ( $seg & 16 );

		    } elsif ( $order eq "fs" ) {

			# output floor surface block
			print BOUTPUT "fill $fst $xrc $yrc $zrc $xrs $yrs $zrs\n";

			# leave floor surface layers
			$yrs -= $fss if ( $seg & 32 );
			$yrc += $fss if ( $seg & 32 );

		    } elsif ( $order eq "op" ) {

			# output room opening
			print BOUTPUT "fill $omt $xrc $yrc $zrc $xrs $yrs $zrs\n";

		    } elsif ( $order eq "l1" ) {

			# add optional room corner lighting
			my $W = ( $xcoord + $hco + $wfs + $wss - 2 );
			my $E = ( $xcoord + $mc_hscale - $hco - $wfs - $wss - 1 );
			my $N = ( $zcoord + $hco + $wfs + $wss - 2 );
			my $S = ( $zcoord + $mc_hscale - $hco - $wfs - $wss - 1 );
			my $B = $ycoord + $vco + $ffs + $fss + 1;
			print BOUTPUT "import $mc_schemroot/misc/insidecornertorch-nw.schematic $W $B $N\n" if (( $seg & (32+1+4)) == (32+1+4));
			print BOUTPUT "import $mc_schemroot/misc/insidecornertorch-ne.schematic $E $B $N\n" if (( $seg & (32+2+4)) == (32+2+4));
			print BOUTPUT "import $mc_schemroot/misc/insidecornertorch-sw.schematic $W $B $S\n" if (( $seg & (32+1+8)) == (32+1+8));
			print BOUTPUT "import $mc_schemroot/misc/insidecornertorch-se.schematic $E $B $S\n" if (( $seg & (32+2+8)) == (32+2+8));

		    } elsif ( $order eq "l4" ) {

			# add optional room corner lighting
			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zcoord );
			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_nw.schematic $X $Y $Z noair\n" if (( $seg & (16+1+4)) == (16+1+4));
			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_ne.schematic $X $Y $Z noair\n" if (( $seg & (16+2+4)) == (16+2+4));
			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_sw.schematic $X $Y $Z noair\n" if (( $seg & (16+1+8)) == (16+1+8));
			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_se.schematic $X $Y $Z noair\n" if (( $seg & (16+2+8)) == (16+2+8));

		    } elsif ( $order eq "gh" ) {

			# one-off: add ceiling lighting for the grandhall dataset class
			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zcoord );
			print BOUTPUT "import $mc_schemroot/misc/grandhall-clighting.schematic $X $Y $Z noair\n" if ($seg & 16 );

		    } elsif ( $order eq "ic" ) {

			my $B = $ycoord + $vco + $ffs + $fss;
			# print BOUTPUT "replace 0 with 78 $xcoord $B $zcoord $mc_hscale 1 $mc_hscale\n" if ( $seg & 32 );
		    };
		};

#		#------------------------------------------------------------------------------
#		# hallway segments
#
#		my ( $ew_xhc, $ew_yhc, $ew_zhc, $ew_xhs, $ew_yhs, $ew_zhs ) = ( $xcoord, $ycoord, $zwcoord, $mc_hscale, $mc_vscale, $mc_hscale );
#		my ( $ns_xhc, $ns_yhc, $ns_zhc, $ns_xhs, $ns_yhs, $ns_zhs ) = ( $xcoord, $ycoord, $zwcoord, $mc_hscale, $mc_vscale, $mc_hscale );
#		my ( $dn_xhc, $dn_yhc, $dn_zhc, $dn_xhs, $dn_yhs, $dn_zhs ) = ( $xcoord, $ycoord, $zwcoord, $mc_hscale, 0, $mc_hscale );
#		my ( $up_xhc, $up_yhc, $up_zhc, $up_xhs, $up_yhs, $up_zhs ) = ( $xcoord, $ycoord+$mc_vscale, $zwcoord, $mc_hscale, 0, $mc_hscale );
#
#		# output import/export lines
#		print EOUTPUT "export $mc_schemroot/$defaultset/h$seg.schematic $xcoord $ycoord $zwcoord $mc_hscale $mc_vscale $mc_hscale\n";
#		print IOUTPUT "import $mc_schemroot/$defaultset/h$seg.schematic $xcoord $ycoord $zwcoord\n";
#
#		# output solid base material block
#		print BOUTPUT "fill $cmt $xcoord $ycoord $zwcoord $mc_hscale $mc_vscale $mc_hscale\n";
#
#		# add glass base layer
#		print BOUTPUT "fill 20 $xcoord $ycoordl1 $zwcoord $mc_hscale 1 $mc_hscale\n";
#		print IOUTPUT "fill 20 $xcoord $ycoordl1 $zwcoord $mc_hscale 1 $mc_hscale\n";
#
#		# provide initial box adjustments for core wall thickness and opening constrictions
#		# ...east-west box
#		$ew_yhc += $vco;
#		$ew_zhc += $hco;
#		$ew_yhs -= ( $vco * 2 );
#		$ew_zhs -= ( $hco * 2 );
#		# ...north-south box
#		$ns_xhc += $hco;
#		$ns_yhc += $vco;
#		$ns_xhs -= ( $hco * 2 );
#		$ns_yhs -= ( $vco * 2 );
#		# ...down box
#		$dn_xhc += ( $hco + $oco);
#		$dn_zhc += ( $hco + $oco);
#		$dn_xhs -= ( ($hco + $oco) * 2 );
#		$dn_zhs -= ( ($hco + $oco) * 2 );
#		$dn_yhs += ( $vco + $ffs + $fss );
#		# ...up box
#		$up_xhc += ( $hco + $oco);
#		$up_zhc += ( $hco + $oco);
#		$up_xhs -= ( ($hco + $oco) * 2 );
#		$up_zhs -= ( ($hco + $oco) * 2 );
#		$up_yhs += ( $vco + $cfs + $css );
#		$up_yhc -= ( $vco + $cfs + $css );
#
#		# leave core walls if required
#		$ew_xhs -= $hco if ( $seg & 1 );
#		$ew_xhc += $hco if ( $seg & 1 );
#		$ew_xhs -= $hco if ( $seg & 2 );
#		$ns_zhs -= $hco if ( $seg & 4 );
#		$ns_zhc += $hco if ( $seg & 4 );
#		$ns_zhs -= $hco if ( $seg & 8 );
#		$up_yhs -= $vco if ( $seg & 16 );
#		$dn_yhs -= $vco if ( $seg & 32 );
#		$dn_yhc += $vco if ( $seg & 32 );
#
#		my $lightbase = $ycoord;
#		
#		foreach my $order ( "wf", "cf", "ff", "ws", "vs", "cs", "fs", "op" ) {
#		    if ( $order eq "wf" ) {
#
#			# output wall fill block
#			print BOUTPUT "fill $wft $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $wft $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#
#			# leave wall fill layers in front of solid core walls
#			$ew_xhs -= $wfs if ( $seg & 1 );
#			$ew_xhc += $wfs if ( $seg & 1 );
#			$ew_xhs -= $wfs if ( $seg & 2 );
#			$ns_zhs -= $wfs if ( $seg & 4 );
#			$ns_zhc += $wfs if ( $seg & 4 );
#			$ns_zhs -= $wfs if ( $seg & 8 );
#
#			# narrow horizontal fill blocks
#			$ew_zhs -= $wfs;
#			$ew_zhc += $wfs;
#			$ew_zhs -= $wfs;
#			$ns_xhs -= $wfs;
#			$ns_xhc += $wfs;
#			$ns_xhs -= $wfs;
#
#		    } elsif ( $order eq "ws" ) {
#
#			# output wall surface block
#			print BOUTPUT "fill $wst $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $wst $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#
#			# leave wall surface layers in front of solid fill walls
#			$ew_xhs -= $wss if ( $seg & 1 );
#			$ew_xhc += $wss if ( $seg & 1 );
#			$ew_xhs -= $wss if ( $seg & 2 );
#			$ns_zhs -= $wss if ( $seg & 4 );
#			$ns_zhc += $wss if ( $seg & 4 );
#			$ns_zhs -= $wss if ( $seg & 8 );
#
#			# narrow horizontal wall surface blocks
#			$ew_zhs -= $wss;
#			$ew_zhc += $wss;
#			$ew_zhs -= $wss;
#			$ns_xhs -= $wss;
#			$ns_xhc += $wss;
#			$ns_xhs -= $wss;
#
#		    } elsif ( $order eq "cf" ) {
#
#			# output ceiling fill block
#			print BOUTPUT "fill $cft $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $cft $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#
#			# leave ceiling fill layer
#			$ew_yhs -= $cfs;
#			$ns_yhs -= $cfs;
#			$up_yhs -= $cfs if ( $seg & 16 );
#		
#		    } elsif ( $order eq "ff" ) {
#
#			# output floor fill block
#			print BOUTPUT "fill $fft $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $fft $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#
#			# leave floor fill layer
#			$ew_yhs -= $ffs;
#			$ns_yhs -= $ffs;
#			$ew_yhc += $ffs;
#			$ns_yhc += $ffs;
#			$dn_yhs -= $ffs if ( $seg & 32 );
#			$dn_yhc += $ffs if ( $seg & 32 );
#
#		    } elsif ( $order eq "vs" ) {
#
#			# output floor surface blocks for vertical opening areas
#			print BOUTPUT "fill $fst $up_xhc $up_yhc $up_zhc $up_xhs $up_yhs $up_zhs\n" if (( $seg & 16 ) == 0 );
#			print BOUTPUT "fill $fst $dn_xhc $dn_yhc $dn_zhc $dn_xhs $dn_yhs $dn_zhs\n" if (( $seg & 32 ) == 0 );
#
#			# narrow vertical opening
#			$up_xhc += 1;
#			$up_zhc += 1;
#			$up_xhs -= 2;
#			$up_zhs -= 2;
#			$dn_xhc += 1;
#			$dn_zhc += 1;
#			$dn_xhs -= 2;
#			$dn_zhs -= 2;
#		
#		    } elsif ( $order eq "cs" ) {
#
#			# output ceiling surface block
#			print BOUTPUT "fill $cst $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $cst $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#
#			# leave ceiling surface layer
#			$ew_yhs -= $css;
#			$ns_yhs -= $css;
#			$up_yhs -= $css if ( $seg & 16 );
#		
#		    } elsif ( $order eq "fs" ) {
#
#			# output floor surface block
#			print BOUTPUT "fill $fst $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $fst $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#
#			# output floor surface blocks for vertical opening areas
#			print BOUTPUT "fill $fst $dn_xhc $dn_yhc $dn_zhc $dn_xhs $dn_yhs $dn_zhs\n" if (( $seg & 32 ) == 0 );
#			print BOUTPUT "fill $fst $up_xhc $up_yhc $up_zhc $up_xhs $up_yhs $up_zhs\n" if (( $seg & 16 ) == 0 );
#
#			$lightbase = $ew_yhc;
#
#			# leave floor surface layer
#			$ew_yhs -= $fss;
#			$ns_yhs -= $fss;
#			$ew_yhc += $fss;
#			$ns_yhc += $fss;
#			$dn_yhs -= $fss if ( $seg & 32 );
#			$dn_yhc += $fss if ( $seg & 32 );
#
#		    } elsif ( $order eq "op" ) {
#
#			# output hall openings
#			print BOUTPUT "fill $omt $ew_xhc $ew_yhc $ew_zhc $ew_xhs $ew_yhs $ew_zhs\n";
#			print BOUTPUT "fill $omt $ns_xhc $ns_yhc $ns_zhc $ns_xhs $ns_yhs $ns_zhs\n";
#			print BOUTPUT "fill $omt $up_xhc $up_yhc $up_zhc $up_xhs $up_yhs $up_zhs\n" if (( $seg & 16 ) == 0 );
#			print BOUTPUT "fill $omt $dn_xhc $dn_yhc $dn_zhc $dn_xhs $dn_yhs $dn_zhs\n" if (( $seg & 32 ) == 0 );
#
#		    } elsif ( $order eq "dr" ) {
#
#			# one-off: output center tunnel split to double-rail hallway
#			if ( $vseg & 3 == 3 ) {
#		 		my $half = ( ($mc_hscale / 2) + 1);
#				my $zhalfstart = $zwcoord + (( $mc_hscale / 2) - 1);
#				my $xhalfstart = $xcoord + (( $mc_hscale / 2) - 1);
#				# my $cwstart = $ew_yhc;
#				# my $cwheight = $ew_yhs + 1;
#				my $cwstart = $ycoord;
#				my $cwheight = $mc_hscale;
#				print BOUTPUT "fill 7 $xcoord $cwstart $zhalfstart $half $cwheight 2\n" if (( $seg & 1 ) == 0 );
#				print BOUTPUT "fill 7 $xhalfstart $cwstart $zhalfstart $half $cwheight 2\n" if (( $seg & 2 ) == 0 );
#				print BOUTPUT "fill 7 $xhalfstart $cwstart $zwcoord 2 $cwheight $half\n" if (( $seg & 4 ) == 0 );
#				print BOUTPUT "fill 7 $xhalfstart $cwstart $zhalfstart 2 $cwheight $half\n" if (( $seg & 8 ) == 0 );
#
#				# add track segments to floor
#				my ( $W, $E, $N, $S, $B ) = ( $xcoord, $xhalfstart, $zwcoord, $zhalfstart, $ew_yhc - 1 );
#				print BOUTPUT "# dr track $seg\n";
#				print BOUTPUT "import $mc_schemroot/misc/track-se.schematic $W $B $N noair\n" if (( $seg & (1 + 4)) == 5 );
#				print BOUTPUT "import $mc_schemroot/misc/track-nw.schematic $W $B $N noair\n" if (( $seg & (1 + 4)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ns-s.schematic $W $B $N noair\n" if (( $seg & (1 + 4)) == 1 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ew-w.schematic $W $B $N noair\n" if (( $seg & (1 + 4)) == 4 );
#
#				print BOUTPUT "import $mc_schemroot/misc/track-sw.schematic $E $B $N noair\n" if (( $seg & (2 + 4)) == 6 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ne.schematic $E $B $N noair\n" if (( $seg & (2 + 4)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ns-n.schematic $E $B $N noair\n" if (( $seg & (2 + 4)) == 2 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ew-w.schematic $E $B $N noair\n" if (( $seg & (2 + 4)) == 4 );
#
#				print BOUTPUT "import $mc_schemroot/misc/track-ne.schematic $W $B $S noair\n" if (( $seg & (1 + 8)) == 9 );
#				print BOUTPUT "import $mc_schemroot/misc/track-sw.schematic $W $B $S noair\n" if (( $seg & (1 + 8)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ns-s.schematic $W $B $S noair\n" if (( $seg & (1 + 8)) == 1 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ew-e.schematic $W $B $S noair\n" if (( $seg & (1 + 8)) == 8 );
#
#				print BOUTPUT "import $mc_schemroot/misc/track-nw.schematic $E $B $S noair\n" if (( $seg & (2 + 8)) == 10 );
#				print BOUTPUT "import $mc_schemroot/misc/track-se.schematic $E $B $S noair\n" if (( $seg & (2 + 8)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ns-n.schematic $E $B $S noair\n" if (( $seg & (2 + 8)) == 2 );
#				print BOUTPUT "import $mc_schemroot/misc/track-ew-e.schematic $E $B $S noair\n" if (( $seg & (2 + 8)) == 8 );
#			};
#
#		    } elsif ( $order eq "lc" ) {
#
#			# one-off: output walkway for lava canal
#		 	my $half = (($mc_hscale / 2) + 1);
#			my $zhalfstart = $zwcoord + (( $mc_hscale / 2) - 1);
#			my $zctrstart = $zwcoord + (( $mc_hscale / 2) - 2);
#			my $ystart = $ycoord + 3;
#			my $xhalfstart = $xcoord + (( $mc_hscale / 2) - 1);
#			my $xctrstart = $xcoord + (( $mc_hscale / 2) - 2);
#			print BOUTPUT "# segment $seg vseg $vseg hseg $hseg\n";
#
#			if (($seg & 12) == 12) {
#				# down access from ew straight walkways
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ewd.schematic $xctrstart $ystart $zctrstart\n" if ($vseg == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ewd.schematic $xctrstart $ystart $zctrstart\n" if ($vseg == 1 );
#			};
#			if (($seg & 3) == 3) {
#				# down access from ns straight walkways
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-nsd.schematic $xctrstart $ystart $zctrstart\n" if ($vseg == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-nsd.schematic $xctrstart $ystart $zctrstart\n" if ($vseg == 1 );
#			};
#
#			# walkway paths
#			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ew.schematic $xcoord $ystart $zhalfstart\n"if ( ($seg & 1) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ew.schematic $xhalfstart $ystart $zhalfstart\n" if ( ($seg & 2) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ns.schematic $xhalfstart $ystart $zwcoord\n" if ( ($seg & 4) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ns.schematic $xhalfstart $ystart $zhalfstart\n" if ( ($seg & 8) == 0 );
#
#			# 3-way/4-way/corner segments only
#			if ( ($seg & 3) != 3 && ($seg & 12) != 12 ) {
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-cd.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-cd.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 1 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-c.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 2 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-c.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 3 );
#			};
#			# dead-ends only
#			if ( $hseg == 7 || $hseg == 11 || $hseg == 13 || $hseg == 14 || $hseg == 15 ) {
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-cd.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-cd.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 1 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-c.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 2 );
#				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-c.schematic $xctrstart $ystart $zctrstart\n" if ( $vseg == 3 );
#			};
#
#		    } elsif ( $order eq "l1" ) {
#
#			# one-off: add optional lighting to generic hallway
#			my ( $W, $E, $N, $S, $B ) = ( $ns_xhc - 1, $ns_xhc + $ns_xhs, $ew_zhc - 1, $ew_zhc + $ew_zhs, $ew_yhc );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $W $B $N\n" if (( $seg & (1 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $E $B $N\n" if (( $seg & (2 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $W $B $S\n" if (( $seg & (1 + 8)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $E $B $S\n" if (( $seg & (2 + 8)) == 0 );
#
#		    } elsif ( $order eq "l2" ) {
#		
#			# one-off: add optional lighting to canal hallway
#			my ( $W, $E, $N, $S, $B ) = ( $ns_xhc - 2, $ns_xhc + $ns_xhs, $ew_zhc - 2, $ew_zhc + $ew_zhs, $lightbase );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-nw.schematic $W $B $N\n" if (( $seg & (1 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-ne.schematic $E $B $N\n" if (( $seg & (2 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-sw.schematic $W $B $S\n" if (( $seg & (1 + 8)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-se.schematic $E $B $S\n" if (( $seg & (2 + 8)) == 0 );
#
#		    } elsif ( $order eq "l3" ) {
#		
#			# one-off: add optional lighting to generic hallway (alternate design)
#			my ( $W, $E, $N, $S, $B ) = ( $ns_xhc - 2, $ns_xhc + $ns_xhs, $ew_zhc - 2, $ew_zhc + $ew_zhs, $lightbase );
#			print BOUTPUT "import $mc_schemroot/misc/sandstonecornertorch-nw.schematic $W $B $N\n" if (( $seg & (1 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstonecornertorch-ne.schematic $E $B $N\n" if (( $seg & (2 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstonecornertorch-sw.schematic $W $B $S\n" if (( $seg & (1 + 8)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstonecornertorch-se.schematic $E $B $S\n" if (( $seg & (2 + 8)) == 0 );
#
#		    } elsif ( $order eq "l4" ) {
#
#			# add optional room corner lighting
#			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zcoord );
#			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_nw.schematic $X $Y $Z noair\n" if (( $seg & (16+1+4)) == (16+1+4));
#			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_ne.schematic $X $Y $Z noair\n" if (( $seg & (16+2+4)) == (16+2+4));
#			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_sw.schematic $X $Y $Z noair\n" if (( $seg & (16+1+8)) == (16+1+8));
#			print BOUTPUT "import $mc_schemroot/misc/generic_room_lighting_se.schematic $X $Y $Z noair\n" if (( $seg & (16+2+8)) == (16+2+8));
#
#		    } elsif ( $order eq "gh" ) {
#
#			# one-off: add ceiling lighting and decoration for the grandhall dataset class
#			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zwcoord );
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-w.schematic $X $Y $Z noair\n" if ( $seg & 1);
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-e.schematic $X $Y $Z noair\n" if ( $seg & 2);
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-n.schematic $X $Y $Z noair\n" if ( $seg & 4);
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-s.schematic $X $Y $Z noair\n" if ( $seg & 8);
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-w.schematic $X $Y $Z noair\n" if ( ! ( $seg & 1));
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-e.schematic $X $Y $Z noair\n" if ( ! ( $seg & 2));
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-n.schematic $X $Y $Z noair\n" if ( ! ( $seg & 4));
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-s.schematic $X $Y $Z noair\n" if ( ! ( $seg & 8));
#			print BOUTPUT "import $mc_schemroot/misc/grandhall-clighting.schematic $X $Y $Z noair\n" if ($seg & 16 );
#
#		    } elsif ( $order eq "cu" ) {
#
#			# one-off: add arch decoration to upper-canal dataset class
#			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zwcoord );
#			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-w.schematic $X $Y $Z noair\n" if ( ! ( $seg & 1));
#			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-e.schematic $X $Y $Z noair\n" if ( ! ( $seg & 2));
#			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-n.schematic $X $Y $Z noair\n" if ( ! ( $seg & 4));
#			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-s.schematic $X $Y $Z noair\n" if ( ! ( $seg & 8));
#
#		    } elsif ( $order eq "cl" ) {
#
#			# one-off: add beam decoration and passage cutouts to lower-canal dataset class
#			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zwcoord );
#			# add beam design
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-w.schematic $X $Y $Z noair\n" if ( ! ( $seg & 1));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-e.schematic $X $Y $Z noair\n" if ( ! ( $seg & 2));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-n.schematic $X $Y $Z noair\n" if ( ! ( $seg & 4));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-s.schematic $X $Y $Z noair\n" if ( ! ( $seg & 8));
#
#			# add passage cutout in walls
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-w.schematic $X $Y $Z noair\n" if ( $seg & 1);
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-e.schematic $X $Y $Z noair\n" if ( $seg & 2);
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-n.schematic $X $Y $Z noair\n" if ( $seg & 4);
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-s.schematic $X $Y $Z noair\n" if ( $seg & 8);
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y $Z noair\n" if ( ! ( $seg & 1));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y $Z noair\n" if ( ! ( $seg & 2));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y $Z noair\n" if ( ! ( $seg & 4));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y $Z noair\n" if ( ! ( $seg & 8));
#
#		    } elsif ( $order eq "ci" ) {
#
#			# one-off: add beam decoration to canal dataset class
#			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zwcoord );
#			# add beam design
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-w.schematic $X $Y $Z noair\n" if ( ! ( $seg & 1));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-e.schematic $X $Y $Z noair\n" if ( ! ( $seg & 2));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-n.schematic $X $Y $Z noair\n" if ( ! ( $seg & 4));
#			print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-s.schematic $X $Y $Z noair\n" if ( ! ( $seg & 8));
#
#			# add optional lighting to canal hallway
#
#			print BOUTPUT "import $mc_schemroot/misc/canal-light-nw.schematic $X $Y $Z noair\n" if (( $seg & (1 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canal-light-ne.schematic $X $Y $Z noair\n" if (( $seg & (2 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canal-light-sw.schematic $X $Y $Z noair\n" if (( $seg & (1 + 8)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canal-light-se.schematic $X $Y $Z noair\n" if (( $seg & (2 + 8)) == 0 );
#
#		    } elsif ( $order eq "llc" ) {
#
#			# one-off: add walkways to lower lava canal dataset class
#			my ( $X, $Y, $Z ) = ( $xcoord, $ycoord, $zwcoord );
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-w.schematic $X $Y $Z noair\n" if ( $seg & 1);
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-e.schematic $X $Y $Z noair\n" if ( $seg & 2);
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-n.schematic $X $Y $Z noair\n" if ( $seg & 4);
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-s.schematic $X $Y $Z noair\n" if ( $seg & 8);
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-w.schematic $X $Y $Z noair\n" if ( ! ( $seg & 1));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-e.schematic $X $Y $Z noair\n" if ( ! ( $seg & 2));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-n.schematic $X $Y $Z noair\n" if ( ! ( $seg & 4));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-s.schematic $X $Y $Z noair\n" if ( ! ( $seg & 8));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-nw.schematic $X $Y $Z noair\n" if (( $seg & (1+4)) == (1+4));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-ne.schematic $X $Y $Z noair\n" if (( $seg & (2+4)) == (2+4));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-sw.schematic $X $Y $Z noair\n" if (( $seg & (1+8)) == (1+8));
#			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-se.schematic $X $Y $Z noair\n" if (( $seg & (2+8)) == (2+8));
#
#		    } elsif ( $order eq "ic" ) {
#			my $B = $ycoord + $vco + $ffs + $fss;
#			# print BOUTPUT "replace 0 with 78 $xcoord $B $zwcoord $mc_hscale 1 $mc_hscale\n";
#
#		    };
#		};
	};

	#------------------------------------------------------------------------------
	# updated build vhe segments

	# initialize variables
	my ( $yhs1, $yhs2, $ycs1, $ycs2 ) = ( 0, $mc_vscale, 0, $mc_vscale );
	my ( $hw1, $hw2, $hw3, $cw1, $cw2, $cw3 ) = ( $mc_hscale, $mc_hscale, $mc_hscale, $mc_hscale, $mc_hscale, $mc_hscale );

	my ( $b4_valid, $b4_dsflag) = getdatasetflag( $dsname, 4 );
	my ( $b5_valid, $b5_dsflag) = getdatasetflag( $dsname, 5 );
	my ( $b6_valid, $b6_dsflag) = getdatasetflag( $dsname, 6 );
	my ( $b7_valid, $b7_dsflag) = getdatasetflag( $dsname, 7 );

	foreach my $order ( "bf", "cf", "ff", "wf", "cs", "ws", "fs", "op" ) {
		if ( $order eq "bf" ) {

			# output core fill block
			printvhefills ( $cmt, $cmt, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for core thicknesses
			$hw1 -= ( $hco * 2 );
			$hw2 -= ( $hco * 2 );
			$hw3 -= ( $hco * 2 );
			$cw1 -= ( $hco * 2 );
			$cw2 -= ( $hco * 2 );
			$cw3 -= ( $hco * 2 );
			$yhs1 += ( $vco );
			$yhs2 -= ( $vco * 2 );
			$ycs1 += ( $vco );
			$ycs2 -= ( $vco * 2 );

		} elsif ( $order eq "cf" ) {

			my $dcft = $cft;
			$dcft = $wst if ( $b7_dsflag );

			# output ceiling fill block
			printvhefills ( $cft, $dcft, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for thickness
			$yhs2 -= ( $cfs + $hcf );
			$ycs2 -= $cfs;

		} elsif ( $order eq "ff" ) {

			my $dfft = $fft;
			$dfft = $wst if ( $b6_dsflag );

			# output floor fill block
			printvhefills ( $fft, $dfft, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for thickness
			$yhs1 += ( $ffs + $hff );
			$yhs2 -= ( $ffs + $hff );
			$ycs1 += $ffs;
			$ycs2 -= $ffs;

		} elsif ( $order eq "wf" ) {

			# output wall fill block
			printvhefills ( $wft, $wft, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for thickness
			if ( $bfa >= $mfa ) {
				$hw1 -= ( ( $wfs * 2 ) + ( $bfa * 2 ) );
			} else {
				$hw1 -= ( ( $wfs * 2 ) + ( $mfa * 2 ) );
			};
			$hw2 -= ( ( $wfs * 2 ) + ( $mfa * 2 ) );
			if ( $tfa >= $mfa ) {
				$hw3 -= ( ( $wfs * 2 ) + ( $tfa * 2 ) );
			} else {
				$hw3 -= ( ( $wfs * 2 ) + ( $mfa * 2 ) );
			};
			$cw1 -= ( ( $wfs * 2 ) + ( $bfa * 2 ) );
			$cw2 -= ( $wfs * 2 );
			$cw3 -= ( ( $wfs * 2 ) + ( $tfa * 2 ) );

		} elsif ( $order eq "cs" ) {

			my $dcst = $cst;
			$dcst = $wst if ( $b7_dsflag );

			# output ceiling surface blocks
			printvhefills ( $cst, $dcst, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for thickness
			$yhs2 -= ( $css + $hcs );
			$ycs2 -= $css;

		} elsif ( $order eq "fs" ) {

			my $dfst = $fst;
			$dfst = $wst if ( $b6_dsflag );

			# output floor surface blocks
			printvhefills ( $fst, $dfst, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for thickness
			$yhs1 += ( $fss + $hfs );
			$yhs2 -= ( $fss + $hfs );
			$ycs1 += $fss;
			$ycs2 -= $fss;

		} elsif ( $order eq "ws" ) {

			# output wall surface blocks
			printvhefills ( $wst, $wst, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );

			# adjust for thickness
			if ( $bsa >= $msa ) {
				$hw1 -= ( ( $wss * 2 ) + ( $bsa * 2 ) );
			} else {
				$hw1 -= ( ( $wss * 2 ) + ( $msa * 2 ) );
			};
			$hw2 -= ( ( $wss * 2 ) + ( $msa * 2 ) );
			if ( $tsa >= $msa ) {
				$hw3 -= ( ( $wss * 2 ) + ( $tsa * 2 ) );
			} else {
				$hw3 -= ( ( $wss * 2 ) + ( $msa * 2 ) );
			};
			$cw1 -= ( ( $wss * 2 ) + ( $bsa * 2 ) );
			$cw2 -= ( $wss * 2 );
			$cw3 -= ( ( $wss * 2 ) + ( $tsa * 2 ) );

		} elsif ( $order eq "op" ) {

			# output wall openings
			printvhefills ( $omt, $omt, $yhs1, $yhs2, $ycs1, $ycs2, $hw1, $hw2, $hw3, $cw1, $cw2, $cw3, $b4_dsflag, $b5_dsflag );
		};
	};

	#------------------------------------------------------------------------------
	# build vhe segments

	foreach my $seg ( 0..80 ) {
		my $hseg = ( $seg & 15 );
		my $vseg = ( ($seg & 112)>>4 );

		# determine primary/secondary/combined segment IDs.
		my ( $psegid, $ssegid ) = ( 0,0 );
		my $w1type = $seg % 3;
		my $w2type = int($seg / 3) % 3;
		my $w3type = int($seg / 9) % 3;
		my $w4type = int($seg / 27) % 3;
		$psegid += 1 if $w1type == 2;
		$psegid += 2 if $w2type == 2;
		$psegid += 4 if $w3type == 2;
		$psegid += 8 if $w4type == 2;
		$ssegid += 1 if $w1type == 1;
		$ssegid += 2 if $w2type == 1;
		$ssegid += 4 if $w3type == 1;
		$ssegid += 8 if $w4type == 1;

		# coordinate of corner of object
		my $xcoord = ($mc_xtoffset + ($hseg * ($mc_hscale + 3)) + 3 );
		my $ycoord1 = $ycoordl1 + 1;
		my $ycoord2 = $ycoordl2 + 1;
		my $ycoord3 = $ycoordl3 + 1;
		my $ycoord4 = $ycoordl4 + 1;
		my $zcoord = ($mc_ztoffset + (($vseg + 0) * ($mc_hscale + 3)) + 3 );
		my ($hhalf, $chhalf, $fhhalf ) = ( $mc_hscale / 2, ceil( $mc_hscale / 2 ), floor( $mc_hscale / 2 ) );
		my ($vhalf, $cvhalf, $fvhalf ) = ( $mc_vscale / 2, ceil( $mc_vscale / 2 ), floor( $mc_vscale / 2 ) );
		my $ycoord2u = ( $ycoordl2 + 1 + $fvhalf );

		my $setpath = "$mc_schemroot/$defaultset";

#		# base coordinates for boxes
#		my ( $w_xhc, $w_yhc, $w_zhc, $w_xhs, $w_yhs, $w_zhs ) = ( $xcoord, $ycoord2, $zcoord, $chhalf, $mc_vscale, $mc_hscale );
#		my ( $e_xhc, $e_yhc, $e_zhc, $e_xhs, $e_yhs, $e_zhs ) = ( $xcoord+$fhhalf, $ycoord2, $zcoord, $chhalf, $mc_vscale, $mc_hscale );
#		my ( $n_xhc, $n_yhc, $n_zhc, $n_xhs, $n_yhs, $n_zhs ) = ( $xcoord, $ycoord2, $zcoord, $mc_hscale, $mc_vscale, $chhalf );
#		my ( $s_xhc, $s_yhc, $s_zhc, $s_xhs, $s_yhs, $s_zhs ) = ( $xcoord, $ycoord2, $zcoord+$fhhalf, $mc_hscale, $mc_vscale, $chhalf );
#		my ( $v_xhc, $v_yhc, $v_zhc, $v_xhs, $v_yhs, $v_zhs ) = ( $xcoord, $ycoord2, $zcoord, $mc_hscale, $mc_vscale, $mc_hscale );
#
#		# additional base coordinates for second and third sets.
#		my ( $n_yhc2, $n_yhc3, $n_yhc4, $n_yhs2, $n_yhs3, $n_yhs4 ) = ( $ycoord3, $ycoord1, $ycoord4, $mc_vscale, $mc_vscale, $mc_vscale );
#		my ( $s_yhc2, $s_yhc3, $s_yhc4, $s_yhs2, $s_yhs3, $s_yhs4 ) = ( $ycoord3, $ycoord1, $ycoord4, $mc_vscale, $mc_vscale, $mc_vscale );
#		my ( $e_yhc2, $e_yhc3, $e_yhc4, $e_yhs2, $e_yhs3, $e_yhs4 ) = ( $ycoord3, $ycoord1, $ycoord4, $mc_vscale, $mc_vscale, $mc_vscale );
#		my ( $w_yhc2, $w_yhc3, $w_yhc4, $w_yhs2, $w_yhs3, $w_yhs4 ) = ( $ycoord3, $ycoord1, $ycoord4, $mc_vscale, $mc_vscale, $mc_vscale );
#		my ( $v_yhc2, $v_yhc3, $v_yhc4, $v_yhs2, $v_yhs3, $v_yhs4 ) = ( $ycoord3, $ycoord1, $ycoord4, $mc_vscale, $mc_vscale, $mc_vscale );
#
		# output import/export lines
		print IOUTPUT "import $setpath/vd$psegid.$ssegid.schematic $xcoord $ycoord1 $zcoord\n";
		print IOUTPUT "import $setpath/vi$psegid.$ssegid.schematic $xcoord $ycoord2 $zcoord\n";
		print IOUTPUT "import $setpath/vu$psegid.$ssegid.schematic $xcoord $ycoord3 $zcoord\n";
		print IOUTPUT "import $setpath/h$psegid.$ssegid.schematic $xcoord $ycoord4 $zcoord\n" if ( ! $ssegid );

		print EOUTPUT "export $setpath/vd$psegid.$ssegid.schematic $xcoord $ycoord1 $zcoord $mc_hscale $mc_vscale $mc_hscale\n";
		print EOUTPUT "export $setpath/vi$psegid.$ssegid.schematic $xcoord $ycoord2 $zcoord $mc_hscale $mc_vscale $mc_hscale\n";
		print EOUTPUT "export $setpath/vu$psegid.$ssegid.schematic $xcoord $ycoord3 $zcoord $mc_hscale $mc_vscale $mc_hscale\n";
		print EOUTPUT "export $setpath/h$psegid.$ssegid.schematic $xcoord $ycoord4 $zcoord $mc_hscale $mc_vscale $mc_hscale\n" if ( ! $ssegid );
		print EOUTPUT "export $setpath/vi$psegid.$ssegid.ut.schematic $xcoord $ycoord2u $zcoord $mc_hscale $fvhalf $mc_hscale\n";
		print EOUTPUT "export $setpath/vi$psegid.$ssegid.lt.schematic $xcoord $ycoord2 $zcoord $mc_hscale $cvhalf $mc_hscale\n";

#		# output solid base material block for four segment groups
#		print BOUTPUT "fill $cmt $xcoord $ycoord1 $zcoord $mc_hscale $mc_vscale $mc_hscale\n";
#		print BOUTPUT "fill $cmt $xcoord $ycoord2 $zcoord $mc_hscale $mc_vscale $mc_hscale\n";
#		print BOUTPUT "fill $cmt $xcoord $ycoord3 $zcoord $mc_hscale $mc_vscale $mc_hscale\n";
#		print BOUTPUT "fill $cmt $xcoord $ycoord4 $zcoord $mc_hscale $mc_vscale $mc_hscale\n" if ( ! $ssegid );

		# output glass base under material blocks
		print BOUTPUT "fill 20 $xcoord $ycoordl1 $zcoord $mc_hscale 1 $mc_hscale\n";
		print BOUTPUT "fill 20 $xcoord $ycoordl2 $zcoord $mc_hscale 1 $mc_hscale\n";
		print BOUTPUT "fill 20 $xcoord $ycoordl3 $zcoord $mc_hscale 1 $mc_hscale\n";
		print BOUTPUT "fill 20 $xcoord $ycoordl4 $zcoord $mc_hscale 1 $mc_hscale\n" if ( ! $ssegid );
		print IOUTPUT "fill 20 $xcoord $ycoordl1 $zcoord $mc_hscale 1 $mc_hscale\n";
		print IOUTPUT "fill 20 $xcoord $ycoordl2 $zcoord $mc_hscale 1 $mc_hscale\n";
		print IOUTPUT "fill 20 $xcoord $ycoordl3 $zcoord $mc_hscale 1 $mc_hscale\n";
		print IOUTPUT "fill 20 $xcoord $ycoordl4 $zcoord $mc_hscale 1 $mc_hscale\n" if ( ! $ssegid );

#		# provide initial box adjustments for core wall thickness
#		$w_zhc += $hco;
#		$w_zhs -= ( $hco * 2 );
#		$e_zhc += $hco;
#		$e_zhs -= ( $hco * 2 );
#		$n_xhc += $hco;
#		$n_xhs -= ( $hco * 2 );
#		$s_xhc += $hco;
#		$s_xhs -= ( $hco * 2 );
#		$v_zhc += $hco;
#		$v_zhs -= ( $hco * 2 );
#		$v_xhc += $hco;
#		$v_xhs -= ( $hco * 2 );
#
#		# leave core walls if required
#		if ( $psegid & 1 ) {
#			$w_xhs -= $hco;
#			$w_xhc += $hco;
#		};
#		if ( $psegid & 2 ) {
#			$e_xhs -= $hco;
#		};
#		if ( $psegid & 4 ) {
#			$n_zhs -= $hco;
#			$n_zhc += $hco;
#		};
#		if ( $psegid & 8 ) {
#			$s_zhs -= $hco;
#		};
#
#		# leave horizontal cores on transitional walls
#		if ( $ssegid & 1 ) {
#			$w_yhs -= ( $vco * 2 );
#			$w_yhc += $vco;
#			$w_yhs2 -= $vco;
#			$w_yhc2 += $vco;
#			$w_yhs3 -= $vco;
#		};
#		if ( $ssegid & 2 ) {
#			$e_yhs -= ( $vco * 2 );
#			$e_yhc += $vco;
#			$e_yhs2 -= $vco;
#			$e_yhc2 += $vco;
#			$e_yhs3 -= $vco;
#		};
#		if ( $ssegid & 4 ) {
#			$n_yhs -= ( $vco * 2 );
#			$n_yhc += $vco;
#			$n_yhs2 -= $vco;
#			$n_yhc2 += $vco;
#			$n_yhs3 -= $vco;
#		};
#		if ( $ssegid & 8 ) {
#			$s_yhs -= ( $vco * 2 );
#			$s_yhc += $vco;
#			$s_yhs2 -= $vco;
#			$s_yhc2 += $vco;
#			$s_yhs3 -= $vco;
#		};
#
#		# leave solid core top on second and fourth segments
#		$w_yhs2 -= $vco;
#		$e_yhs2 -= $vco;
#		$n_yhs2 -= $vco;
#		$s_yhs2 -= $vco;
#		$v_yhs2 -= $vco;
#		$w_yhs4 -= $vco;
#		$e_yhs4 -= $vco;
#		$n_yhs4 -= $vco;
#		$s_yhs4 -= $vco;
#		$v_yhs4 -= $vco;
#
#		# leave solid core bottom on third and fourth segments
#		$w_yhc3 += $vco;
#		$w_yhs3 -= $vco;
#		$e_yhc3 += $vco;
#		$e_yhs3 -= $vco;
#		$n_yhc3 += $vco;
#		$n_yhs3 -= $vco;
#		$s_yhc3 += $vco;
#		$s_yhs3 -= $vco;
#		$v_yhc3 += $vco;
#		$v_yhs3 -= $vco;
#		$w_yhc4 += $vco;
#		$w_yhs4 -= $vco;
#		$e_yhc4 += $vco;
#		$e_yhs4 -= $vco;
#		$n_yhc4 += $vco;
#		$n_yhs4 -= $vco;
#		$s_yhc4 += $vco;
#		$s_yhs4 -= $vco;
#		$v_yhc4 += $vco;
#		$v_yhs4 -= $vco;
#
#		foreach my $order ( "cf", "ff", "wf", "cs", "ws", "fs", "op", "cmh" ) {
#
		foreach my $order ( "null" ) {

		    if ( $order eq "null" ) {
		    } elsif ( $order eq "cf" ) {
#			# output ceiling fill block
#			print BOUTPUT "fill $cft $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $cft $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $cft $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $cft $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $cft $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#
#			print BOUTPUT "fill $cft $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $cft $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $cft $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $cft $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $cft $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $cft $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $cft $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $cft $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $cft $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $cft $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $cft $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $cft $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $cft $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $cft $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $cft $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
#			# leave horizontal ceiling fills on transitional walls
#			if ( $ssegid & 1 ) {
#				$w_yhs -= $cfs;
#				$w_yhs3 -= $cfs;
#			};
#			if ( $ssegid & 2 ) {
#				$e_yhs -= $cfs;
#				$e_yhs3 -= $cfs;
#			};
#			if ( $ssegid & 4 ) {
#				$n_yhs -= $cfs;
#				$n_yhs3 -= $cfs;
#			};
#			if ( $ssegid & 8 ) {
#				$s_yhs -= $cfs;
#				$s_yhs3 -= $cfs;
#			};
#
#			# leave solid ceiling fills on second and fourth segments
#			$w_yhs2 -= $cfs;
#			$e_yhs2 -= $cfs;
#			$n_yhs2 -= $cfs;
#			$s_yhs2 -= $cfs;
#			$v_yhs2 -= $cfs;
#			$w_yhs4 -= $cfs;
#			$e_yhs4 -= $cfs;
#			$n_yhs4 -= $cfs;
#			$s_yhs4 -= $cfs;
#			$v_yhs4 -= $cfs;
#
#		    } elsif ( $order eq "ff" ) {
#
#			# output floor fill block
#			print BOUTPUT "fill $fft $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $fft $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $fft $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $fft $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $fft $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#
#			print BOUTPUT "fill $fft $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $fft $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $fft $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $fft $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $fft $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $fft $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $fft $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $fft $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $fft $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $fft $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $fft $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $fft $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $fft $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $fft $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $fft $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
#			# leave horizontal floor fills on transitional walls
#			if ( $ssegid & 1 ) {
#				$w_yhs -= $ffs;
#				$w_yhc += $ffs;
#				$w_yhs2 -= $ffs;
#				$w_yhc2 += $ffs;
#			};
#			if ( $ssegid & 2 ) {
#				$e_yhs -= $ffs;
#				$e_yhc += $ffs;
#				$e_yhs2 -= $ffs;
#				$e_yhc2 += $ffs;
#			};
#			if ( $ssegid & 4 ) {
#				$n_yhs -= $ffs;
#				$n_yhc += $ffs;
#				$n_yhs2 -= $ffs;
#				$n_yhc2 += $ffs;
#			};
#			if ( $ssegid & 8 ) {
#				$s_yhs -= $ffs;
#				$s_yhc += $ffs;
#				$s_yhs2 -= $ffs;
#				$s_yhc2 += $ffs;
#			};
#
#			# leave solid floor fills on third and fourth segments
#			$w_yhc3 += $ffs;
#			$w_yhs3 -= $ffs;
#			$e_yhc3 += $ffs;
#			$e_yhs3 -= $ffs;
#			$n_yhc3 += $ffs;
#			$n_yhs3 -= $ffs;
#			$s_yhc3 += $ffs;
#			$s_yhs3 -= $ffs;
#			$v_yhc3 += $ffs;
#			$v_yhs3 -= $ffs;
#			$w_yhc4 += $ffs;
#			$w_yhs4 -= $ffs;
#			$e_yhc4 += $ffs;
#			$e_yhs4 -= $ffs;
#			$n_yhc4 += $ffs;
#			$n_yhs4 -= $ffs;
#			$s_yhc4 += $ffs;
#			$s_yhs4 -= $ffs;
#			$v_yhc4 += $ffs;
#			$v_yhs4 -= $ffs;
#
#		    } elsif ( $order eq "wf" ) {
#
#			# output wall fill block
#			print BOUTPUT "fill $wft $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $wft $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $wft $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $wft $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $wft $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#	
#			print BOUTPUT "fill $wft $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $wft $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $wft $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $wft $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $wft $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $wft $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $wft $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $wft $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $wft $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $wft $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $wft $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $wft $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $wft $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $wft $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $wft $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
#			# narrow horizontal fill blocks
#			$w_zhs -= ( $wfs * 2 );
#			$w_zhc += $wfs;
#			$e_zhs -= ( $wfs * 2 );
#			$e_zhc += $wfs;
#			$n_xhs -= ( $wfs * 2 );
#			$n_xhc += $wfs;
#			$s_xhs -= ( $wfs * 2 );
#			$s_xhc += $wfs;
#			$v_xhs -= ( $wfs * 2 );
#			$v_xhc += $wfs;
#			$v_zhs -= ( $wfs * 2 );
#			$v_zhc += $wfs;
#
#			# leave fill walls over solid core walls if required
#			if ( $psegid & 1 ) {
#				$w_xhs -= $wfs;
#				$w_xhc += $wfs;
#			};
#			if ( $psegid & 2 ) {
#				$e_xhs -= $wfs;
#			};
#			if ( $psegid & 4 ) {
#				$n_zhs -= $wfs;
#				$n_zhc += $wfs;
#			};
#			if ( $psegid & 8 ) {
#				$s_zhs -= $wfs;
#			};
#	
#		    } elsif ( $order eq "cs" ) {
#
#			# output ceiling surface blocks
#			print BOUTPUT "fill $cst $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $cst $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $cst $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $cst $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $cst $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#
#			print BOUTPUT "fill $cst $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $cst $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $cst $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $cst $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $cst $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $cst $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $cst $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $cst $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $cst $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $cst $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $cst $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $cst $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $cst $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $cst $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $cst $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
#			# leave horizontal ceiling surfaces on transitional walls
#			if ( $ssegid & 1 ) {
#				$w_yhs -= $css;
#				$w_yhs3 -= $css;
#			};
#			if ( $ssegid & 2 ) {
#				$e_yhs -= $css;
#				$e_yhs3 -= $css;
#			};
#			if ( $ssegid & 4 ) {
#				$n_yhs -= $css;
#				$n_yhs3 -= $css;
#			};
#			if ( $ssegid & 8 ) {
#				$s_yhs -= $css;
#				$s_yhs3 -= $css;
#			};
#
#			# leave solid ceiling surfaces on second and fourth segments
#			$w_yhs2 -= $css;
#			$e_yhs2 -= $css;
#			$n_yhs2 -= $css;
#			$s_yhs2 -= $css;
#			$v_yhs2 -= $css;
#			$w_yhs4 -= $css;
#			$e_yhs4 -= $css;
#			$n_yhs4 -= $css;
#			$s_yhs4 -= $css;
#			$v_yhs4 -= $css;
#
#		    } elsif ( $order eq "fs" ) {
#
#			# output floor surface blocks
#			print BOUTPUT "fill $fst $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $fst $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $fst $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $fst $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $fst $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#
#			print BOUTPUT "fill $fst $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $fst $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $fst $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $fst $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $fst $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $fst $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $fst $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $fst $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $fst $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $fst $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $fst $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $fst $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $fst $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $fst $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $fst $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
#			# leave horizontal floor surfaces on transitional walls
#			if ( $ssegid & 1 ) {
#				$w_yhs -= $fss;
#				$w_yhc += $fss;
#				$w_yhs2 -= $fss;
#				$w_yhc2 += $fss;
#			};
#			if ( $ssegid & 2 ) {
#				$e_yhs -= $fss;
#				$e_yhc += $fss;
#				$e_yhs2 -= $fss;
#				$e_yhc2 += $fss;
#			};
#			if ( $ssegid & 4 ) {
#				$n_yhs -= $fss;
#				$n_yhc += $fss;
#				$n_yhs2 -= $fss;
#				$n_yhc2 += $fss;
#			};
#			if ( $ssegid & 8 ) {
#				$s_yhs -= $fss;
#				$s_yhc += $fss;
#				$s_yhs2 -= $fss;
#				$s_yhc2 += $fss;
#			};
#
#			# leave solid floor surfaces on third and fourth segments
#			$w_yhc3 += $fss;
#			$w_yhs3 -= $fss;
#			$e_yhc3 += $fss;
#			$e_yhs3 -= $fss;
#			$n_yhc3 += $fss;
#			$n_yhs3 -= $fss;
#			$s_yhc3 += $fss;
#			$s_yhs3 -= $fss;
#			$v_yhc3 += $fss;
#			$v_yhs3 -= $fss;
#			$w_yhc4 += $fss;
#			$w_yhs4 -= $fss;
#			$e_yhc4 += $fss;
#			$e_yhs4 -= $fss;
#			$n_yhc4 += $fss;
#			$n_yhs4 -= $fss;
#			$s_yhc4 += $fss;
#			$s_yhs4 -= $fss;
#			$v_yhc4 += $fss;
#			$v_yhs4 -= $fss;
#
#		    } elsif ( $order eq "ws" ) {
#
#			# output wall surface blocks
#			print BOUTPUT "fill $wst $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $wst $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $wst $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $wst $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $wst $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#
#			print BOUTPUT "fill $wst $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $wst $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $wst $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $wst $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $wst $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $wst $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $wst $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $wst $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $wst $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $wst $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $wst $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $wst $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $wst $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $wst $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $wst $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
#			# narrow horizontal fill blocks
#			$w_zhs -= ( $wss * 2 );
#			$w_zhc += $wss;
#			$e_zhs -= ( $wss * 2 );
#			$e_zhc += $wss;
#			$n_xhs -= ( $wss * 2 );
#			$n_xhc += $wss;
#			$s_xhs -= ( $wss * 2 );
#			$s_xhc += $wss;
#			$v_xhs -= ( $wss * 2 );
#			$v_xhc += $wss;
#			$v_zhs -= ( $wss * 2 );
#			$v_zhc += $wss;
#
#			# leave surface walls over solid fill walls if required
#			if ( $psegid & 1 ) {
#				$w_xhs -= $wss;
#				$w_xhc += $wss;
#			};
#			if ( $psegid & 2 ) {
#				$e_xhs -= $wss;
#			};
#			if ( $psegid & 4 ) {
#				$n_zhs -= $wss;
#				$n_zhc += $wss;
#			};
#			if ( $psegid & 8 ) {
#				$s_zhs -= $wss;
#			};
#
#		    } elsif ( $order eq "op" ) {
#
#			# output wall openings
#			print BOUTPUT "fill $omt $w_xhc $w_yhc $w_zhc $w_xhs $w_yhs $w_zhs\n";
#			print BOUTPUT "fill $omt $e_xhc $e_yhc $e_zhc $e_xhs $e_yhs $e_zhs\n";
#			print BOUTPUT "fill $omt $n_xhc $n_yhc $n_zhc $n_xhs $n_yhs $n_zhs\n";
#			print BOUTPUT "fill $omt $s_xhc $s_yhc $s_zhc $s_xhs $s_yhs $s_zhs\n";
#			print BOUTPUT "fill $omt $v_xhc $v_yhc $v_zhc $v_xhs $v_yhs $v_zhs\n";
#
#			print BOUTPUT "fill $omt $w_xhc $w_yhc2 $w_zhc $w_xhs $w_yhs2 $w_zhs\n";
#			print BOUTPUT "fill $omt $e_xhc $e_yhc2 $e_zhc $e_xhs $e_yhs2 $e_zhs\n";
#			print BOUTPUT "fill $omt $n_xhc $n_yhc2 $n_zhc $n_xhs $n_yhs2 $n_zhs\n";
#			print BOUTPUT "fill $omt $s_xhc $s_yhc2 $s_zhc $s_xhs $s_yhs2 $s_zhs\n";
#			print BOUTPUT "fill $omt $v_xhc $v_yhc2 $v_zhc $v_xhs $v_yhs2 $v_zhs\n";
#
#			print BOUTPUT "fill $omt $w_xhc $w_yhc3 $w_zhc $w_xhs $w_yhs3 $w_zhs\n";
#			print BOUTPUT "fill $omt $e_xhc $e_yhc3 $e_zhc $e_xhs $e_yhs3 $e_zhs\n";
#			print BOUTPUT "fill $omt $n_xhc $n_yhc3 $n_zhc $n_xhs $n_yhs3 $n_zhs\n";
#			print BOUTPUT "fill $omt $s_xhc $s_yhc3 $s_zhc $s_xhs $s_yhs3 $s_zhs\n";
#			print BOUTPUT "fill $omt $v_xhc $v_yhc3 $v_zhc $v_xhs $v_yhs3 $v_zhs\n";
#
#			if ( ! $ssegid ) {
#				print BOUTPUT "fill $omt $w_xhc $w_yhc4 $w_zhc $w_xhs $w_yhs4 $w_zhs\n";
#				print BOUTPUT "fill $omt $e_xhc $e_yhc4 $e_zhc $e_xhs $e_yhs4 $e_zhs\n";
#				print BOUTPUT "fill $omt $n_xhc $n_yhc4 $n_zhc $n_xhs $n_yhs4 $n_zhs\n";
#				print BOUTPUT "fill $omt $s_xhc $s_yhc4 $s_zhc $s_xhs $s_yhs4 $s_zhs\n";
#				print BOUTPUT "fill $omt $v_xhc $v_yhc4 $v_zhc $v_xhs $v_yhs4 $v_zhs\n";
#			};
#
		    } elsif ( $order eq "lc" ) {
			print BOUTPUT "# lc\n";

			# one-off: output walkway for lava canal
		 	my $half = (($mc_hscale / 2) + 1);
			my $zhalfstart = $zcoord + (( $mc_hscale / 2) - 1);
			my $zctrstart = $zcoord + (( $mc_hscale / 2) - 2);
			my $ystart = $ycoord1 + 3;
			my $y4start = $ycoord4 + 3;
			my $ybstart = $ycoord1 + 1;
			my $yb2start = $ycoord2 + 1;
			my $yb3start = $ycoord3 + 1;
			my $yb4start = $ycoord4 + 1;
			my $xhalfstart = $xcoord + (( $mc_hscale / 2) - 1);
			my $xctrstart = $xcoord + (( $mc_hscale / 2) - 2);
			my $xfstart = $xcoord + $mc_hscale - 2;
			my $zfstart = $zcoord + $mc_hscale - 2;
			print BOUTPUT "# vhe segment $seg vseg $vseg hseg $hseg\n";

			# walkway paths on first and fourth segments
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ew.schematic $xcoord $ystart $zhalfstart\n"if ( ($psegid & 1) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ew.schematic $xhalfstart $ystart $zhalfstart\n" if ( ($psegid & 2) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ns.schematic $xhalfstart $ystart $zcoord\n" if ( ($psegid & 4) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ns.schematic $xhalfstart $ystart $zhalfstart\n" if ( ($psegid & 8) == 0 );

			if ( ! $ssegid ) {
			    print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ew.schematic $xcoord $y4start $zhalfstart\n"if ( ($psegid & 1) == 0 );
			    print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ew.schematic $xhalfstart $y4start $zhalfstart\n" if ( ($psegid & 2) == 0 );
			    print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ns.schematic $xhalfstart $y4start $zcoord\n" if ( ($psegid & 4) == 0 );
			    print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ns.schematic $xhalfstart $y4start $zhalfstart\n" if ( ($psegid & 8) == 0 );
			};

			# 3-way/4-way/corner segments only
			if ( ($psegid & 3) != 3 && ($psegid & 12) != 12 ) {
				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-cp.schematic $xctrstart $ybstart $zctrstart noair\n";
			};
			# dead-ends only
			if ( $psegid == 7 || $psegid == 11 || $psegid == 13 || $psegid == 14 || $psegid == 15 ) {
				print BOUTPUT "import $mc_schemroot/misc/lc-walkway-cp.schematic $xctrstart $ybstart $zctrstart noair\n";
			};
			# secondary walls only
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-wg.schematic $xcoord $ycoord2 $zcoord noair\n" if ( $ssegid & 1 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-eg.schematic $xcoord $ycoord2 $zcoord noair\n" if ( $ssegid & 2 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ng.schematic $xcoord $ycoord2 $zcoord noair\n" if ( $ssegid & 4 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-sg.schematic $xcoord $ycoord2 $zcoord noair\n" if ( $ssegid & 8 );

			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-wg.schematic $xcoord $ycoord3 $zcoord noair\n" if ( $ssegid & 1 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-eg.schematic $xcoord $ycoord3 $zcoord noair\n" if ( $ssegid & 2 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-ng.schematic $xcoord $ycoord3 $zcoord noair\n" if ( $ssegid & 4 );
			print BOUTPUT "import $mc_schemroot/misc/lc-walkway-sg.schematic $xcoord $ycoord3 $zcoord noair\n" if ( $ssegid & 8 );

		    } elsif ( $order eq "dr" ) {
			print BOUTPUT "# dr\n";

			# one-off: lay double track on vhe segments
		 	my $half = ( ($mc_hscale / 2) + 1);
			my $zhalfstart = $zcoord + (( $mc_hscale / 2) - 1);
			my $xhalfstart = $xcoord + (( $mc_hscale / 2) - 1);
			my $yb1start = $ycoord1 + $vco + $ffs + $fss - 1;
			my $yb2start = $ycoord2 + $vco + $ffs + $fss - 1;
			my $yb3start = $ycoord3 + $vco + $ffs + $fss - 1;
			my $yb4start = $ycoord4 + $vco + $ffs + $fss - 1;

			my $C = '';

			# add track segments to vd blocks
			my ( $W, $E, $N, $S, $B ) = ( $xcoord, $xhalfstart, $zcoord, $zhalfstart, $yb1start );

			my $vdset = 0;
			$vdset = 1 if $buildalt;

			if ( $vdset ) {
				$C = '#' if $psegid == 15;

				print BOUTPUT "# vd track $psegid\n";
				print BOUTPUT "$C import $mc_schemroot/misc/track-se.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 5 );
				print BOUTPUT "import $mc_schemroot/misc/track-nw.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-s.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-w.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-sw.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 6 );
				print BOUTPUT "import $mc_schemroot/misc/track-ne.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-n.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-w.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-ne.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 9 );
				print BOUTPUT "import $mc_schemroot/misc/track-sw.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-s.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-e.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 8 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-nw.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 10 );
				print BOUTPUT "import $mc_schemroot/misc/track-se.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-n.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-e.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 8 );
			};

			# output tracks on hallway blocks
			( $W, $E, $N, $S, $B ) = ( $xcoord, $xhalfstart, $zcoord, $zhalfstart, $yb4start );

			$C = '#' if $psegid == 15;

			if ( ! $ssegid ) {
				print BOUTPUT "# h track $psegid\n";
				print BOUTPUT "$C import $mc_schemroot/misc/track-se.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 5 );
				print BOUTPUT "import $mc_schemroot/misc/track-nw.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-s.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-w.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-sw.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 6 );
				print BOUTPUT "import $mc_schemroot/misc/track-ne.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-n.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-w.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-ne.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 9 );
				print BOUTPUT "import $mc_schemroot/misc/track-sw.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-s.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-e.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 8 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-nw.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 10 );
				print BOUTPUT "import $mc_schemroot/misc/track-se.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-ns-n.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-ew-e.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 8 );
			};

			# add track segments to vi blocks
			( $W, $E, $N, $S, $B ) = ( $xcoord, $xhalfstart, $zcoord, $zhalfstart, $yb2start );

			my $viset = 0;
			$viset = 1 if $buildalt;

			if ( $viset ) {

				$C = '#' if $psegid == 15;

				print BOUTPUT "# vi track pseg $psegid.$ssegid \n";
				print BOUTPUT "$C import $mc_schemroot/misc/track-br-se.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 5 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-nw.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-sw.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 6 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ne.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-ne.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 9 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-sw.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 8 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-nw.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 10 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-se.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 8 );

			} else {
				$C = '#' if $ssegid == 0;

				print BOUTPUT "# vi track sseg $psegid.$ssegid\n";
				print BOUTPUT "$C import $mc_schemroot/misc/track-br-se.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-nw.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 5 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 4 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 1 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-sw.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ne.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 6 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 4 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 2 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-ne.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-sw.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 9 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 8 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 1 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-nw.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-se.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 10 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 8 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 2 );
			};


			# add track segments to vu blocks
			( $W, $E, $N, $S, $B ) = ( $xcoord, $xhalfstart, $zcoord, $zhalfstart, $yb3start );

			my $vuset = 0;
			$vuset = 1 if $buildalt;

			$C = '';

			if ( $vuset ) {
				$C = '#' if $psegid == 15;

				print BOUTPUT "# vu track pseg $psegid\n";
				print BOUTPUT "$C import $mc_schemroot/misc/track-br-se.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 5 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-nw.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $W $B $N noair\n" if (( $psegid & (1 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-sw.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 6 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ne.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $E $B $N noair\n" if (( $psegid & (2 + 4)) == 4 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-ne.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 9 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-sw.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 1 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $W $B $S noair\n" if (( $psegid & (1 + 8)) == 8 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-nw.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 10 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-se.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 2 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $E $B $S noair\n" if (( $psegid & (2 + 8)) == 8 );

			} else {
				$C = '#' if $ssegid == 0;

				print BOUTPUT "# vu track ssegid $ssegid\n";
				print BOUTPUT "$C import $mc_schemroot/misc/track-br-se.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-nw.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 5 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 4 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $W $B $N noair\n" if (( $ssegid & (1 + 4)) == 1 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-sw.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ne.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 6 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 4 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-w.schematic $E $B $N noair\n" if (( $ssegid & (2 + 4)) == 2 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-ne.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-sw.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 9 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-s.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 8 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $W $B $S noair\n" if (( $ssegid & (1 + 8)) == 1 );

				print BOUTPUT "$C import $mc_schemroot/misc/track-br-nw.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-se.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 10 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ns-n.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 8 );
				print BOUTPUT "import $mc_schemroot/misc/track-br-ew-e.schematic $E $B $S noair\n" if (( $ssegid & (2 + 8)) == 2 );

			};

#		    } elsif ( $order eq "l1" ) {
#			print BOUTPUT "# l1\n";
#
#			# one-off: add optional lighting for generic hallways
#			my ( $W, $E, $N, $S ) = ( $n_xhc - 1, $n_xhc + $n_xhs, $w_zhc - 1, $w_zhc + $w_zhs );
#			my $B = ( $ycoord1 + $vco + $ffs + $fss );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $W $B $N\n" if (( $psegid & (1 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $E $B $N\n" if (( $psegid & (2 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $W $B $S\n" if (( $psegid & (1 + 8)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $E $B $S\n" if (( $psegid & (2 + 8)) == 0 );
#			if ( ! $ssegid ) {
#				$B = ( $ycoord4 + $vco + $ffs + $fss );
#				print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $W $B $N\n" if (( $psegid & (1 + 4)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $E $B $N\n" if (( $psegid & (2 + 4)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $W $B $S\n" if (( $psegid & (1 + 8)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/sandstone-light.schematic $E $B $S\n" if (( $psegid & (2 + 8)) == 0 );
#			};
#
#		    } elsif ( $order eq "l2" ) {
#			print BOUTPUT "# l2\n";
#
#			# one-off: add optional lighting for canal hallways
#			my ( $W, $E, $N, $S ) = ( $n_xhc - 2, $n_xhc + $n_xhs, $w_zhc - 2, $w_zhc + $w_zhs );
#			my $B = ( $ycoord1 + $vco + $ffs + $fss - 1 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-nw.schematic $W $B $N\n" if (( $psegid & (1 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-ne.schematic $E $B $N\n" if (( $psegid & (2 + 4)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-sw.schematic $W $B $S\n" if (( $psegid & (1 + 8)) == 0 );
#			print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-se.schematic $E $B $S\n" if (( $psegid & (2 + 8)) == 0 );
#			if ( ! $ssegid ) {
#				$B = ( $ycoord4 + $vco + $ffs + $fss - 1 );
#				print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-nw.schematic $W $B $N\n" if (( $psegid & (1 + 4)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-ne.schematic $E $B $N\n" if (( $psegid & (2 + 4)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-sw.schematic $W $B $S\n" if (( $psegid & (1 + 8)) == 0 );
#				print BOUTPUT "import $mc_schemroot/misc/canalcornertorch-se.schematic $E $B $S\n" if (( $psegid & (2 + 8)) == 0 );
#			};

		    } elsif ( $order eq "l3" ) {
			print BOUTPUT "# l3\n";
		
			# one-off: add optional lighting to generic hallway (alternate design)
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			my $HW = $hallwidth;
			print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-nw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-ne.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-sw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-se.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			print BOUTPUT "replace 62 with 0 $X $Y1 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/cornertorch-w$HW-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};

		    } elsif ( $order eq "cmh" ) {

			print BOUTPUT "# ldt\n";

			# one-off: add interior to large drainage tunnel dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# floor moulding along solid walls of VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# floor moulding extending through wall opening on VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# inside corner fix
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			# print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/ctunnel-cicfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				# print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};
			# central pillars determined by floor/ceiling status
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-ctr-nc-f.schematic $X $Y1 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-ctr-nc-nf.schematic $X $Y2 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-ctr-c-nf.schematic $X $Y3 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-ctr-c-f.schematic $X $Y4 $Z noair\n" if ( ! $ssegid );

			# ceiling moulding ending at constricted openings on VD, and VI groups
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);

			# floor moulding ending at constricted openings on VU, and VI groups
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ctunnel-fmouldend-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);

			# ceiling archways extending through wall opening on VU group
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			# print BOUTPUT "import $mc_schemroot/misc/ctunnel-cmarch-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);

			print BOUTPUT "replace 62 with 0 $X $Y1 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y2 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n" if ( ! $ssegid );

		    } elsif ( $order eq "ldt" ) {

			print BOUTPUT "# ldt\n";

			# one-off: add interior to large drainage tunnel dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# floor moulding along solid walls of VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# floor moulding extending through wall opening on VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# inside corner fix
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			# print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/ldrainage-cicfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				# print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};
			# central pillars determined by floor/ceiling status
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-ctr-nc-f.schematic $X $Y1 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-ctr-nc-nf.schematic $X $Y2 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-ctr-c-nf.schematic $X $Y3 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-ctr-c-f.schematic $X $Y4 $Z noair\n" if ( ! $ssegid );

			# ceiling moulding ending at constricted openings on VD and VI groups
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);

			# ceiling moulding ending at constricted openings on VU and VI groups
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-fmouldend-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);

			# ceiling archways extending through wall opening on VU group
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/ldrainage-cmarch-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);

			print BOUTPUT "replace 62 with 0 $X $Y1 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y2 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n" if ( ! $ssegid );

		    } elsif ( $order eq "ldh" ) {
			print BOUTPUT "# ldh\n";

			# one-off: add interior to large dungeon hallway dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# floor moulding along solid walls of VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# floor moulding extending through wall opening on VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# ceiling moulding ending at constricted openings on VD and VI groups
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# floor moulding ending at constricted openings on VU and VI groups
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall-fmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# inside corner fix
			print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall-icfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};
			# central pillars/lighting determined by floor/ceiling status
			print BOUTPUT "import $mc_schemroot/misc/dhall-ctr-nc-f.schematic $X $Y1 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall-ctr-nc-nf.schematic $X $Y2 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall-ctr-c-nf.schematic $X $Y3 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall-ctr-c-f.schematic $X $Y4 $Z noair\n" if ( ! $ssegid );

			# redstone circuits under floors of VD and H groups and switch redstone lamps to off state.
			print BOUTPUT "import $mc_schemroot/misc/dhall-redstone-s$psegid.schematic $xcoord $Y1 $zcoord noair\n";
			print BOUTPUT "replace 124 with 123 $X $Y1 $Z $mc_hscale 6 $mc_hscale\n";
			if ( ! $ssegid ) {
			    print BOUTPUT "import $mc_schemroot/misc/dhall-redstone-s$psegid.schematic $xcoord $Y4 $zcoord noair\n";
			    print BOUTPUT "replace 124 with 123 $X $Y4 $Z $mc_hscale 6 $mc_hscale\n";
			};

		    } elsif ( $order eq "ldh2" ) {
			print BOUTPUT "# ldh2\n";

			# one-off: add interior to large dungeon hallway 2 dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# floor moulding along solid walls of VD and H groups
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ledge moulding along solid walls and constricted openings of VI and VU groups
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-w.schematic $X $Y2 $Z noair\n" if (( $psegid & 1) || ( $ssegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-e.schematic $X $Y2 $Z noair\n" if (( $psegid & 2) || ( $ssegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-n.schematic $X $Y2 $Z noair\n" if (( $psegid & 4) || ( $ssegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-s.schematic $X $Y2 $Z noair\n" if (( $psegid & 8) || ( $ssegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-w.schematic $X $Y3 $Z noair\n" if (( $psegid & 1) || ( $ssegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-e.schematic $X $Y3 $Z noair\n" if (( $psegid & 2) || ( $ssegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-n.schematic $X $Y3 $Z noair\n" if (( $psegid & 4) || ( $ssegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmoulding-s.schematic $X $Y3 $Z noair\n" if (( $psegid & 8) || ( $ssegid & 8));

			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};

			# ledge moulding extending through non-constricted wall openings on VI and VU groups
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-w.schematic $X $Y2 $Z noair\n" if ((!($psegid & 1)) && (!($ssegid & 1)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-e.schematic $X $Y2 $Z noair\n" if ((!($psegid & 2)) && (!($ssegid & 2)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-n.schematic $X $Y2 $Z noair\n" if ((!($psegid & 4)) && (!($ssegid & 4)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-s.schematic $X $Y2 $Z noair\n" if ((!($psegid & 8)) && (!($ssegid & 8)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-w.schematic $X $Y3 $Z noair\n" if ((!($psegid & 1)) && (!($ssegid & 1)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-e.schematic $X $Y3 $Z noair\n" if ((!($psegid & 2)) && (!($ssegid & 2)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-n.schematic $X $Y3 $Z noair\n" if ((!($psegid & 4)) && (!($ssegid & 4)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lmouldext-s.schematic $X $Y3 $Z noair\n" if ((!($psegid & 8)) && (!($ssegid & 8)));

			# floor moulding extending through wall opening on VD and H groups
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# ceiling moulding ending at constricted openings on VD and VI groups
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# floor moulding ending at constricted openings on VU and VI groups
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-fmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);

			# inside corner fix of ceiling moulding
			print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall2-icfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};

			# inside corner fix of ledge moulding on VI and VU groups
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-nw.schematic $X $Y2 $Z noair\n" if ((!($psegid &  5)) && (!($ssegid &  5)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-ne.schematic $X $Y2 $Z noair\n" if ((!($psegid &  6)) && (!($ssegid &  6)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-sw.schematic $X $Y2 $Z noair\n" if ((!($psegid &  9)) && (!($ssegid &  9)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-se.schematic $X $Y2 $Z noair\n" if ((!($psegid & 10)) && (!($ssegid & 10)));
			print BOUTPUT "replace 62 with 0 $X $Y2 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-nw.schematic $X $Y3 $Z noair\n" if ((!($psegid &  5)) && (!($ssegid &  5)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-ne.schematic $X $Y3 $Z noair\n" if ((!($psegid &  6)) && (!($ssegid &  6)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-sw.schematic $X $Y3 $Z noair\n" if ((!($psegid &  9)) && (!($ssegid &  9)));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-licfix-se.schematic $X $Y3 $Z noair\n" if ((!($psegid & 10)) && (!($ssegid & 10)));
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";

			# central pillars/lighting determined by floor/ceiling status
			print BOUTPUT "import $mc_schemroot/misc/dhall2-ctr-nc-f.schematic $X $Y1 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall2-ctr-nc-nf.schematic $X $Y2 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall2-ctr-c-nf.schematic $X $Y3 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall2-ctr-c-f.schematic $X $Y4 $Z noair\n" if ( ! $ssegid );
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n" if ( ! $ssegid );

			# cmoulding stair fix for places where central pillars and ceiling come together
			print BOUTPUT "import $mc_schemroot/misc/dhall2-wfix-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-wfix-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-wfix-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall2-wfix-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);

			# lmoulding stair fix for places where central pillars and ledges come together
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-w.schematic $X $Y2 $Z noair\n" if (( $psegid & 1) || ( $ssegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-e.schematic $X $Y2 $Z noair\n" if (( $psegid & 2) || ( $ssegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-n.schematic $X $Y2 $Z noair\n" if (( $psegid & 4) || ( $ssegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-s.schematic $X $Y2 $Z noair\n" if (( $psegid & 8) || ( $ssegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-w.schematic $X $Y3 $Z noair\n" if (( $psegid & 1) || ( $ssegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-e.schematic $X $Y3 $Z noair\n" if (( $psegid & 2) || ( $ssegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-n.schematic $X $Y3 $Z noair\n" if (( $psegid & 4) || ( $ssegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall2-lwfix-s.schematic $X $Y3 $Z noair\n" if (( $psegid & 8) || ( $ssegid & 8));

			# redstone circuits under floors of VD and H groups and switch redstone lamps to off state.
			# print BOUTPUT "import $mc_schemroot/misc/dhall2-redstone-s$psegid.schematic $xcoord $Y1 $zcoord noair\n";
			# print BOUTPUT "replace 124 with 123 $X $Y1 $Z $mc_hscale 6 $mc_hscale\n";
			if ( ! $ssegid ) {
			    # print BOUTPUT "import $mc_schemroot/misc/dhall2-redstone-s$psegid.schematic $xcoord $Y4 $zcoord noair\n";
			    # print BOUTPUT "replace 124 with 123 $X $Y4 $Z $mc_hscale 6 $mc_hscale\n";
			};

		    } elsif ( $order eq "ldh3" ) {

			print BOUTPUT "# ldh3\n";

			# one-off: add interior to large dungeon hallway 3 dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# ceiling moulding ending at constricted openings on VD and VI groups
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "replace 62 with 0 $X $Y1 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/dhall3-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "replace 62 with 0 $X $Y2 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			# inside corner fix
			print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/dhall3-icfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};
		    } elsif ( $order eq "drh" ) {

			print BOUTPUT "# drh\n";

			# obsolete: replaced by drsint

			# one-off: add interior to small drainage tunnel dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# floor moulding along solid walls of VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# floor moulding extending through wall opening on VD and H groups
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# ceiling moulding ending at constricted openings on VD and VI groups
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# floor moulding ending at constricted openings on VU and VI groups
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-fmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# ceiling inside corner fix
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-cicfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};
			# floor inside corner fix
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-nw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-ne.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-sw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-se.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/sdrainage-ficfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
				print BOUTPUT "replace 62 with 0 $X $Y4 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			};

		    } elsif ( $order eq "drsint" ) {

			print BOUTPUT "# drsint\n";

			# one-off: add interior to small drainage tunnel dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );

			my $mouldset = "$mc_schemroot/misc/sdrainage";

			# ceiling moulding at solid walls adjacent to ceilings
			if ( $tfa || $tsa ) {
			    print BOUTPUT "import $mouldset-cmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			    print BOUTPUT "import $mouldset-cmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			    print BOUTPUT "import $mouldset-cmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			    print BOUTPUT "import $mouldset-cmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			    print BOUTPUT "import $mouldset-cmoulding-w.schematic $X $Y2 $Z noair\n" if ( $psegid & 1);
			    print BOUTPUT "import $mouldset-cmoulding-e.schematic $X $Y2 $Z noair\n" if ( $psegid & 2);
			    print BOUTPUT "import $mouldset-cmoulding-n.schematic $X $Y2 $Z noair\n" if ( $psegid & 4);
			    print BOUTPUT "import $mouldset-cmoulding-s.schematic $X $Y2 $Z noair\n" if ( $psegid & 8);
			};
			print BOUTPUT "import $mouldset-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mouldset-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mouldset-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mouldset-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mouldset-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mouldset-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mouldset-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mouldset-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};

			# floor moulding along solid walls adjacent to floors
			if ( $bfa || $bsa ) {
			    print BOUTPUT "import $mouldset-fmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			    print BOUTPUT "import $mouldset-fmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			    print BOUTPUT "import $mouldset-fmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			    print BOUTPUT "import $mouldset-fmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			    print BOUTPUT "import $mouldset-fmoulding-w.schematic $X $Y2 $Z noair\n" if ( $psegid & 1);
			    print BOUTPUT "import $mouldset-fmoulding-e.schematic $X $Y2 $Z noair\n" if ( $psegid & 2);
			    print BOUTPUT "import $mouldset-fmoulding-n.schematic $X $Y2 $Z noair\n" if ( $psegid & 4);
			    print BOUTPUT "import $mouldset-fmoulding-s.schematic $X $Y2 $Z noair\n" if ( $psegid & 8);
			};
			print BOUTPUT "import $mouldset-fmoulding-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mouldset-fmoulding-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mouldset-fmoulding-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mouldset-fmoulding-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mouldset-fmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mouldset-fmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mouldset-fmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mouldset-fmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};

			# ceiling moulding extending through wall opening on VU and H groups and upper-constricted VD and VI groups
			if ( $tfa || $tsa ) {
			    print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			    print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			    print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			    print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			    print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			    print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 1));
			    print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 2));
			    print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 4));
			    print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 8));
			    print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			};
			print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mouldset-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mouldset-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mouldset-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mouldset-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};

			# floor moulding extending through wall opening on VD and H groups and lower-constricted VU and VI groups
			print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			if ( $bfa || $bsa ) {
			    print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 1));
			    print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 2));
			    print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 4));
			    print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 8));
			    print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			    print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			    print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			    print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			    print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			    print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			};
			if ( ! $ssegid ) {
				print BOUTPUT "import $mouldset-fmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mouldset-fmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mouldset-fmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mouldset-fmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};

			# ceiling moulding ending at constricted openings on VD and VI groups for non-constricted ceiling
			if ( ( ! $tfa ) && ( ! $tsa ) ) {
			    print BOUTPUT "import $mouldset-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			    print BOUTPUT "import $mouldset-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			};
			# floor moulding ending at constricted openings on VU and VI groups for non-constricted floor
			if ( ( ! $bfa ) && ( ! $bsa ) ) {
			    print BOUTPUT "import $mouldset-fmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-fmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-fmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-fmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			    print BOUTPUT "import $mouldset-fmouldend-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			    print BOUTPUT "import $mouldset-fmouldend-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			    print BOUTPUT "import $mouldset-fmouldend-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			    print BOUTPUT "import $mouldset-fmouldend-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			};
			# ceiling inside corner fix for VU and H groups and for constricted-ceiling VI and VD groups
			if ( $tfa || $tsa ) {
			    print BOUTPUT "import $mouldset-cicfix-nw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-ne.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-sw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-se.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-nw.schematic $X $Y2 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-ne.schematic $X $Y2 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-sw.schematic $X $Y2 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			    print BOUTPUT "import $mouldset-cicfix-se.schematic $X $Y2 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			};
			print BOUTPUT "import $mouldset-cicfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mouldset-cicfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mouldset-cicfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mouldset-cicfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			if ( ! $ssegid ) {
				print BOUTPUT "import $mouldset-cicfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mouldset-cicfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mouldset-cicfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mouldset-cicfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			};
			# floor inside corner fix for VD and H groups and for constricted-floor VU and VI groups
			print BOUTPUT "import $mouldset-ficfix-nw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mouldset-ficfix-ne.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mouldset-ficfix-sw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mouldset-ficfix-se.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			if ( $bfa || $bsa ) {
			    print BOUTPUT "import $mouldset-ficfix-nw.schematic $X $Y2 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-ne.schematic $X $Y2 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-sw.schematic $X $Y2 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-se.schematic $X $Y2 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-nw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-ne.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-sw.schematic $X $Y3 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			    print BOUTPUT "import $mouldset-ficfix-se.schematic $X $Y3 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			};
			# print BOUTPUT "replace 62 with 0 $X $Y3 $Z $mc_hscale $mc_vscale $mc_hscale\n";
			if ( ! $ssegid ) {
				print BOUTPUT "import $mouldset-ficfix-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mouldset-ficfix-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mouldset-ficfix-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mouldset-ficfix-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			};

		    } elsif ( $order eq "gh" ) {

			print BOUTPUT "# gh\n";

			# one-off: add ceiling lighting and decoration for the grandhall dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# ceiling moulding along solid walls of VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmoulding-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
			};
			# ceiling moulding extending through wall opening on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
			# ceiling lighting on VU and H groups
			print BOUTPUT "import $mc_schemroot/misc/grandhall-clighting.schematic $X $Y3 $Z noair\n";
			print BOUTPUT "import $mc_schemroot/misc/grandhall-clighting.schematic $X $Y4 $Z noair\n" if ( ! $ssegid );
			# ceiling moulding ending at constricted openings on VD and VI groups
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/grandhall-cmouldend-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);

		    } elsif ( $order eq "cu" ) {
			print BOUTPUT "# cu\n";

			# one-off: add arch decoration to upper canal dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# VU decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-w.schematic $X $Y3 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-e.schematic $X $Y3 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-n.schematic $X $Y3 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-s.schematic $X $Y3 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			# H decoration
			if ( ! $ssegid ) {
				print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-w.schematic $X $Y4 $Z noair\n" if (! ($psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-e.schematic $X $Y4 $Z noair\n" if (! ($psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-n.schematic $X $Y4 $Z noair\n" if (! ($psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-s.schematic $X $Y4 $Z noair\n" if (! ($psegid & 8));
			};
			# VI decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-w.schematic $X $Y2 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-e.schematic $X $Y2 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-n.schematic $X $Y2 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-s.schematic $X $Y2 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# VD decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-w.schematic $X $Y1 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-e.schematic $X $Y1 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-n.schematic $X $Y1 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-s.schematic $X $Y1 $Z noair\n" if ( ! ( ( $ssegid | $psegid ) & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-hbeam-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);

		    } elsif ( $order eq "cl" ) {
			print BOUTPUT "# cl\n";

			# one-off: add arch decoration and path cutout to lower canal dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# VU decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				# H decoration
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-w.schematic $X $Y4 $Z noair\n" if (! ($psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-e.schematic $X $Y4 $Z noair\n" if (! ($psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-n.schematic $X $Y4 $Z noair\n" if (! ($psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-s.schematic $X $Y4 $Z noair\n" if (! ($psegid & 8));
			};
			# VI decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-w.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-e.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-n.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-s.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# VD decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);

			# path cutout added to VD group
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			# path cutout added to VI group
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-w.schematic $X $Y2 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-e.schematic $X $Y2 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-n.schematic $X $Y2 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-s.schematic $X $Y2 $Z noair\n" if ( $psegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# path cutout added to VU group
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-w.schematic $X $Y3 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-e.schematic $X $Y3 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-n.schematic $X $Y3 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-s.schematic $X $Y3 $Z noair\n" if ( $psegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				# path cutout added to H group
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-path-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-pathext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};

		    } elsif ( $order eq "ci" ) {
			print BOUTPUT "# ci\n";

			# one-off: add beam decoration to canal dataset class
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# VU decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-w.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-e.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-n.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-s.schematic $X $Y3 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vubeam-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			# VI decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-w.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-e.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-n.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-s.schematic $X $Y2 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vibeam-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			# VD decoration
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/uppercanal-vdbeam-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);

			if ( ! $ssegid ) {
				# H decoration
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/lowercanal-hbeam-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};

			# add lighting to VD set
			print BOUTPUT "import $mc_schemroot/misc/canal-light-nw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/canal-light-ne.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/canal-light-sw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
			print BOUTPUT "import $mc_schemroot/misc/canal-light-se.schematic $X $Y1 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );

			if ( ! $ssegid ) {
				# add lighting to H set
				print BOUTPUT "import $mc_schemroot/misc/canal-light-nw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/canal-light-ne.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 4)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/canal-light-sw.schematic $X $Y4 $Z noair\n" if (( $psegid & (1 + 8)) == 0 );
				print BOUTPUT "import $mc_schemroot/misc/canal-light-se.schematic $X $Y4 $Z noair\n" if (( $psegid & (2 + 8)) == 0 );
			};

		    } elsif ( $order eq "llc" ) {
			print BOUTPUT "# llc\n";

			# one-off: add walkways to lower lava canal dataset
			my ( $X, $Y1, $Y2, $Y3, $Y4, $Z ) = ( $xcoord, $ycoord1, $ycoord2, $ycoord3, $ycoord4, $zcoord );
			# path along solid walls of VD group
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-w.schematic $X $Y1 $Z noair\n" if ( $psegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-e.schematic $X $Y1 $Z noair\n" if ( $psegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-n.schematic $X $Y1 $Z noair\n" if ( $psegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-s.schematic $X $Y1 $Z noair\n" if ( $psegid & 8);
			# path extending through wall opening on VD group
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-w.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 1));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-e.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 2));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-n.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 4));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-s.schematic $X $Y1 $Z noair\n" if ( ! ( $psegid & 8));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-w.schematic $X $Y1 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-e.schematic $X $Y1 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-n.schematic $X $Y1 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-s.schematic $X $Y1 $Z noair\n" if ( $ssegid & 8);
			# path support on inside corners
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-nw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1+4)) == (1+4));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-ne.schematic $X $Y1 $Z noair\n" if (( $psegid & (2+4)) == (2+4));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-sw.schematic $X $Y1 $Z noair\n" if (( $psegid & (1+8)) == (1+8));
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathcnr-se.schematic $X $Y1 $Z noair\n" if (( $psegid & (2+8)) == (2+8));
			# path ending with lava gate at constricted openings on VU, VI, and VD groups
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-w.schematic $X $Y3 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-e.schematic $X $Y3 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-n.schematic $X $Y3 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-s.schematic $X $Y3 $Z noair\n" if ( $ssegid & 8);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-w.schematic $X $Y2 $Z noair\n" if ( $ssegid & 1);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-e.schematic $X $Y2 $Z noair\n" if ( $ssegid & 2);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-n.schematic $X $Y2 $Z noair\n" if ( $ssegid & 4);
			print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathgate-s.schematic $X $Y2 $Z noair\n" if ( $ssegid & 8);
			if ( ! $ssegid ) {
				# path along solid walls of H group
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-w.schematic $X $Y4 $Z noair\n" if ( $psegid & 1);
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-e.schematic $X $Y4 $Z noair\n" if ( $psegid & 2);
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-n.schematic $X $Y4 $Z noair\n" if ( $psegid & 4);
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-path-s.schematic $X $Y4 $Z noair\n" if ( $psegid & 8);
				# path extending through wall opening on H group
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-w.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 1));
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-e.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 2));
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-n.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 4));
				print BOUTPUT "import $mc_schemroot/misc/lower-lavacanal-pathext-s.schematic $X $Y4 $Z noair\n" if ( ! ( $psegid & 8));
			};
		    };
		};
	};
	#------------------------------------------------------------------------------
	# build floor effect templates

	my $lsize = ( $mc_hscale * 4 );
	my $gsize = ( $lsize + 2 );
	my $lavazcoord = $mc_ztoffset + ( 0 * ( $lsize + 3 ) );
	my $swebzcoord = $mc_ztoffset + ( 1 * ( $lsize + 3 ) );
	my $xcoord = $mc_xtoffset + ( 0 * ( $lsize + 3 ) );
	my $ycoord = $ycoordl5 + 4;
	my $z1gcoord = ( $lavazcoord - 1 );
	my $z4gcoord = ( $swebzcoord - 1 );
	my $ygcoord = ( $ycoord );
	my $xgcoord = ( $xcoord );
	# my $level = ( $feffectlevel + 1 );
	my $hsize = ( $mc_hscale - (( $hco + $wfs + $wss ) * 2 ));
	my $halllen = (($mc_hscale - $hsize ) / 2 );

	print BOUTPUT "fill 20 $xgcoord $ygcoord $z1gcoord $gsize 1 $gsize\n";
	print IOUTPUT "fill 20 $xgcoord $ygcoord $z1gcoord $gsize 1 $gsize\n";

	print BOUTPUT "fill 0 $xcoord $ycoord $lavazcoord $lsize 1 $lsize\n";

	foreach my $xinc ( 0..($lsize-1) ) {
	    foreach my $zinc ( 0..($lsize-1) ) {
last;
		my $yrand = int( rand( 8 ) );
		my $yrand2 = int( rand( 8 ) );
		my ( $yinc, $yinc2 ) = (0, 0);

		$yinc += 1 if ( $yrand >= 1 );
		$yinc += 1 if ( $yrand >= 2 );
		$yinc += 2 if ( $yrand >= 4 );

		$yinc2 += 1 if ( $yrand2 >= 1 );
		$yinc2 += 1 if ( $yrand2 >= 2 );
		$yinc2 += 2 if ( $yrand2 >= 4 );
		
		my $xlcoord = $xcoord + $xinc;

		my $ylcoord = $ycoord + $yinc;
		my $zlcoord = $lavazcoord + $zinc;

		my $ylcoord2 = $ycoord + $yinc2;
		my $zlcoord2 = $swebzcoord + $zinc;

		print BOUTPUT "fill 87 $xlcoord $ylcoord $zlcoord 1 1 1\n";
		print BOUTPUT "fill 30 $xlcoord $ylcoord2 $zlcoord2 1 1 1\n";
	    };
	};

	# output import/export lines for lava/cobweb floor effect templates
	foreach my $level ( 1,2,4 ) {
		my $yinc = ( $ycoord + $level );
last;
		foreach my $xpos ( 0..3 ) {
		    my $xc = ( $xcoord + ( $xpos * $mc_hscale ));
		    foreach my $zpos ( 0..3 ) {
			my $zc = ( $lavazcoord + ( $zpos * $mc_hscale ));
			print EOUTPUT "export $mc_schemroot/misc/lava.b$level.$xpos$zpos.schematic ";
			print EOUTPUT "$xc $yinc $zc $mc_hscale 1 $mc_hscale\n";
			print EOUTPUT "export $mc_schemroot/misc/lavax.b$level.$xpos$zpos.schematic ";
			print EOUTPUT "$xc $yinc $zc $halllen 1 $mc_hscale\n";
			print EOUTPUT "export $mc_schemroot/misc/lavaz.b$level.$xpos$zpos.schematic ";
			print EOUTPUT "$xc $yinc $zc $mc_hscale 1 $halllen\n";
			print IOUTPUT "import $mc_schemroot/misc/lava.b$level.$xpos$zpos.schematic $xc $yinc $zc\n";
		    };
		};

		foreach my $block ( 0..15 ) {
		    foreach my $width ( 1 .. ( $mc_hscale - 1 ) ) {

			# skip odd hallway widths
			next if ( $width % 2 );

			# build hallway cobweb floor effect templates
			my $xpos = int( $block / 4 );
			my $zpos = ( $block % 4 );
			my $xc = ( $xcoord + ( $xpos * $width ));
			my $swebzc = ( $swebzcoord + ( $zpos * $width ));
			my $halllen = (($mc_hscale - $width ) / 2 );
			print EOUTPUT "export $mc_schemroot/misc/hsweb.w$width.b$level.$block.schematic ";
			print EOUTPUT "$xc $yinc $swebzc $width 1 $width\n";
			print EOUTPUT "export $mc_schemroot/misc/hswebx.w$width.b$level.$block.schematic ";
			print EOUTPUT "$xc $yinc $swebzc $halllen 1 $width\n";
			print EOUTPUT "export $mc_schemroot/misc/hswebz.w$width.b$level.$block.schematic ";
			print EOUTPUT "$xc $yinc $swebzc $width 1 $halllen\n";
			if ( $width == ( $mc_hscale - 2 ) ) {
				print IOUTPUT "import $mc_schemroot/misc/hsweb.w$width.l$level.$block.schematic $xc $ycoord $swebzc\n";
			};

			# build room cobweb floor effect templates
			my $rwsize = (($mc_hscale - $width ) / 2 );
			$xc = ( $xcoord + ( $xpos * $mc_hscale ));
			$swebzc = ( $swebzcoord + ( $zpos * $mc_hscale ));
			my ($xs, $zs) = ($mc_hscale, $mc_hscale);
			$xs -= $rwsize if ( $block & 1 );
			$xs -= $rwsize if ( $block & 2 );
			$zs -= $rwsize if ( $block & 4 );
			$zs -= $rwsize if ( $block & 8 );
			print EOUTPUT "export $mc_schemroot/misc/rsweb.w$width.b$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $swebzc $xs 1 $zs\n";
			# print IOUTPUT "import $mc_schemroot/misc/rsweb.w$width.l$level.$block.schematic $xc $ycoord $swebzc\n";
		    };
		}
	};

	foreach my $feffectlevel ( 0..2 ) {
last;
		my $lsize = ( $mc_hscale * 4 );
		my $ssize = ( $mc_hscale * 4 );
		my $gsize = ( $lsize + 2 );
		my $lavazcoord = $mc_ztoffset + ( 0 * ( $lsize + 3 ) );
		my $sandzcoord = $mc_ztoffset + ( 1 * ( $lsize + 3 ) );
		my $gravzcoord = $mc_ztoffset + ( 2 * ( $lsize + 3 ) );
		my $xcoord = $mc_xtoffset + ( ($lsize + 3) * $feffectlevel );
		my $ycoord = $ycoordl4 + 4;
		my $z1gcoord = ( $lavazcoord - 1 );
		my $z2gcoord = ( $sandzcoord - 1 );
		my $z3gcoord = ( $gravzcoord - 1 );
		my $ygcoord = ( $ycoord - 1 );
		my $xgcoord = ( $xcoord - 1 );
		my $level = ( $feffectlevel + 1 );
		my $hsize = ( $mc_hscale - (( $hco + $wfs + $wss ) * 2 ));
		my $halllen = (($mc_hscale - $hsize ) / 2 );

		# print BOUTPUT "fill 20 $xgcoord $ygcoord $z1gcoord $gsize 1 $gsize\n";
		print BOUTPUT "fill 20 $xgcoord $ygcoord $z2gcoord $gsize 1 $gsize\n";
		print BOUTPUT "fill 20 $xgcoord $ygcoord $z3gcoord $gsize 1 $gsize\n";
		# print IOUTPUT "fill 20 $xgcoord $ygcoord $z1gcoord $gsize 1 $gsize\n";
		print IOUTPUT "fill 20 $xgcoord $ygcoord $z2gcoord $gsize 1 $gsize\n";
		print IOUTPUT "fill 20 $xgcoord $ygcoord $z3gcoord $gsize 1 $gsize\n";

		# print BOUTPUT "fill 0 $xcoord $ycoord $lavazcoord $lsize 1 $lsize\n";
		print BOUTPUT "fill 0 $xcoord $ycoord $sandzcoord $lsize 1 $lsize\n";
		print BOUTPUT "fill 0 $xcoord $ycoord $gravzcoord $lsize 1 $lsize\n";

		# my $density = ( $mc_hscale * $mc_hscale * ( $feffectlevel + 1 ) * 4);
		# foreach my $lava ( 1..$density ) {
		# 	my $xrand = $xcoord + int(rand( $lsize ) );
		# 	my $zrand = $lavazcoord + int(rand( $lsize ) );
		# 	print BOUTPUT "fill 11 $xrand $ycoord $zrand 1 1 1\n";
		# };

		foreach my $xinc ( $xcoord .. ( $xcoord + $lsize - 1 )) {
		    foreach my $zinc ( $sandzcoord .. ( $sandzcoord + $ssize - 1 )) {
			my $sandrand = ( $feffectlevel + int(rand(3)));
			print BOUTPUT "fill 12 $xinc $ycoord $zinc 1 $sandrand 1\n" if $sandrand;
		    }
		    foreach my $zinc ( $gravzcoord .. ( $gravzcoord + $ssize - 1 )) {
			my $gravrand = ( $feffectlevel + int(rand(3)));
			print BOUTPUT "fill 13 $xinc $ycoord $zinc 1 $gravrand 1\n" if $gravrand;
		    }
		}

		# output import/export lines for sand/gravel floor effect templates
		foreach my $block ( 0..15 ) {
		    foreach my $width ( 1 .. ( $mc_hscale - 1 ) ) {

			# skip odd hallway widths
			next if ( $width % 2 );

			# build hallway sand/grand floor effect templates
			my $xpos = int( $block / 4 );
			my $zpos = ( $block % 4 );
			my $xc = ( $xcoord + ( $xpos * $width ));
			my $sandzc = ( $sandzcoord + ( $zpos * $width ));
			my $gravzc = ( $gravzcoord + ( $zpos * $width ));
			my $halllen = (($mc_hscale - $width ) / 2 );
			print EOUTPUT "export $mc_schemroot/misc/hsand.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $sandzc $width 3 $width\n";
			print EOUTPUT "export $mc_schemroot/misc/hsandx.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $sandzc $halllen 3 $width\n";
			print EOUTPUT "export $mc_schemroot/misc/hsandz.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $sandzc $width 3 $halllen\n";
			print EOUTPUT "export $mc_schemroot/misc/hgrav.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $gravzc $width 3 $width\n";
			print EOUTPUT "export $mc_schemroot/misc/hgravx.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $gravzc $halllen 3 $width\n";
			print EOUTPUT "export $mc_schemroot/misc/hgravz.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $gravzc $width 3 $halllen\n";
			if ( $width == ( $mc_hscale - 2 ) ) {
				print IOUTPUT "import $mc_schemroot/misc/hsand.w$width.l$level.$block.schematic $xc $ycoord $sandzc\n";
				print IOUTPUT "import $mc_schemroot/misc/hgrav.w$width.l$level.$block.schematic $xc $ycoord $gravzc\n";
			};

			# build room sand/grand floor effect templates
			# my $rwsize = ( $hco + $wfs + $wss );
			my $rwsize = (($mc_hscale - $width ) / 2 );
			$xc = ( $xcoord + ( $xpos * $mc_hscale ));
			$sandzc = ( $sandzcoord + ( $zpos * $mc_hscale ));
			$gravzc = ( $gravzcoord + ( $zpos * $mc_hscale ));
			my ($xs, $zs) = ($mc_hscale, $mc_hscale);
			$xs -= $rwsize if ( $block & 1 );
			$xs -= $rwsize if ( $block & 2 );
			$zs -= $rwsize if ( $block & 4 );
			$zs -= $rwsize if ( $block & 8 );
			print EOUTPUT "export $mc_schemroot/misc/rsand.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $sandzc $xs 3 $zs\n";
			print EOUTPUT "export $mc_schemroot/misc/rgrav.w$width.l$level.$block.schematic ";
			print EOUTPUT "$xc $ycoord $gravzc $xs 3 $zs\n";
			# print IOUTPUT "import $mc_schemroot/misc/rsand.w$width.l$level.$block.schematic $xc $ycoord $sandzc\n";
			# print IOUTPUT "import $mc_schemroot/misc/rgrav.w$width.l$level.$block.schematic $xc $ycoord $gravzc\n";
		    };
		};
	};
	#------------------------------------------------------------------------------
	# build the doorway/archway templates

	# doorwaytype is 0 for door and 1 for arch
	foreach my $doorwaytype ( 0..1 ) {

	    my $doorwayname = "door";
	    $doorwayname = "arch" if $doorwaytype;

	    # doorset is 0 for hallway doors and 1 for room doors
	    foreach my $doorset ( 0..1 ) {

		# doorway height is adjusted by door/arch parameters and optional FEV value
		my $doorheight = 6 + $buildfev - ( $vco + $ffs + $fss ) + $doorwaytype;

		# doorway thickness is the hallway/room wall thickness
		my $doorwaythick = $hco + $wfs + $wss;
		$doorwaythick = $hco + $wfs + $wss if $doorset;

		# determine the doorway/archway thickness
		my $doorwidthinc = $doorwaytype + 1;
		my $doorwayheight = ( $doorheight + 2 );
		my $doorhstart = ( ceil(($mc_hscale-2)/2) - $doorwidthinc );
		my $doorwayhstart = ( ceil(($mc_hscale-2)/2) - $doorwidthinc - 1 );
		my $doorwaywidth = ( $mc_hscale - 2 - ( $doorwayhstart * 2 ));
		my $doorwidth = ( $mc_hscale - 2 - ( $doorhstart * 2 ));

		# doorway type and door set determine which level to place doors on
		my $ycoord = ( $ycoordl1 + 2);
		$ycoord = ($ycoordl2 + 2) if $doorwaytype && ! $doorset;
		$ycoord = ($ycoordl3 + 2) if ! $doorwaytype && $doorset;
		$ycoord = ($ycoordl4 + 2) if $doorwaytype && $doorset;

		# direction is 0/1/2/3 = west/east/north/south
		foreach my $direction ( 0..3 ) {
			# doortype is the unique door style
			foreach my $doortype ( 0..15 ) {

				# X and Z coordinates are adjusted based on door type and direction
				my $xcoord = ($mc_xtoffset + ($doortype * ($mc_hscale + 3 )) + 3 );
				my $zcoord = ($mc_ztoffset +  ((13 + $direction) * ($mc_hscale + 3)) + 3 );

				my $dir = ( $direction + 1 );

				# determine doorway coordinates based on door direction
				my $ystart = $ycoord + $ffs;
				$ystart = $ycoord + $ffs if $doorset;
				my $yostart = $ystart + 1;
				my $ysize = $mc_vscale - 2;
				my $yosize = $doorheight;
				my ( $xostart, $zostart ) = ( $xcoord + $doorhstart, $zcoord + $doorhstart );
				my ( $xsize, $zsize ) = ( $mc_hscale - 2, $mc_hscale - 2 );
				my ( $xosize, $zosize ) = ( $doorwidth, $doorwidth );
				if ( $direction == 0 || $direction == 1 ) {
					$xsize = $doorwaythick;
					$xosize = $doorwaythick;
					$xostart = $xcoord;
				} elsif ( $direction == 2 || $direction == 3 ) {
					$zsize = $doorwaythick;
					$zosize = $doorwaythick;
					$zostart = $zcoord;
				};

				# write out the creation entries.  Door type 15 is created as solid wall
				print BOUTPUT "fill $wst $xcoord $ycoord $zcoord $xsize $ysize $zsize\n";
				print BOUTPUT "fill $omt $xostart $yostart $zostart $xosize $yosize $zosize\n" if ($doortype != 15);
				print BOUTPUT "fill $fst $xostart $ystart $zostart $xosize $fss $zosize\n" if ( $fss && ( $doortype != 15 ) );

				# write out the import/export entries
				if ( $doorset ) {
					print EOUTPUT "export $mc_schemroot/$defaultset/r$doorwayname$doortype-$dir.schematic ";
					print EOUTPUT "$xcoord $ycoord $zcoord $xsize $ysize $zsize\n";

					print IOUTPUT "import $mc_schemroot/$defaultset/r$doorwayname$doortype-$dir.schematic $xcoord $ycoord $zcoord\n";
				} else {
					print EOUTPUT "export $mc_schemroot/$defaultset/h$doorwayname$doortype-$dir.schematic ";
					print EOUTPUT "$xcoord $ycoord $zcoord $xsize $ysize $zsize\n";

					print IOUTPUT "import $mc_schemroot/$defaultset/h$doorwayname$doortype-$dir.schematic $xcoord $ycoord $zcoord\n";
				}
			}
		}
	    }
	}

	#------------------------------------------------------------------------------
	# build crossover access templates
	for my $csval ( 2..7 ) {
		my $xcoord = ($mc_xtoffset + (($csval - 2 ) * ($mc_hscale + 3 )) + 3 );
		my $ycoord = $ycoordl4 + 4;
		my $zcoord = ($mc_ztoffset + (10 * ($mc_hscale + 3)) + 3 );
		my  $width = 4;
		my ( $toheight, $boheight ) = ( 2, 3 );
		my $height = $toheight + 2;
		my $depth = ( $hco + $wfs + $wss );
		my $owidth = $width - 2;
		my $odepth = 1;
		my $todepth = ( $odepth + 1 );
		my $bodepth = ( $depth - 1 );
		my $tstart = $ycoord + $mc_vscale - $height;
		my $tostart = $tstart + 1;
		my $xocoord = $xcoord + 1;
		my $yocoord = $ycoord + 1;
		my $zocoord = $zcoord + 1;
		my $yccoord = $ycoord + $mc_vscale - 1;
		my $yfcoord = $ycoord;
		my $xfcoord = $xcoord + $width - 1;
		my $zfcoord = $zcoord + $width - 1;

		# write out import/export/build lines
		if ( $csval == 2 ) {
			print IOUTPUT "import $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord\n";

			print EOUTPUT "export $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord $mc_hscale $height $width\n";

			print BOUTPUT "fill $cmt $xcoord $ycoord $zcoord $mc_hscale $height $width\n";
			print BOUTPUT "fill $omt $xcoord $yocoord $zocoord $mc_hscale $toheight $owidth\n";
		} elsif ( $csval == 3 ) {
			print IOUTPUT "import $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord\n";

			print EOUTPUT "export $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord $width $height $mc_hscale\n";

			print BOUTPUT "fill $cmt $xcoord $ycoord $zcoord $width $height $mc_hscale\n";
			print BOUTPUT "fill $omt $xocoord $yocoord $zcoord $owidth $toheight $mc_hscale\n";
		} elsif ( $csval == 4 ) {
			print IOUTPUT "import $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord\n";

			print EOUTPUT "export $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord $depth $mc_vscale $width\n";

			# build the vertical tube
			print BOUTPUT "fill $wst $xcoord $ycoord $zcoord $depth $mc_vscale $width\n";
			print BOUTPUT "fill $omt $xocoord $ycoord $zocoord $odepth $mc_vscale $owidth\n";
			# cap the top in bedrock
			print BOUTPUT "fill $cmt $xcoord $yccoord $zcoord $depth 1 $width\n";
			# build the floor
			print BOUTPUT "fill $cmt $xcoord $yfcoord $zcoord $depth $vco $width\n" if $vco;
			$yfcoord += $vco;
			print BOUTPUT "fill $fft $xcoord $yfcoord $zcoord $depth $ffs $width\n" if $ffs;
			$yfcoord += $ffs;
			print BOUTPUT "fill $fst $xcoord $yfcoord $zcoord $depth $fss $width\n" if $fss;
			$yfcoord += $fss;
			# add bottom opening
			print BOUTPUT "fill $omt $xocoord $yfcoord $zocoord $bodepth $boheight $owidth\n";
			# add the ladder
			print BOUTPUT "replace $omt with 65:5 $xocoord $ycoord $zocoord $odepth $mc_vscale $owidth\n";
			# add the top opening
			print BOUTPUT "fill $omt $xcoord $tostart $zocoord $todepth $toheight $owidth\n";
		} elsif ( $csval == 5 ) {
			$xfcoord = $xcoord + $depth - 1;
			$xocoord = $xfcoord - 1;

			print IOUTPUT "import $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord\n";

			print EOUTPUT "export $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord $depth $mc_vscale $width\n";

			print BOUTPUT "fill $wst $xcoord $ycoord $zcoord $depth $mc_vscale $width\n";
			print BOUTPUT "fill $omt $xocoord $ycoord $zocoord $odepth $mc_vscale $owidth\n";
			print BOUTPUT "fill $cmt $xcoord $yccoord $zcoord $depth 1 $width\n";
			print BOUTPUT "fill $cmt $xcoord $yfcoord $zcoord $depth $vco $width\n" if $vco;
			$yfcoord += $vco;
			print BOUTPUT "fill $fft $xcoord $yfcoord $zcoord $depth $ffs $width\n" if $ffs;
			$yfcoord += $ffs;
			print BOUTPUT "fill $fst $xcoord $yfcoord $zcoord $depth $fss $width\n" if $fss;
			$yfcoord += $fss;
			print BOUTPUT "fill $omt $xcoord $yfcoord $zocoord $bodepth $boheight $owidth\n";
			print BOUTPUT "replace $omt with 65:4 $xocoord $ycoord $zocoord $odepth $mc_vscale $owidth\n";
			print BOUTPUT "fill $omt $xocoord $tostart $zocoord $todepth $toheight $owidth\n";
		} elsif ( $csval == 6 ) {
			print IOUTPUT "import $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord\n";

			print EOUTPUT "export $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord $width $mc_vscale $depth\n";

			print BOUTPUT "fill $wst $xcoord $ycoord $zcoord $width $mc_vscale $depth\n";
			print BOUTPUT "fill $omt $xocoord $ycoord $zocoord $owidth $mc_vscale $odepth\n";
			print BOUTPUT "fill $cmt $xcoord $yccoord $zcoord $width 1 $depth\n";
			print BOUTPUT "fill $cmt $xcoord $yfcoord $zcoord $width $vco $depth\n" if $vco;
			$yfcoord += $vco;
			print BOUTPUT "fill $fft $xcoord $yfcoord $zcoord $width $ffs $depth\n" if $ffs;
			$yfcoord += $ffs;
			print BOUTPUT "fill $fst $xcoord $yfcoord $zcoord $width $fss $depth\n" if $fss;
			$yfcoord += $fss;
			print BOUTPUT "fill $omt $xocoord $yfcoord $zocoord $owidth $boheight $bodepth\n";
			print BOUTPUT "replace $omt with 65:3 $xocoord $ycoord $zocoord $owidth $mc_vscale $odepth\n";
			print BOUTPUT "fill $omt $xocoord $tostart $zcoord $owidth $toheight $todepth\n";
		} elsif ( $csval == 7 ) {
			$zfcoord = $zcoord + $depth - 1;
			$zocoord = $zfcoord - 1;
			
			print IOUTPUT "import $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord\n";

			print EOUTPUT "export $mc_schemroot/$defaultset/crossover$csval.schematic $xcoord $ycoord $zcoord $width $mc_vscale $depth\n";

			print BOUTPUT "fill $wst $xcoord $ycoord $zcoord $width $mc_vscale $depth\n";
			print BOUTPUT "fill $omt $xocoord $ycoord $zocoord $owidth $mc_vscale $odepth\n";
			print BOUTPUT "fill $cmt $xcoord $yccoord $zcoord $width 1 $depth\n";
			print BOUTPUT "fill $cmt $xcoord $yfcoord $zcoord $width $vco $depth\n" if $vco;
			$yfcoord += $vco;
			print BOUTPUT "fill $fft $xcoord $yfcoord $zcoord $width $ffs $depth\n" if $ffs;
			$yfcoord += $ffs;
			print BOUTPUT "fill $fst $xcoord $yfcoord $zcoord $width $fss $depth\n" if $fss;
			$yfcoord += $fss;
			print BOUTPUT "fill $omt $xocoord $yfcoord $zcoord $owidth $boheight $bodepth\n";
			print BOUTPUT "replace $omt with 65:2 $xocoord $ycoord $zocoord $owidth $mc_vscale $odepth\n";
			print BOUTPUT "fill $omt $xocoord $tostart $zocoord $owidth $toheight $todepth\n";
		}
	}

	# build the custom floor/ceiling design for the unstable tunnel type
	if ( $defaultset eq "unstable-tunnel" ) {

	    foreach my $group (0 .. 1 ) {

		my $ceiling = $vco + $css + $cfs;
		my $floor = $vco + $fss + $ffs;
		my $wall = $hco + $wss + $wfs;

		my $hallwidth = $mc_hscale - ( $wall * 2 );
		my $halllen = (($mc_hscale - $hallwidth ) / 2 );
		my $hallheight = $mc_vscale - $ceiling - $floor;
		$hallheight += $mc_vscale if $group;
		my $totalheight = $mc_vscale + ( $mc_vscale * $group );

		my $lsize = ( $mc_hscale * 4 );

		my $xcoord = $mc_xtoffset + ( ( $lsize + 3) * $group );
		my $ycoord = $ycoordl6 + 1;
		my $yfcoord = $ycoord;
		my $yccoord = $ycoordl6 + $mc_vscale + 1;
		$yccoord += $mc_vscale if $group;
		my $zcoord = $mc_ztoffset + ( 0 * ( $lsize + 3 ) );


		# build the floor layers
		print BOUTPUT "fill $cmt $xcoord $yfcoord $zcoord $lsize $vco $lsize\n" if $vco;
		$yfcoord += $vco;
		print BOUTPUT "fill $fft $xcoord $yfcoord $zcoord $lsize $ffs $lsize\n" if $ffs;
		$yfcoord += $ffs;
		print BOUTPUT "fill $fst $xcoord $yfcoord $zcoord $lsize $fss $lsize\n" if $fss;
		my $yflayer = $yfcoord;
		$yfcoord += $fss;

		# build the ceiling layers
		$yccoord -= $vco;
		print BOUTPUT "fill $cmt $xcoord $yccoord $zcoord $lsize $vco $lsize\n" if $vco;
		$yccoord -= $cfs;
		print BOUTPUT "fill $fft $xcoord $yccoord $zcoord $lsize $cfs $lsize\n" if $cfs;
		$yccoord -= $css;
		print BOUTPUT "fill $fst $xcoord $yccoord $zcoord $lsize $css $lsize\n" if $css;

		# clear out open space
		print BOUTPUT "fill $omt $xcoord $yfcoord $zcoord $lsize $hallheight $lsize\n";

		foreach my $xinc ( $xcoord .. ( $xcoord + $lsize - 1 )) {
		    foreach my $zinc ( $zcoord .. ( $zcoord + $lsize - 1 )) {
			next if ( int(rand(15)));
			if ( int(rand(5))) {
				# build a random-height gravel column on top of a single cobble block, and
				# use a snow block as a placeholder for the hole created in the ceiling
				my $grheight = (1 + int(rand($hallheight)));
				print BOUTPUT "fill 13 $xinc $yfcoord $zinc 1 $grheight 1\n";
				print BOUTPUT "fill 4 $xinc $yfcoord $zinc 1 1 1\n";
				print BOUTPUT "fill 80 $xinc $yccoord $zinc 1 1 1\n";
			} else {
				print BOUTPUT "fill 11 $xinc $yflayer $zinc 1 1 1\n";
			}
		    }
		}

		# output import/export lines for custom floor templates
		foreach my $block ( 0..15 ) {
			# build hallway templates
			my $xpos = int( $block / 4 );
			my $zpos = ( $block % 4 );
			my $xc = ( $xcoord + ( $xpos * $hallwidth ));
			my $zc = ( $zcoord + ( $zpos * $hallwidth ));
			print EOUTPUT "export $mc_schemroot/$defaultset/hcustfloor$group.$block.schematic ";
			print EOUTPUT "$xc $ycoord $zc $hallwidth $totalheight $hallwidth\n";
			print EOUTPUT "export $mc_schemroot/$defaultset/hcustfloorx$group.$block.schematic ";
			print EOUTPUT "$xc $ycoord $zc $halllen $totalheight $hallwidth\n";
			print EOUTPUT "export $mc_schemroot/$defaultset/hcustfloorz$group.$block.schematic ";
			print EOUTPUT "$xc $ycoord $zc $hallwidth $totalheight $halllen\n";
			print IOUTPUT "import $mc_schemroot/$defaultset/hcustfloor$group.$block.schematic $xc $ycoord $zc\n";

			# build room templates
			$xc = ( $xcoord + ( $xpos * $mc_hscale ));
			$zc = ( $zcoord + ( $zpos * $mc_hscale ));
			my ($xs, $zs) = ($mc_hscale, $mc_hscale);
			$xs -= $wall if ( $block & 1 );
			$xs -= $wall if ( $block & 2 );
			$zs -= $wall if ( $block & 4 );
			$zs -= $wall if ( $block & 8 );
			print EOUTPUT "export $mc_schemroot/$defaultset/rcustfloor$group.$block.schematic ";
			print EOUTPUT "$xc $ycoord $zc $xs $totalheight $zs\n";
			print IOUTPUT "import $mc_schemroot/$defaultset/rcustfloor$group.$block.schematic $xc $ycoord $zc\n";
		};
	    }
	};

	# convert flowing materials to placeholder materials
	print BOUTPUT "replace 8 with 22 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print BOUTPUT "replace 9 with 21 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print BOUTPUT "replace 10 with 88 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print BOUTPUT "replace 11 with 87 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print IOUTPUT "replace 8 with 22 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print IOUTPUT "replace 9 with 21 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print IOUTPUT "replace 10 with 88 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print IOUTPUT "replace 11 with 87 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 8 with 22 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 9 with 21 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 10 with 88 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";
	print EOUTPUT "replace 11 with 87 $mc_xtoffset $mc_ytoffset $mc_ztoffset $xboxsize $yboxsize $zboxsize\n";

	close(BOUTPUT);
	close(IOUTPUT);
	close(EOUTPUT);
};

#------------------------------------------------------------------------------
# printvhefills - output fill commands for building VHE blocks

sub printvhefills {

	my ( $cfillval, $fillval, $YHS1, $YHS2, $YCS1, $YCS2, $HW1, $HW2, $HW3, $CW1, $CW2, $CW3, $b4_dsflag, $b5_dsflag ) = @_;

	# absolute coordinates of the VHE levels
	my $ycoord1 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 0 ) + 1);
	my $ycoord2 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 1 ) + 1);
	my $ycoord3 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 2 ) + 1);
	my $ycoord4 = (($mc_ytoffset + ( $mc_vscale + 4 ) * 3 ) + 1);

	# relative Y coordinates and sizes of the bottom, middle, and top layers
	my @YHC = ( 0, 0, $YHS1, ($YHS1+$YHS2) );
	my @YHS = ( 0, $YHS1, $YHS2, ($mc_vscale-$YHS1-$YHS2) );
	my @YCC = ( 0, 0, $YCS1, ($YCS1+$YCS2) );
	my @YCS = ( 0, $YCS1, $YCS2, ($mc_vscale-$YCS1-$YCS2) );

	# relative X/Z coordinates and sizes of bottom, middle, and top layers
	my @HHC = ( 0, ( ($mc_hscale - $HW1) / 2 ), ( ( $mc_hscale - $HW2 ) / 2 ), ( ( $mc_hscale - $HW3 ) / 2 ) );
	my @HCC = ( 0, ( ($mc_hscale - $CW1) / 2 ), ( ( $mc_hscale - $CW2 ) / 2 ), ( ( $mc_hscale - $CW3 ) / 2 ) );
	my @HHS = ( 0, $HW1, $HW2, $HW3 );
	my @HCS = ( 0, $CW1, $CW2, $CW3 );

	my ($hhalf, $chhalf, $fhhalf ) = ( int( $mc_hscale / 2 ), ceil( $mc_hscale / 2 ), floor( $mc_hscale / 2 ) );
	my ($vhalf, $cvhalf, $fvhalf ) = ( int( $mc_vscale / 2 ), ceil( $mc_vscale / 2 ), floor( $mc_vscale / 2 ) );

	foreach my $seg ( 0..80 ) {
		my $hseg = ( $seg & 15 );
		my $vseg = ( ($seg & 112)>>4 );

		# wall types: 0=open, 1=constricted, 2=solid
		my $w1t = $seg % 3;
		my $w2t = int($seg / 3) % 3;
		my $w3t = int($seg / 9) % 3;
		my $w4t = int($seg / 27) % 3;

		# psegid: bitmap of solid walls, ssegid: bitmap of constricted walls
		my ( $ssegid, $psegid ) = (0, 0);
		$ssegid += 1 if $w1t == 1;
		$ssegid += 2 if $w2t == 1;
		$ssegid += 4 if $w3t == 1;
		$ssegid += 8 if $w4t == 1;
		$psegid += 1 if $w1t == 2;
		$psegid += 2 if $w2t == 2;
		$psegid += 4 if $w3t == 2;
		$psegid += 8 if $w4t == 2;

		# coordinate of horizontal corner of object
		my $xcoord = ($mc_xtoffset + ($hseg * ($mc_hscale + 3)) + 3 );
		my $zcoord = ($mc_ztoffset + (($vseg + 0) * ($mc_hscale + 3)) + 3 );

		foreach my $pass ( 1..3 ) {

			# Y layer height
			my $yhs = $YHS[$pass];
			my $ycs = $YCS[$pass];

			# skip this pass if layer height is zero.
			next if ( ! $yhs );

			# Y coordinates for boxes
			my $vd_yhc = $YHC[$pass] + $ycoord1;
			my $vi_yhc = $YHC[$pass] + $ycoord2;
			my $vu_yhc = $YHC[$pass] + $ycoord3;
			my $h_yhc = $YHC[$pass] + $ycoord4;
			my $vd_ycc = $YCC[$pass] + $ycoord1;
			my $vi_ycc = $YCC[$pass] + $ycoord2;
			my $vu_ycc = $YCC[$pass] + $ycoord3;
			my $h_ycc = $YCC[$pass] + $ycoord4;

			# N/S box coordinates
			my $xsc = $HHC[$pass] + $xcoord;
			my $znc = $zcoord;
			my $zfc = $zcoord + $fhhalf;

			# W/E box coordinates
			my $zsc = $HHC[$pass] + $zcoord;
			my $xnc = $xcoord;
			my $xfc = $xcoord + $fhhalf;

			my $xzs = $chhalf;
			my $hss = $HHS[$pass];

			# center box coordinates
			my $xcc = $HCC[$pass] + $xcoord;
			my $xcs = $HCS[$pass];
			my $zcc = $HCC[$pass] + $zcoord;
			my $zcs = $HCS[$pass];

			# limit to center fill if hallway width matches horizontal scale (used for initial fill)
			if ( $hss == $mc_hscale ) {
				# output center fills for VD/VI/VU/H
				print BOUTPUT "fill $cfillval $xcc $vd_ycc $zcc $xcs $ycs $zcs\n" if ( $pass != 1 );
				print BOUTPUT "fill $cfillval $xcc $vi_ycc $zcc $xcs $ycs $zcs\n";
				print BOUTPUT "fill $cfillval $xcc $vu_ycc $zcc $xcs $ycs $zcs\n" if ( $pass != 3 );
				print BOUTPUT "fill $cfillval $xcc $h_ycc $zcc $xcs $ycs $zcs\n" if ( $pass == 2 && $ssegid == 0);

				next;
			};

			if ( ( $pass == 1 && $b5_dsflag == 0 ) || ( $pass == 2 ) || ( $pass == 3 && $b4_dsflag == 0 ) ) {

			    # output W/E/N/S fills for VD
			    print BOUTPUT "fill $fillval $xnc $vd_yhc $zsc $fhhalf $yhs $hss\n" if (( $pass == 2 && $w1t != 2 )||( $pass == 3 && $w1t == 0 ));
			    print BOUTPUT "fill $fillval $xfc $vd_yhc $zsc $fhhalf $yhs $hss\n" if (( $pass == 2 && $w2t != 2 )||( $pass == 3 && $w2t == 0 ));
			    print BOUTPUT "fill $fillval $xsc $vd_yhc $znc $hss $yhs $fhhalf\n" if (( $pass == 2 && $w3t != 2 )||( $pass == 3 && $w3t == 0 ));
			    print BOUTPUT "fill $fillval $xsc $vd_yhc $zfc $hss $yhs $fhhalf\n" if (( $pass == 2 && $w4t != 2 )||( $pass == 3 && $w4t == 0 ));

			    # output W/E/N/S fills for VI
			    print BOUTPUT "fill $fillval $xnc $vi_yhc $zsc $fhhalf $yhs $hss\n" if (( $pass == 2 && $w1t != 2 )||( $pass != 2 && $w1t == 0 ));
			    print BOUTPUT "fill $fillval $xfc $vi_yhc $zsc $fhhalf $yhs $hss\n" if (( $pass == 2 && $w2t != 2 )||( $pass != 2 && $w2t == 0 ));
			    print BOUTPUT "fill $fillval $xsc $vi_yhc $znc $hss $yhs $fhhalf\n" if (( $pass == 2 && $w3t != 2 )||( $pass != 2 && $w3t == 0 ));
			    print BOUTPUT "fill $fillval $xsc $vi_yhc $zfc $hss $yhs $fhhalf\n" if (( $pass == 2 && $w4t != 2 )||( $pass != 2 && $w4t == 0 ));

			    # output W/E/N/S fills for VU
			    print BOUTPUT "fill $fillval $xnc $vu_yhc $zsc $fhhalf $yhs $hss\n" if (( $pass == 2 && $w1t != 2 )||( $pass == 1 && $w1t == 0 ));
			    print BOUTPUT "fill $fillval $xfc $vu_yhc $zsc $fhhalf $yhs $hss\n" if (( $pass == 2 && $w2t != 2 )||( $pass == 1 && $w2t == 0 ));
			    print BOUTPUT "fill $fillval $xsc $vu_yhc $znc $hss $yhs $fhhalf\n" if (( $pass == 2 && $w3t != 2 )||( $pass == 1 && $w3t == 0 ));
			    print BOUTPUT "fill $fillval $xsc $vu_yhc $zfc $hss $yhs $fhhalf\n" if (( $pass == 2 && $w4t != 2 )||( $pass == 1 && $w4t == 0 ));

			    if ( $ssegid == 0 ) {
				# output W/E/N/S fills for H
				print BOUTPUT "fill $fillval $xnc $h_yhc $zsc $fhhalf $yhs $hss\n" if ( $pass == 2 && $w1t != 2 );
				print BOUTPUT "fill $fillval $xfc $h_yhc $zsc $fhhalf $yhs $hss\n" if ( $pass == 2 && $w2t != 2 );
				print BOUTPUT "fill $fillval $xsc $h_yhc $znc $hss $yhs $fhhalf\n" if ( $pass == 2 && $w3t != 2 );
				print BOUTPUT "fill $fillval $xsc $h_yhc $zfc $hss $yhs $fhhalf\n" if ( $pass == 2 && $w4t != 2 );
			    };
			};

			# output center fills for VD/VI/VU/H
			print BOUTPUT "fill $cfillval $xcc $vd_ycc $zcc $xcs $ycs $zcs\n" if ( $pass != 1 );
			print BOUTPUT "fill $cfillval $xcc $vi_ycc $zcc $xcs $ycs $zcs\n";
			print BOUTPUT "fill $cfillval $xcc $vu_ycc $zcc $xcs $ycs $zcs\n" if ( $pass != 3 );
			print BOUTPUT "fill $cfillval $xcc $h_ycc $zcc $xcs $ycs $zcs\n" if ( $pass == 2 && $ssegid == 0);
		};
	};
};

#------------------------------------------------------------------------------
# printmcesch - print mce output file with schematics imports

sub printmcesch {
	open(OUTPUT, ">$fileprefix.mce");

	print OUTPUT "dimension $mc_dim_dungeon\n";
	print OUTPUT "log $mc_log_dungeon\n";

	foreach my $thread ( 1 .. $totalthreads ) {
		my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) = getthreadinfo( $thread );

		# open up the entryway into the dungeon on the maze array if it is a hallway cell
		my $startroom = getroomid( $STX, $STY, $STZ );
		if ( $startroom == 0 ) {
			my $entrydir = 5;
			$entrydir = 6 if $invertlevels;
			my ( $fdirmask, $rdirmask, $sfdirmask, $srdirmask ) = getdirmasks($entrydir);
			$mazegrid[$STX][$STY][$STZ] = (( $mazegrid[$STX][$STY][$STZ] | $fdirmask ) ^ $fdirmask );
			$auxmazegrid[$STX][$STY][$STZ] = (( $auxmazegrid[$STX][$STY][$STZ] | $sfdirmask ) ^ $sfdirmask );
		};
	};

	# render the cell grid for the dungeon
	foreach my $yincr (1 .. $ymazesize ) {
	    my $yinc = $ymazesize - $yincr;
		
	    my $yscale = getyscale( $yinc );
	    my $ycoord = ( $mc_yoffset - ( $yscale * ( $yinc + 1 )) + 1 );
	    my $yplushalf = $ycoord + floor( $yscale / 2 );
	    my $yfcoord = ( $ycoord + $yscale - 1 );

	    # get level class flags
	    my $emptyblocks = getlevelflag( $yinc, 8 );

       	    foreach my $zinc (0 .. $zmazesize-1) {
		my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );
		my $zfcoord = ( $zcoord + $mc_hscale - 1 );

        	foreach my $xinc (0 .. $xmazesize-1) {
			my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );
			my $xfcoord = ( $xcoord + $mc_hscale - 1 );

			# get cell information
			my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
				getcellinfo( $xinc, $yinc, $zinc );
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );

			# get cell style information if global style is enabled for hallway
			my ( $hfound_b42, $hflag_b42 ) = gethallflag( $xinc, $yinc, $zinc, 42 );
			my $style = 0;
			if ( $hflag_b42 ) {
				my ( $gstyle, $lstyle ) = gethallstyle( $xinc, $yinc, $zinc );
				my $stylestr = gethallinfo( $xinc, $yinc, $zinc, 1, 3 );
				my ( $stywgt, $styrtype ) = parsestylestring( $stylestr, '', 0, 0 );
				$style = ( ( $styrtype >> ( $gstyle * 4 ) ) & 15 ) if ( $gstyle >= 0 && $gstyle <= 7 );
			};

			# adjust the segments if crossovers are set
			$segment = ($segment | (1 + 2) ) if ( $cellspc == 2 );
			$segment = ($segment | (4 + 8) ) if ( $cellspc == 3 );
			$segment = ($segment | 1 ) if ( $cellspc == 4 );
			$segment = ($segment | 2 ) if ( $cellspc == 5 );
			$segment = ($segment | 4 ) if ( $cellspc == 6 );
			$segment = ($segment | 8 ) if ( $cellspc == 7 );

			next if ! $valid;
			my ( $hall, $hclass ) = (0, 0);
			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $vheseg = ( $segment & 15 );
			my $umflag = getumflag( $xinc, $yinc, $zinc );

			print OUTPUT "# location $xinc $yinc $zinc vhe $vheflags segment $segment\n";

			# open up tops of non-vhe surface hallways
			my ( $otvalid, $opentop) = gethallflag( $xinc, $yinc, $zinc, 9 );
			$segment = ($segment & 0x2f ) if ( $opentop && ! $vheflags && ! $roomid );

			# fill unused hallway cells as empty if level class specifies it.
			if ( $segment == 0x3f && $emptyblocks && ! $roomid ) {
				print OUTPUT "fill 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
				next;
			};

			# get the dateset name from the room or hallway class data
			my ( $setname, $roomspc, $lookupsetname, $interior ) = ( $defaultset, 0, $defaultset, 0 );
			my ( $valid_b30, $roomspc_b30 ) = ( 0, 0 );
			if ( $roomid ) {
				# get the dataset name
				$roomspc = getroomspc( $roomid );
				$lookupsetname = $roomclass[$roomspc][16];
				my $roomsetvalid;
				($setname, $roomsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = '' if ( ! $setname || ! $roomsetvalid );
				( $valid_b30, $roomspc_b30) = getroomspcflag( $roomspc, 30 );
				$interior = $roominfo[$roomid][17];
			} else {
				$hall = gethallid( $xinc, $yinc, $zinc );
				$hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $hallsetvalid;
				$lookupsetname = gethallinfo( $xinc, $yinc, $zinc, 1, 18);
				($setname, $hallsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = '' if ( ! $setname || ! $hallsetvalid );
			};

			# override the room dataset name if room has an interior class specified
			if ( $interior ) {
				$lookupsetname = $interiorclass[$interior][1];
				my $intsetvalid;
				($setname, $intsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = '' if ( ! $setname || ! $intsetvalid );
			};

			# skip this cell if it does not have a valid dataset type
			next if ( ! $setname );

			# get elevation variance of cell
			my $fev = getfev( $xinc, $yinc, $zinc );

			# Limit action to clearing this cell if room special flag bit 30 is set for this cells room class
			if ( $roomspc_b30 ) {
				print OUTPUT "fill 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
				next;
			};

			# get dataset information
			my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
				$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( $lookupsetname );

			# render unmined cell if unmined flag set
			if ( $umflag ) {
				my ( $xum, $yum, $zum ) = ( $xinc % 20, $yinc % 10, $zinc % 20 );

				# render unmined block
				print OUTPUT "import $mc_schemroot/unmined/map0-$xum-$yum-$zum.schematic $xcoord $ycoord $zcoord\n";

				# prevent breaching of outer dungeon perimeter
				print OUTPUT "fill $cmt $xcoord $ycoord $zcoord 1 $yscale $mc_hscale\n" if ( $xinc == 0 );
				print OUTPUT "fill $cmt $xfcoord $ycoord $zcoord 1 $yscale $mc_hscale\n" if ( $xinc == ($xmazesize-1));
				print OUTPUT "fill $cmt $xcoord $ycoord $zcoord $mc_hscale $yscale 1\n" if ( $zinc == 0 );
				print OUTPUT "fill $cmt $xcoord $ycoord $zfcoord $mc_hscale $yscale 1\n" if ( $zinc == ($zmazesize-1));
				print OUTPUT "fill $cmt $xcoord $yfcoord $zcoord $mc_hscale 1 $mc_hscale\n" if ( $yinc == 0 );
				print OUTPUT "fill $cmt $xcoord $ycoord $zcoord $mc_hscale 1 $mc_hscale\n" if ( $yinc == ($ymazesize-1));

				next if ( $segment == 63 );

				# add mine entrance if the cell has a segment opening
				for my $dir ( 1 .. 6 ) {
				    if (! (( $segment >> ($dir - 1)) & 1)) {
					my ( $xi, $yi, $zi ) = getmazedirection( $dir );
					my $efev = getfev( $xinc+$xi, $yinc+$yi, $zinc+$zi );
					my $eumflag = getumflag( $xinc+$xi, $yinc+$yi, $zinc+$zi );
					next if $eumflag;
					my $header = "$mc_schemroot/$setname/mine-ent";
					$header = "$mc_schemroot/$setname/fev$efev/mine-ent" if ( $efev );

					print OUTPUT "import $header-$dir.schematic $xcoord $ycoord $zcoord noair\n";
				    };
				};

				# replace placeholder with air
				print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";

				next;
			};

			my ( $lssegid, $ussegid, $ssegid ) = getvhesseg( $xinc, $yinc, $zinc ) if $vheflags;

			my $fevpath = '';
			$fevpath = "/fev$fev" if ( $fev );

			my $stypath = '';
			$stypath = "/style$style" if ( $style );

			my $setpath = "$mc_schemroot/$setname";
			my $subset = "$stypath$fevpath";

			# determine if alternate VHE set needs to be used
			my $vhealt = '';
			my ( $hfound_b17, $hflag_b17 ) = gethallflag( $xinc, $yinc, $zinc, 17 );
			my ( $hfound_b18, $hflag_b18 ) = gethallflag( $xinc, $yinc, $zinc, 18 );
			my ( $hfound_b19, $hflag_b19 ) = gethallflag( $xinc, $yinc, $zinc, 19 );
			if ( $vheflags == 0b100 ) {
				$vhealt = '/alt' if ( $hflag_b17 && ($segment & 48 ) == 32 );
				$vhealt = '/alt' if ( $hflag_b18 && ($segment & 48 ) == 16 );
				$vhealt = '/alt' if ( $hflag_b19 && ($segment & 48 ) == 0 );
			};

			my ( $valid_b37, $roomspc_b37) = getroomspcflag( $roomspc, 37 );
			if ( $roomid ) {
				print OUTPUT "import $setpath$subset/r$segment.schematic $xcoord $ycoord $zcoord\n";
			} elsif ( $vheflags && ($segment & 48) == 16 ) {
				print OUTPUT "import $setpath$vhealt$subset/vu$vheseg.$ssegid.schematic $xcoord $ycoord $zcoord\n";
			} elsif ( $vheflags && ($segment & 48) == 0 ) {
				print OUTPUT "import $setpath$vhealt$subset/vi$vheseg.$ssegid.schematic $xcoord $ycoord $zcoord\n";
			} elsif ( $vheflags && ($segment & 48) == 32 ) {
				print OUTPUT "import $setpath$vhealt$subset/vd$vheseg.$ssegid.schematic $xcoord $ycoord $zcoord\n";
			} elsif ( $cellspc == 48 || $cellspc == 53 || $cellspc == 58 || $cellspc == 63 ) {
				print OUTPUT "# non-rendered half of dynamic stair pair\n";
			} elsif ( $cellspc >= 40 && $cellspc <= 47 ) {

				my ( $hfound_b41, $hflag_b41 ) = gethallflag( $xinc, $yinc, $zinc, 41 );

				my $dir = ( $cellspc & 0x03 ) + 1;
				my $sechar = 'd';
				$sechar = 'u' if ( $cellspc >= 44 );

				print OUTPUT "import $setpath$subset/h$vheseg.0.schematic $xcoord $ycoord $zcoord\n";

				if ( $hflag_b41 ) {
				    print OUTPUT "import $setpath$subset/dynstair-term-$sechar$dir.schematic $xcoord $ycoord $zcoord noair\n";
				    print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
				};

			} elsif ( $cellspc >= 48 && $cellspc <= 63 ) {
				my $udir = ( ( $cellspc & 0x03 ) ^ 1 ) + 1;
				my $ldir = ( ( $cellspc >> 2 ) & 0x03 ) + 1;
				my $ydspos = $ycoord;

				my $ucellspc = getcellspc( $xinc, $yinc-1, $zinc );
				my $lcellspc = getcellspc( $xinc, $yinc+1, $zinc );
				$ucellspc = 0 if ( ! $ucellspc );
				$lcellspc = 0 if ( ! $lcellspc );

				my $sdir='l';
				$sdir='d' if ( $lcellspc == 53 );
				$sdir='u' if ( $ucellspc == 58 );
				$sdir='d' if ( $lcellspc == 63 );
				$sdir='u' if ( $ucellspc == 48 );

				$ydspos = ( $yplushalf - $yscale ) if ( $sdir eq 'd' );

				if ( $sdir eq 'u' ) {
					# print "inv $xinc $yinc $zinc\n";
					# ($udir, $ldir ) = ( $ldir, $udir );
					$sdir = 'd';
				};

				print OUTPUT "import $setpath$subset/dynstair-$udir$sdir$ldir.schematic $xcoord $ydspos $zcoord\n";
			} else {
				print OUTPUT "import $setpath$subset/h$vheseg.0.schematic $xcoord $ycoord $zcoord\n";
			};

			# output any vhe upper/lower section modifications
			print OUTPUT "import $setpath$vhealt$subset/vi$vheseg.$ussegid.ut.schematic $xcoord $yplushalf $zcoord\n" if $ussegid;
			print OUTPUT "import $setpath$vhealt$subset/vi$vheseg.$lssegid.lt.schematic $xcoord $ycoord $zcoord\n" if $lssegid;

			my ( $ds3valid, $ds3flag) = getdatasetflag( $setname, 3 );

			# determine if the transitions need to be VHE transitions or left as regular hallway transitions
			my $vhetrans = '';
			my $transok = 1;
			$vhetrans = 'vd' if ( $vheflags && (( $segment & 48 ) == 32));
			$vhetrans = 'vu' if ( $vheflags && (( $segment & 48 ) == 16));
			$vhetrans = 'vi' if ( $vheflags && (( $segment & 48 ) == 0) && $vhealt );
			$transok = 0 if ( $vheflags && ! $vhetrans );
			# $vhetrans = '' if ( $vhetrans eq 'x' );
			my $maxadjfev = $fev;

			# add any floor elevation (FEV) transitions
			if ( $transok && $hall && ! ($segment & 1) ) {
				my $adjhall = gethallid( $xinc-1, $yinc, $zinc );
				my $adjhclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $adjfev = getfev( $xinc-1, $yinc, $zinc );
				$maxadjfev = $adjfev if ( $adjfev > $maxadjfev );
				if ( $hclass == $adjhclass && $fev < $adjfev ) {
				    if ( ($vhetrans eq 'vi') && ( $lssegid & 1 )) {
					print OUTPUT "# ls $lssegid\n";
					print OUTPUT "import $setpath$vhealt/vd-fev$fev-$adjfev.1.schematic $xcoord $ycoord $zcoord noair\n"
				    } elsif ( $vhetrans && ! ( $ssegid & 1 )) {
					print OUTPUT "import $setpath$vhealt/$vhetrans-fev$fev-$adjfev.1.schematic $xcoord $ycoord $zcoord noair\n"
				    } else {
					print OUTPUT "import $setpath/fev$fev-$adjfev.1.schematic $xcoord $ycoord $zcoord\n";
				    };
				};
			};
			if ( $transok && $hall && ! ($segment & 2) ) {
				my $adjhall = gethallid( $xinc+1, $yinc, $zinc );
				my $adjhclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $adjfev = getfev( $xinc+1, $yinc, $zinc );
				$maxadjfev = $adjfev if ( $adjfev > $maxadjfev );
				if ( $hclass == $adjhclass && $fev < $adjfev ) {
					my $adjxcoord = $xcoord + $mc_hscale - $evt;
					if ( $ds3flag ) {
						$adjxcoord = $xcoord + $mc_hscale - ( $evt * ( $adjfev - $fev ) );
					};
				    if ( ($vhetrans eq 'vi') && ( $lssegid & 2 )) {
					print OUTPUT "# ls $lssegid\n";
					print OUTPUT "import $setpath$vhealt/vd-fev$fev-$adjfev.2.schematic $adjxcoord $ycoord $zcoord noair\n"
				    } elsif ( $vhetrans && ! ( $ssegid & 2 )) {
					print OUTPUT "import $setpath$vhealt/$vhetrans-fev$fev-$adjfev.2.schematic $adjxcoord $ycoord $zcoord noair\n"
				    } else {
					print OUTPUT "import $setpath/fev$fev-$adjfev.2.schematic $adjxcoord $ycoord $zcoord\n";
				    };
				};
			};
			if ( $transok && $hall && ! ($segment & 4) ) {
				my $adjhall = gethallid( $xinc, $yinc, $zinc-1 );
				my $adjhclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $adjfev = getfev( $xinc, $yinc, $zinc-1 );
				$maxadjfev = $adjfev if ( $adjfev > $maxadjfev );
				if ( $hclass == $adjhclass && $fev < $adjfev ) {
				    if ( ($vhetrans eq 'vi') && ( $lssegid & 4 )) {
					print OUTPUT "# ls $lssegid\n";
					print OUTPUT "import $setpath$vhealt/vd-fev$fev-$adjfev.3.schematic $xcoord $ycoord $zcoord noair\n"
				    } elsif ( $vhetrans && ! ( $ssegid & 4 )) {
					print OUTPUT "import $setpath$vhealt/$vhetrans-fev$fev-$adjfev.3.schematic $xcoord $ycoord $zcoord noair\n"
				    } else {
					print OUTPUT "import $setpath/fev$fev-$adjfev.3.schematic $xcoord $ycoord $zcoord\n";
				    };
				};
			};
			if ( $transok && $hall && ! ($segment & 8) ) {
				my $adjhall = gethallid( $xinc, $yinc, $zinc+1 );
				my $adjhclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $adjfev = getfev( $xinc, $yinc, $zinc+1 );
				$maxadjfev = $adjfev if ( $adjfev > $maxadjfev );
				if ( $hclass == $adjhclass && $fev < $adjfev ) {
					my $adjzcoord = $zcoord + $mc_hscale - $evt;
					if ( $ds3flag ) {
						$adjzcoord = $zcoord + $mc_hscale - ( $evt * ( $adjfev - $fev ) );
					};
				    if ( ($vhetrans eq 'vi') && ( $lssegid & 8 )) {
					print OUTPUT "# ls $lssegid\n";
					print OUTPUT "import $setpath$vhealt/vd-fev$fev-$adjfev.4.schematic $xcoord $ycoord $adjzcoord noair\n"
				    } elsif ( $vhetrans && ! ( $ssegid & 8 )) {
					print OUTPUT "import $setpath$vhealt/$vhetrans-fev$fev-$adjfev.4.schematic $xcoord $ycoord $adjzcoord noair\n"
				    } else {
					print OUTPUT "import $setpath/fev$fev-$adjfev.4.schematic $xcoord $ycoord $adjzcoord\n";
				    };
				};
			};

			# fill downward-extending vhe sections with lava or water unless hall class prevents it
			my ( $hfound_b16, $hflag_b16 ) = gethallflag( $xinc, $yinc, $zinc, 16 );
			if ( ($vheflags >= 0b101) && (($segment & 32 ) == 32 ) && ! $swl && ! $hflag_b16 ) {
				my $floor = $ffs + $fss + $vco + $fev;
				my $stair = $ffs + $fss + $vco + $maxadjfev + 1;
				print OUTPUT "replace $fst with 11 $xcoord $ycoord $zcoord $mc_hscale $floor $mc_hscale\n";
				print OUTPUT "replace 67 with 10 $xcoord $ycoord $zcoord $mc_hscale $stair $mc_hscale\n";
			} elsif ( ($vheflags >= 0b101) && (($segment & 32 ) == 32 ) && $swl ) {
				my $xfcoord = ( $xcoord + $mc_hscale - 1 );
				my $zfcoord = ( $zcoord + $mc_hscale - 1 );

				print OUTPUT "replace 4 with 48 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
			};

			# add vhe edge enhancements if the hall class specifies it.
			my ( $hfound_b11, $hflag_b11 ) = gethallflag( $xinc, $yinc, $zinc, 11 );
			if ( $hflag_b11 && $lssegid ) {
				my $ylevel = $ycoord + $fev;
 				print OUTPUT "import $setpath/vhe-edge-f$lssegid.schematic $xcoord $ylevel $zcoord noair\n";
				print OUTPUT "replace 62 with 0 $xcoord $ylevel $zcoord $mc_hscale $yscale $mc_hscale\n";
			};
			my ( $hfound_b10, $hflag_b10 ) = gethallflag( $xinc, $yinc, $zinc, 10 );
			if ( $hflag_b10 && $ussegid ) {
				my $ylevel = $ycoord + $fev;
 				print OUTPUT "import $setpath/vhe-edge-c$lssegid.schematic $xcoord $ylevel $zcoord noair\n";
				print OUTPUT "replace 62 with 0 $xcoord $ylevel $zcoord $mc_hscale $yscale $mc_hscale\n";
			};

			# add vertical transitions for certain dead-ends if the hall class specifies it.
			my ( $hfound_b22, $hflag_b22 ) = gethallflag( $xinc, $yinc, $zinc, 22 );
			if ( $hflag_b22 && $vheflags == 0b011 ) {
			    my $segment2 = (( getsegment( $xinc, $yinc + 1, $zinc ) & 15 ) ^ 15);
			    my ( $topend, $botend ) = ( 0, 0 );
			    $topend = 1 if ( $lssegid == 1 || $lssegid == 2 || $lssegid == 4 || $lssegid == 8 );
			    $botend = 1 if ( $segment2 == 1 || $segment2 == 2 || $segment2 == 4 || $segment2 == 8 );
			    if ($topend || $botend ) {
				my ( $botdir, $topdir ) = ( 0, 0 );
				$botdir = 1 if $segment2 == 1;
				$botdir = 2 if $segment2 == 2;
				$botdir = 3 if $segment2 == 4;
				$botdir = 4 if $segment2 == 8;
				$topdir = 1 if $lssegid == 1;
				$topdir = 2 if $lssegid == 2;
				$topdir = 3 if $lssegid == 4;
				$topdir = 4 if $lssegid == 8;

				my $ylevel = $ycoord + $fev - $yscale;
				my $dyscale = ( $yscale * 2 );

 				print OUTPUT "import $setpath/verttrans-$botdir-$topdir.schematic $xcoord $ylevel $zcoord noair\n";
				print OUTPUT "replace 62 with 0 $xcoord $ylevel $zcoord $mc_hscale $dyscale $mc_hscale\n";
			    };
			};

			# add crossover tunnels
			my ( $coheight, $cowidth ) = ( 4, 4 );
			my $xstart = $xcoord + floor(( $mc_hscale - $cowidth ) / 2 );
			my $ystart = ( $ycoord + $yscale - $coheight );
			my $zstart = $zcoord + floor(( $mc_hscale - $cowidth ) / 2 );
			my $xccoord = ( $xcoord + $mc_hscale - $hco - $wfs - $wss );
			my $zccoord = ( $zcoord + $mc_hscale - $hco - $wfs - $wss );
			print OUTPUT "import $setpath$fevpath/crossover4.schematic $xcoord $ycoord $zstart\n" if ( $cellspc == 4 );
			print OUTPUT "import $setpath$fevpath/crossover5.schematic $xccoord $ycoord $zstart\n" if ( $cellspc == 5 );
			print OUTPUT "import $setpath$fevpath/crossover6.schematic $xstart $ycoord $zcoord\n" if ( $cellspc == 6 );
			print OUTPUT "import $setpath$fevpath/crossover7.schematic $xstart $ycoord $zccoord\n" if ( $cellspc == 7 );

			# add vhe stairs if enabled
			my ( $hfound_b44, $hflag_b44 ) = gethallflag( $xinc, $yinc, $zinc, 44 );
			if ( $hflag_b44 && (( $segment & 32 ) == 0 ) && $vheflags) {
				# use the x/y/z coordinates to pick the first direction to test
				my $stdir = ((( $xinc + $zinc ) ^ ( $yinc & 1 )) & 0x03 );

				# get information about lower cell
				my $segment2 = ( getsegment( $xinc, $yinc + 1, $zinc ) & 15 );
				my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $yinc + 1, $zinc );
				my ( $dfound2, $doorid2 ) = ( lookupdoor( $xinc, $yinc + 1, $zinc ));
				my $ycoord2 = ($ycoord - $yscale );

				# rules:
				# stair requires vhe segment with no floor
				# udir needs to be on solid or usseg-constricted wall, doorways/archways ignored
				# intermediate dirs cannot be fully open
				# ldir needs to be solid with no doorways/archways and no crossover starts

				my ( $ufound, $lfound ) = ( 0, 0 );
				foreach my $rcnt ( 0 .. 3 ) {
				    next if ( $dfound2 );
				    next if ( $ufound );
				    foreach my $rdir ( 0 .. 3 ) {
				        next if ( $ufound );
					my ( $udir, $ldir, $udmask, $ldmask ) = convstdir( $stdir, $rdir, $rcnt );
					next if (( $segment2 & $ldmask ) == 0 );

					next if (( ($segment2 | $ussegid2) & $udmask ) == 0 );

					$lfound = $ldir;
					$ufound = $udir;
				    };
				    next if ( $ufound == 0 );
				    last;
				};

				if ( $ufound ) {
					print OUTPUT "import $setpath/vhe-stair-u$ufound-l$lfound.schematic $xcoord $ycoord2 $zcoord noair\n";
					print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
				};
			};
			# add vhe ladders if enabled
			my ( $hfound_b45, $hflag_b45 ) = gethallflag( $xinc, $yinc, $zinc, 45 );
			if ( $hflag_b45 && (( $segment & 48 ) == 16 ) && $vheflags) {
				# steps:
				# 1. locate bottom
				# 2. init corner variables
				# 3. scan from top down, shortening corner paths for invalid exits
				# 4. scan from bottom up, shortening corner paths for invalid exits.
				# 5. render ladders for valid corners
				# 6. render openings for valid ladder exits

				# find bottom of current vhe column
				my $ybot = $yinc;
				foreach my $ychk ($yinc+1 .. $ymazesize ) {
					my $yvalid = checkbounds( $xinc, $ychk, $zinc );
					last if ( ! $yvalid );
				
					my $segment2 = getsegment( $xinc, $ychk, $zinc );
					if ( $segment2 & 32 ) {
						$ybot = $ychk;
						last;
					};
				};

				my ( $nwtop, $netop, $swtop, $setop ) = ( $yinc, $yinc, $yinc, $yinc );
				my ( $nwbot, $nebot, $swbot, $sebot ) = ( $ybot, $ybot, $ybot, $ybot );
				my ( $nwtok, $netok, $swtok, $setok ) = ( 0, 0, 0, 0 );
				my ( $nwbok, $nebok, $swbok, $sebok ) = ( 0, 0, 0, 0 );

				# check for topmost segment of valid ladder paths
				foreach my $ychk ($yinc .. $ybot) {
					my $segment2 = getsegment( $xinc, $ychk, $zinc );
					my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $ychk, $zinc );
					my $chkpaths = $lssegid2;
					$chkpaths = ( $segment2 ^ 63 ) if ( $ychk == $ybot );

					if (( $chkpaths & 5 ) && ( $nwtok == 0 )) {
						$nwtok = 1;
						$nwtop = $ychk;
					};
					if (( $chkpaths & 6 ) && ( $netok == 0 )) {
						$netok = 1;
						$netop = $ychk;
					};
					if (( $chkpaths & 9 ) && ( $swtok == 0 )) {
						$swtok = 1;
						$swtop = $ychk;
					};
					if (( $chkpaths & 10 ) && ( $setok == 0 )) {
						$setok = 1;
						$setop = $ychk;
					};
				};

				# ladder path is not valid if bottom was first valid segment
				$nwtok = 0 if ( $nwtop == $ybot );
				$netok = 0 if ( $netop == $ybot );
				$swtok = 0 if ( $swtop == $ybot );
				$setok = 0 if ( $setop == $ybot );

				# check for bottommost segment of valid ladder paths
				foreach my $ychkr ($yinc .. $ybot) {
					my $ychk = (( $yinc + $ybot ) - $ychkr );
					my $segment2 = getsegment( $xinc, $ychk, $zinc );
					my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $ychk, $zinc );
					my $chkpaths = $lssegid2;
					$chkpaths = ( $segment2 ^ 63 ) if ( $ychk == $ybot );

					if (( $chkpaths & 5 ) && ( $nwbok == 0 ) && $nwtok ) {
						$nwbok = 1;
						$nwbot = $ychk;
					};
					if (( $chkpaths & 6 ) && ( $nebok == 0 ) && $netok ) {
						$nebok = 1;
						$nebot = $ychk;
					};
					if (( $chkpaths & 9 ) && ( $swbok == 0 ) && $swtok ) {
						$swbok = 1;
						$swbot = $ychk;
					};
					if (( $chkpaths & 10 ) && ( $sebok == 0 ) && $setok ) {
						$sebok = 1;
						$sebot = $ychk;
					};
				};
				# ladder path is not valid if bottom and top segments match
				( $nwbok, $nwtok ) = ( 0, 0 ) if ( $nwtop == $nwbot );
				( $nebok, $netok ) = ( 0, 0 ) if ( $netop == $nebot );
				( $swbok, $swtok ) = ( 0, 0 ) if ( $swtop == $swbot );
				( $sebok, $setok ) = ( 0, 0 ) if ( $setop == $sebot );

				if ( $debug2 ) {
					print "$xinc $yinc $zinc vheladders range $yinc to $ybot, valid: ";
					print "nw: $nwtop to $nwbot " if ( $nwbok );
					print "ne: $netop to $nebot " if ( $nebok );
					print "sw: $swtop to $swbot " if ( $swbok );
					print "se: $setop to $sebot " if ( $sebok );
					print "\n";
				};

				# process northwest corner
				if ( $nwtok && $nwbok ) {
					# place ladder segments
					my $yctop = getycoord( $nwtop );
					my $ycbot = getycoord( $nwbot );
					print OUTPUT "import $setpath/vhe-ladder-nw-d.schematic $xcoord $ycbot $zcoord noair\n";
					print OUTPUT "import $setpath/vhe-ladder-nw-u.schematic $xcoord $yctop $zcoord noair\n";
					foreach my $yldr ( ( $nwtop + 1 ) .. ( $nwbot - 1 ) ) {
						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-nw-i.schematic $xcoord $ycint $zcoord noair\n";
					};
					# place openings
					foreach my $yldr ( $nwtop .. $nwbot ) {
						my $segment2 = getsegment( $xinc, $yldr, $zinc );
						my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $yldr, $zinc );
						my $chkpaths = $lssegid2;
						$chkpaths = ( $segment2 ^ 63 ) if ( $yldr == $nwbot );

						my $ycldr = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-nw-no.schematic $xcoord $ycldr $zcoord noair\n" if ( $chkpaths & 1 );
						print OUTPUT "import $setpath/vhe-ladder-nw-wo.schematic $xcoord $ycldr $zcoord noair\n" if ( $chkpaths & 4 );
						print OUTPUT "replace 62 with 0 $xcoord $ycldr $zcoord $mc_hscale $yscale $mc_hscale\n";
					};
				};
				# process northeast corner
				if ( $netok && $nebok ) {
					# place ladder segments
					my $yctop = getycoord( $netop );
					my $ycbot = getycoord( $nebot );
					print OUTPUT "import $setpath/vhe-ladder-ne-d.schematic $xcoord $ycbot $zcoord noair\n";
					print OUTPUT "import $setpath/vhe-ladder-ne-u.schematic $xcoord $yctop $zcoord noair\n";
					foreach my $yldr ( ( $netop + 1 ) .. ( $nebot - 1 ) ) {
						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-ne-i.schematic $xcoord $ycint $zcoord noair\n";
					};
					# place openings
					foreach my $yldr ( $netop .. $nebot ) {
						my $segment2 = getsegment( $xinc, $yldr, $zinc );
						my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $yldr, $zinc );
						my $chkpaths = $lssegid2;
						$chkpaths = ( $segment2 ^ 63 ) if ( $yldr == $nebot );

						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-ne-no.schematic $xcoord $ycint $zcoord noair\n" if ( $chkpaths & 2 );
						print OUTPUT "import $setpath/vhe-ladder-ne-eo.schematic $xcoord $ycint $zcoord noair\n" if ( $chkpaths & 4 );
						print OUTPUT "replace 62 with 0 $xcoord $ycint $zcoord $mc_hscale $yscale $mc_hscale\n";
					};
				};
				# process southwest corner
				if ( $swtok && $swbok ) {
					# place ladder segments
					my $yctop = getycoord( $swtop );
					my $ycbot = getycoord( $swbot );
					print OUTPUT "import $setpath/vhe-ladder-sw-d.schematic $xcoord $ycbot $zcoord noair\n";
					print OUTPUT "import $setpath/vhe-ladder-sw-u.schematic $xcoord $yctop $zcoord noair\n";
					foreach my $yldr ( ( $swtop + 1 ) .. ( $swbot - 1 ) ) {
						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-sw-i.schematic $xcoord $ycint $zcoord noair\n";
					};
					# place openings
					foreach my $yldr ( $swtop .. $swbot ) {
						my $segment2 = getsegment( $xinc, $yldr, $zinc );
						my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $yldr, $zinc );
						my $chkpaths = $lssegid2;
						$chkpaths = ( $segment2 ^ 63 ) if ( $yldr == $swbot );

						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-sw-so.schematic $xcoord $ycint $zcoord noair\n" if ( $chkpaths & 1 );
						print OUTPUT "import $setpath/vhe-ladder-sw-wo.schematic $xcoord $ycint $zcoord noair\n" if ( $chkpaths & 8 );
						print OUTPUT "replace 62 with 0 $xcoord $ycint $zcoord $mc_hscale $yscale $mc_hscale\n";
					};
				};
				# process southeast corner
				if ( $setok && $sebok ) {
					# place ladder segments
					my $yctop = getycoord( $setop );
					my $ycbot = getycoord( $sebot );
					print OUTPUT "import $setpath/vhe-ladder-se-d.schematic $xcoord $ycbot $zcoord noair\n";
					print OUTPUT "import $setpath/vhe-ladder-se-u.schematic $xcoord $yctop $zcoord noair\n";
					foreach my $yldr ( ( $setop + 1 ) .. ( $sebot - 1 ) ) {
						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-se-i.schematic $xcoord $ycint $zcoord noair\n";
					};
					# place openings
					foreach my $yldr ( $setop .. $sebot ) {
						my $segment2 = getsegment( $xinc, $yldr, $zinc );
						my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $yldr, $zinc );
						my $chkpaths = $lssegid2;
						$chkpaths = ( $segment2 ^ 63 ) if ( $yldr == $sebot );

						my $ycint = getycoord( $yldr );
						print OUTPUT "import $setpath/vhe-ladder-se-so.schematic $xcoord $ycint $zcoord noair\n" if ( $chkpaths & 2 );
						print OUTPUT "import $setpath/vhe-ladder-se-eo.schematic $xcoord $ycint $zcoord noair\n" if ( $chkpaths & 8 );
						print OUTPUT "replace 62 with 0 $xcoord $ycint $zcoord $mc_hscale $yscale $mc_hscale\n";
					};
				};
			};
			# add vhe central ladders if enabled
			my ( $hfound_b46, $hflag_b46 ) = gethallflag( $xinc, $yinc, $zinc, 46 );
			if ( $hflag_b46 && (( $segment & 48 ) == 16 ) && $vheflags) {
				# steps:
				# 1. init top level and bottom level variables
				# 1. scan from top down, moving top level down to first exit level.
				# 2. continue scanning for floor, record bottom level.
				# 3. abort placement if top and bottom levels are the same.
				# 5. render bottom segment.
				# 6. render top/intermediate segments and add any required exits.

				my ( $ytop, $ybot ) = ( $yinc, $yinc );
				my ( $ytok, $ybok ) = ( 0, 0 );

				# find bottom of current vhe column and first accessible top.
				foreach my $ychk ($yinc .. $ymazesize ) {
					my $yvalid = checkbounds( $xinc, $ychk, $zinc );
					last if ( ! $yvalid );
				
					my $segment2 = getsegment( $xinc, $ychk, $zinc );
					if ( $segment2 & 32 ) {
						$ybot = $ychk;
						last;
					};

					my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $ychk, $zinc );

					if (( $lssegid2 & 15 ) && ( $ytok == 0 )) {
						$ytok = 1;
						$ytop = $ychk;
					};
				};

				# ladder is not useable if first accessible top segment is the bottom segment.
				$ytok = 0 if ( $ytop == $ybot );

				if ( $ytok ) {
					# place ladder segments
					my $yctop = getycoord( $ytop );
					my $ycbot = getycoord( $ybot );

					# place bottom ladder segment
					print OUTPUT "import $setpath/vhe-ctrladder-d.schematic $xcoord $ycbot $zcoord noair\n";

					foreach my $yldr ( $ytop .. ( $ybot - 1 ) ) {
						my $ycint = getycoord( $yldr );


						my $segment2 = getsegment( $xinc, $yldr, $zinc );
						my ( $lssegid2, $ussegid2, $ssegid2 ) = getvhesseg( $xinc, $yldr, $zinc );

						my $segtype = 'in';
						$segtype = 'ie' if ( ( $yldr != $ytop ) && ( $lssegid2 & 15 ) );
						$segtype = 'u' if ( $yldr == $ytop );

						# place top/intermediate ladder segments
						print OUTPUT "import $setpath/vhe-ctrladder-$segtype.schematic $xcoord $ycint $zcoord noair\n";

						# place bridges
						print OUTPUT "import $setpath/vhe-ctrladder-w.schematic $xcoord $ycint $zcoord noair\n" if ( $lssegid2 & 1 );
						print OUTPUT "import $setpath/vhe-ctrladder-e.schematic $xcoord $ycint $zcoord noair\n" if ( $lssegid2 & 2 );
						print OUTPUT "import $setpath/vhe-ctrladder-n.schematic $xcoord $ycint $zcoord noair\n" if ( $lssegid2 & 4 );
						print OUTPUT "import $setpath/vhe-ctrladder-s.schematic $xcoord $ycint $zcoord noair\n" if ( $lssegid2 & 8 );
						print OUTPUT "replace 62 with 0 $xcoord $ycint $zcoord $mc_hscale $yscale $mc_hscale\n" if ( $lssegid2 );
					};
				};
			};
		}
	    }
	}

	# render any custom-schematic rooms
	if ( $totalrooms > 0 ) {
		foreach my $room ( 1 .. $totalrooms ) {
			# get basic room/door information
			my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $room );
			my ($doorfound, $locdoor ) = lookupdoor( $xe, $ye, $ze );
			my ($dx, $dy, $dz, $droom, $sdnum, $ddir, $from, $did, $valid, $doorclass ) = getdoorinfo( $locdoor ) if $doorfound;
			my $roomspc = getroomspc( $room );
			my $specialname = $roomclass[$roomspc][17];
			my $yscale = getroomyscale( $room );

			# far corner coordinates
			my $xfc=( $xc+$xs-1 );
			my $yfc=( $yc+$ys-1 );
			my $zfc=( $zc+$zs-1 );

			# determine room coordinates
			my $xcoord = (( $mc_hscale * $xc ) + $mc_xoffset );
			my $ycoord = getycoord( $yfc );
			my $zcoord = (( $mc_hscale * $zc ) + $mc_zoffset );

			my $xfcoord = (( $mc_hscale * ( $xfc + 1 )) + $mc_xoffset );
			my $yfcoord = getycoord( $yc );
			my $zfcoord = (( $mc_hscale * ( $zfc + 1 )) + $mc_zoffset );
			# my $yc1 = $ycoord + 1;
			# my $yc2 = $ycoord1 + 1;
			# my $yc3 = $ycoord2 + 1;
			# my $yc4 = $ycoord3 + 1;
			# my $yc5 = $ycoord4 + 1;
			# my $yc6 = $ycoord5 + 1;
			# my $ycc1 = getycoord( $yc - 1 ) - 2;
			# my $ycc2 = $yccoord1 - 1;
			# my $ycc3 = $yccoord2 - 1;

			# get room-specific characteristics
			my @roomchars = getroomchars( $room );

			# get additional interior class info, if required.
			my $interior = $roominfo[$room][17];
			my ( $intsub, $intrtype, $inthunits ) = ( '', 0, 0 );
			if ( $interior ) {
				$intsub = $interiorclass[$interior][2];
				$intrtype = $interiorclass[$interior][8];
				$inthunits = $interiorclass[$interior][10];
			};

			# add rough ceiling/floor if specified by room class
			my ( $valid_b40, $roomspc_b40) = getroomspcflag( $roomspc, 40 );
			if ( $roomspc_b40 ) {
			    print OUTPUT "# bit40 for room $room\n";
			    my $datasetname = $roomclass[$roomspc][16];
			    $datasetname = $interiorclass[$interior][1] if $interior;
			    my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
				$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) =
				getdatasetinfo( $datasetname );
			    for my $xinc ( $xc .. ($xc + $xs - 1 ) ) {
				my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );
				for my $zinc ( $zc .. ($zc + $zs - 1 ) ) {
				    my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );
				    for my $yinc ( $yc .. ( $yc + $ys - 1 ) ) {

					# skip this cell if it does not belong to the target room
					my $room2 = getroomid( $xinc, $yinc, $zinc );
					next if ( $room2 != $room );

					my ( $xstart, $zstart ) = ( $xcoord, $zcoord );
					my $segment = getsegment( $xinc, $yinc, $zinc );
				        $xstart += ( $hco + $wfs + $wss ) if ( $segment & 1 );
				    	$zstart += ( $hco + $wfs + $wss ) if ( $segment & 4 );
					my $ycoord = getycoord( $yinc );
					my $yscale = getyscale( $yinc );
					my $yc1 = $ycoord + 1;
					my $yc2 = $ycoord + 2;
					my $yc3 = $ycoord + 3;
					my $yc4 = $ycoord + 4;
					my $yc5 = $ycoord + 5;
					my $yc6 = $ycoord + 6;
					my $ycc1 = $ycoord + $yscale - 2;
					my $ycc2 = $ycoord + $yscale - 3;
					my $ycc3 = $ycoord + $yscale - 4;

					my $xp = $xinc % 4;
					my $zp = $zinc % 4;

					# add ceiling surface to cells with a ceiling segment
					if ( $segment & 16 ) {
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b4.$xp$zp.schematic $xcoord $ycc1 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b2.$xp$zp.schematic $xcoord $ycc1 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b1.$xp$zp.schematic $xcoord $ycc1 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b2.$xp$zp.schematic $xcoord $ycc2 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b1.$xp$zp.schematic $xcoord $ycc2 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b1.$xp$zp.schematic $xcoord $ycc3 $zcoord noair\n";
					};
					# add a rough floor surface to cells with a floor segment 
					if ( $segment & 32 ) {
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b1.$xp$zp.schematic $xcoord $yc1 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b2.$xp$zp.schematic $xcoord $yc1 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b4.$xp$zp.schematic $xcoord $yc1 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b1.$xp$zp.schematic $xcoord $yc2 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b2.$xp$zp.schematic $xcoord $yc2 $zcoord noair\n";
					    print OUTPUT "import $mc_schemroot/fceffect/erosion.b1.$xp$zp.schematic $xcoord $yc3 $zcoord noair\n";
					};
					# perform placeholder block replacement for any required cells
					if ( $segment & 48 ) {
				            print OUTPUT "replace 62 with 7 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
					};
				    };
				};
			    };
			};

			# Interior: H/V fixed/scaleable combinations
			if ( $interior && $intrtype >= 1 && $intrtype <= 7 ) {

			    # get interior flags for variation selection
			    my ( $intvalid_b0, $intspc_b0 ) = getintspcflag( $interior, 0 );
			    my ( $intvalid_b1, $intspc_b1 ) = getintspcflag( $interior, 1 );
			    my ( $intvalid_b2, $intspc_b2 ) = getintspcflag( $interior, 2 );
			    my ( $intvalid_b3, $intspc_b3 ) = getintspcflag( $interior, 3 );
			    my ( $intvalid_b4, $intspc_b4 ) = getintspcflag( $interior, 4 );
			    my ( $intvalid_b5, $intspc_b5 ) = getintspcflag( $interior, 5 );
			    my ( $intvalid_b8, $intspc_b8 ) = getintspcflag( $interior, 8 );
			    my ( $intvalid_b9, $intspc_b9 ) = getintspcflag( $interior, 9 );
			    my ( $intvalid_b10, $intspc_b10 ) = getintspcflag( $interior, 10 );
			    my ( $intvalid_b11, $intspc_b11 ) = getintspcflag( $interior, 11 );

			    # determine "direction" for non-square rooms
			    my $rpldir = (( $xc+$yc+$zc ) & 1 );
			    $rpldir = 1 if ( $xs > $zs );
			    $rpldir = 0 if ( $zs > $xs );
			    $rpldir = 0 if ( $intspc_b4 );

			    print OUTPUT "# room $room interior type $intrtype\n";

			    # process room cell grid
			    my $schdir = "$mc_schemroot/rooms";
			    foreach my $xinc ( 0 .. ( $xs - 1 )) {
				# skip additional X dimension passes if a fixed-horiz is specified.
				# last if ( $xinc && ( $intrtype == 2 || $intrtype == 4 || $intrtype == 5 || $intrtype == 6 ));

				my $X = $xinc + $xc;
				my $xcoord = (( $mc_hscale * $X ) + $mc_xoffset );

				# adjust the xcoord if we are centering a schematic
				if ( $intrtype == 5 || $intrtype == 6 ) {
					my $xocoord = int((( $xs * $mc_hscale ) - ( $inthunits * $mc_hscale ))/2);

					# check if the schematic size exceeds the room dimensions
					last if ( $xocoord < 0 );

					$xcoord += $xocoord;
				};
				foreach my $zinc ( 0 .. ( $zs - 1 )) {
				    # skip additional Z dimension passes if a fixed-horiz is specified.
				    # last if ( $zinc && ( $intrtype == 2 || $intrtype == 4 || $intrtype == 5 || $intrtype == 6 ));

				    my $Z = $zinc + $zc;
				    my $zcoord = (( $mc_hscale * $Z ) + $mc_zoffset );
				    my $rel = 0;

				    # adjust the zcoord if we are centering a schematic
				    if ( $intrtype == 5 || $intrtype == 6 ) {
					my $zocoord = int((( $zs * $mc_hscale ) - ( $inthunits * $mc_hscale ))/2);

					# check if the schematic size exceeds the room dimensions
					last if ( $zocoord < 0 );

					$zcoord += $zocoord;
				    };

				    my $passthruflag = 0;

				    foreach my $yinc ( 0 .. ( $ys - 1 )) {
					# skip additional Y dimension passes if a fixed-vert or single-height is specified.
					# last if ( $yinc && ( $intrtype == 3 || $intrtype == 4 || $intrtype == 6 || $intspc_b5 ));

					# invert Y - we start at the room bottom
					my $Y = ( $yc + $ys - $yinc - 1 );

					my $ycoord = getycoord( $Y );
					my $ylcoord = getycoord( $Y + 1 );

					# make sure we are working with a cell belonging to current room
					my $cc_roomid = getroomid( $X, $Y, $Z );
					next if ( $cc_roomid != $room );

					my $cc_cellspc = getcellspc( $X, $Y, $Z );

					# stop processing this column if cell contains a passthru segment
					last if ( $cc_cellspc >= 34 && $cc_cellspc <= 39 && $intspc_b11 == 0 );

					# skip processing this cell if cell contains any other cellspc value
					# next if ( $cc_cellspc );

					my $vari = 0;

					my $segment = getsegment( $X, $Y, $Z );
					my $hseg = $segment & 0xf;

					# reset the Y base when we have a floor segment
					$rel = 0 if ( $segment & 32 );

					# lookup the variation
					my $intvarcnt = 0;
					if ( $intrtype == 7 ) {
						if ( $intspc_b8 ) {
							$intvarcnt = getncintvari( $interior, 0, $segment, $ys );
						} else {
							$intvarcnt = getintvari( $interior, 0, $segment );
						};
					} else {
						if ( $intspc_b8 ) {
							$intvarcnt = getncintvari( $interior, $rel, $hseg, $ys );
						} else {
							$intvarcnt = getintvari( $interior, $rel, $hseg );
						};
					};

					# determine if variation 0 should be excluded from random selection
					my $excludevari0 = 0;
					if ( $intspc_b11 && $intvarcnt > 1 ) {
						$intvarcnt -= 1;
						$excludevari0 = 1;
					};

					# skip this location if no variations exist
					next if ( ! $intvarcnt );

					# determine the variation to use
					if ( $intspc_b2 ) {
						$vari = ( $xinc + $yinc + $zinc ) if ( ! $intspc_b0 && ! $intspc_b1 );
						$vari = ( $yinc ) if ( $intspc_b0 && ( ! $intspc_b1 ));
						$vari = ( $xinc + $zinc ) if ( $intspc_b1 && ( ! $intspc_b0 ));
						$vari = ( $room ) if ( $intspc_b1 && $intspc_b0 );
						if ( $intspc_b3 ) {
							$vari = ( $intvarcnt - 1 ) if ( $vari >= $intvarcnt );
						} else {
							$vari = $vari % $intvarcnt;
						};
					} elsif ( $intspc_b9 ) {
						# we are requesting a room-wide constant variation with random +/- adjustments.
						my $varinc;
						$vari = 1 + ( $randgrid[$xc][$yc][$zc] % ( $intvarcnt - 2 ));

						$varinc = (($randgrid[$X][$Y][$Z] >> 4 ) & 3 ) if ( ! $intspc_b0 && ! $intspc_b1 );
						$varinc = (($randgrid[$xc][$Y][$zc] >> 4 ) & 3 ) if ( $intspc_b0 && ( ! $intspc_b1 ));
						$varinc = (($randgrid[$X][$yc][$Z] >> 4 ) & 3 ) if ( $intspc_b1 && ( ! $intspc_b0 ));
						$varinc = (($randgrid[$xc][$yc][$zc] >> 4 ) & 3 ) if ( $intspc_b1 && $intspc_b0 );

						if ( $intspc_b10 ) {
							my ( $varsel, $locsum );
							$varsel = (($randgrid[$X][$Y][$Z] >> 5 ) & 1 ) if ( ! $intspc_b0 && ! $intspc_b1 );
							$varsel = (($randgrid[$xc][$Y][$zc] >> 5 ) & 1 ) if ( $intspc_b0 && ( ! $intspc_b1 ));
							$varsel = (($randgrid[$X][$yc][$Z] >> 5 ) & 1 ) if ( $intspc_b1 && ( ! $intspc_b0 ));
							$varsel = (($randgrid[$xc][$yc][$zc] >> 5 ) & 1 ) if ( $intspc_b1 && $intspc_b0 );
							$locsum = ( $xinc + $yinc + $zinc ) if ( ! $intspc_b0 && ! $intspc_b1 );
							$locsum = ( $yinc ) if ( $intspc_b0 && ( ! $intspc_b1 ));
							$locsum = ( $xinc + $zinc ) if ( $intspc_b1 && ( ! $intspc_b0 ));
							$locsum = ( $room ) if ( $intspc_b1 && $intspc_b0 );
							
							$varinc = 0 if ( $varsel == ( $locsum & 1 ));
						};

						# odds: 25% for a +1 adjustment, 25% for a -1 adjustment, 50% for no adjustment.
						$vari += 1 if ( $varinc == 1 );
						$vari -= 1 if ( $varinc == 2 );
					} else {
						$vari = ( $randgrid[$X][$Y][$Z] % ($intvarcnt )) if ( ! $intspc_b0 && ! $intspc_b1 );
						$vari = ( $randgrid[$xc][$Y][$zc] % ( $intvarcnt )) if ( $intspc_b0 && ( ! $intspc_b1 ));
						$vari = ( $randgrid[$X][$yc][$Z] % ( $intvarcnt )) if ( $intspc_b1 && ( ! $intspc_b0 ));
						$vari = ( $randgrid[$xc][$yc][$zc] % ( $intvarcnt )) if ( $intspc_b1 && $intspc_b0 );
					};

					# adjust variation if we have excluded vari 0, or select vari 0 if we have a passthru segment.
					$vari += 1 if ( $excludevari0 );
			
					if (( $cc_cellspc >= 34 && $cc_cellspc <= 39 && $intspc_b11 ) || $passthruflag ) {
						$vari = 0;
						$passthruflag = 1;
					};

					# set the variation in the local style cell field
					print OUTPUT "# vari at $X $Y $Z = $vari\n";
					sethalllstyle( $X, $Y, $Z, $vari );

					# skip remaining processing on cells depending on interior types
					next if ( ( $xinc || $zinc ) && ( $intrtype == 2 || $intrtype == 4 || $intrtype == 5 || $intrtype == 6 ));
					next if ( $yinc && ( $intrtype == 3 || $intrtype == 4 || $intrtype == 6 || $intspc_b5 ));

					my $cellspc = getcellspc( $X, $Y, $Z );

					# adjust Y coordinate and height for non-zero layers
					my ( $yreladj, $yusize ) = ( $ycoord, $yscale );
					( $yreladj, $yusize ) = ( $ylcoord, $yscale * 2 ) if ( $rel && ( $intrtype != 7 ));

					# adjust reported Y room height if single-height flag is enabled.
					my $yh = $ys;
					$yh = 1 if ( $intspc_b5 );

					# type-specific information string to append
					my $addstr = '';
					$addstr = "-l$rel-s$hseg" if ( $intrtype == 1 );
					$addstr = "-l$rel-x$xs-z$zs" if ( $intrtype == 2 );
					$addstr = "-s$hseg-y$yh" if ( $intrtype == 3 );
					$addstr = "-x$xs-y$yh-z$zs" if ( $intrtype == 4 );
					$addstr = "-l$rel" if ( $intrtype == 5 );
					$addstr = "-y$yh" if ( $intrtype == 6 );
					$addstr = "-s$segment" if ( $intrtype == 7 );

					print OUTPUT "import $schdir/$intsub-v$vari-p$rpldir$addstr.schematic $xcoord $yreladj $zcoord noair\n";
					print OUTPUT "replace 62 with 0 $xcoord $yreladj $zcoord $mc_hscale $yusize $mc_hscale\n";

					# relative Y repeats at 2
					$rel += 1;
					$rel = 2 if ( $rel > 2 );
				    };
				};
			    };
			};

			if ( $specialname eq "gorge" ) {
				my $xfarside = ( $xfcoord - ( 2 * $mc_hscale ));
				# my $ylevel = ( $ycoord + ( ($ys - 1) * $yscale ));
				my $ylevel = getycoord( $yc );
				my $zfarside = ( $zfcoord - ( 2 * $mc_hscale ));
				print OUTPUT "import $mc_schemroot/rooms/bridge-w.schematic $xcoord $ylevel $zcoord noair\n"if ( $zs == 1 );
				print OUTPUT "import $mc_schemroot/rooms/bridge-e.schematic $xfarside $ylevel $zcoord noair\n"if ( $zs == 1 );
				print OUTPUT "import $mc_schemroot/rooms/bridge-n.schematic $xcoord $ylevel $zcoord noair\n"if ( $xs == 1 );
				print OUTPUT "import $mc_schemroot/rooms/bridge-s.schematic $xcoord $ylevel $zfarside noair\n"if ( $xs == 1 );
			};

			if ( $specialname eq "levelgate" ) {
				print OUTPUT "# level gateway #$room at $xcoord $ycoord $zcoord\n";
				my $doorflag = getdoorflag( $xc, $yc, $zc );
				print OUTPUT "import $mc_schemroot/rooms/dungeon-gate.schematic $xcoord $ycoord $zcoord\n";
			};

			if ( $specialname eq "stairwell" ) {
				print OUTPUT "# stairwell #$room at $xcoord $ycoord $zcoord\n";
				my $type = $roomchars[0];
				$type = 0 if ! $type;
				my $doorflag = getdoorflag( $xc, $yc, $zc );
				print OUTPUT "import $mc_schemroot/rooms/stair-w-$type.schematic $xcoord $ycoord $zcoord\n" if ( $zs == 1 && (! $doorflag ));
				print OUTPUT "import $mc_schemroot/rooms/stair-n-$type.schematic $xcoord $ycoord $zcoord\n" if ( $xs == 1 && (! $doorflag ));
				print OUTPUT "import $mc_schemroot/rooms/stair-e-$type.schematic $xcoord $ycoord $zcoord\n" if ( $zs == 1 && $doorflag );
				print OUTPUT "import $mc_schemroot/rooms/stair-s-$type.schematic $xcoord $ycoord $zcoord\n" if ( $xs == 1 && $doorflag );
			};
			if ( $specialname eq "tower" ) {

				my $towertype = $roomchars[0];

				my (  $towerid, $topvars, $midvars, $botvars, $xsize, $zsize, $yminsize, $ymaxsize ) = gettowerinfo( $towertype );

				for my $inc ( 1 .. $ys ) {
					my $style = $roomchars[$inc];
					if ( $inc == 1 ) {
						print OUTPUT "import $mc_schemroot/rooms/tower-$towerid-base-$style.schematic $xcoord $ycoord $zcoord\n";
					} elsif ( $inc == $ys ) {
						print OUTPUT "import $mc_schemroot/rooms/tower-$towerid-top-$style.schematic $xcoord $yfcoord $zcoord\n";
					} else {
						my $ymcoord = getycoord( $yfc - $inc + 1 );
						print OUTPUT "import $mc_schemroot/rooms/tower-$towerid-mid-$style.schematic $xcoord $ymcoord $zcoord\n";
					};
				};
			};
			if ( $specialname eq "staircase" ) {
				my $type = $roomchars[0];
				$type = 0 if ! $type;

				my $udoorflag = getdoorflag( $xc, $yfc, $zc );
				$udoorflag = lookupadjdoor( $xc, $yfc, $zc ) if ( ! $udoorflag );

				my $ddoorflag = getdoorflag( $xc, $yc, $zc );
				$ddoorflag = lookupadjdoor( $xc, $yc, $zc ) if ( ! $ddoorflag );

				print OUTPUT "import $mc_schemroot/rooms/stair-dd-$type.schematic $xcoord $yfcoord $zcoord\n" if ( $ddoorflag );
				print OUTPUT "import $mc_schemroot/rooms/stair-d-$type.schematic $xcoord $yfcoord $zcoord\n" if ( ! $ddoorflag );
				print OUTPUT "import $mc_schemroot/rooms/stair-ud-$type.schematic $xcoord $ycoord $zcoord\n" if ( $udoorflag );
				print OUTPUT "import $mc_schemroot/rooms/stair-u-$type.schematic $xcoord $ycoord $zcoord\n" if ( ! $udoorflag );
				if ( $ys > 2 ) {
					foreach my $ymc ( $yc + 1 .. $yfc - 1 ) {
						my $doorflag = getdoorflag( $xc, $ymc, $zc );
						$doorflag = lookupadjdoor( $xc, $ymc, $zc ) if ( ! $doorflag );

						# my $ymcoord = ( $mc_yoffset - ( $yscale * ( $ymc + 1 )) + 1 );
						my $ymcoord = getycoord( $ymc );
						print OUTPUT "import $mc_schemroot/rooms/stair-id-$type.schematic $xcoord $ymcoord $zcoord\n" if ( $doorflag );
						print OUTPUT "import $mc_schemroot/rooms/stair-i-$type.schematic $xcoord $ymcoord $zcoord\n" if ( ! $doorflag );
					};
					
				}
			};
			if ( $specialname eq "large-staircase" ) {
				my $type = $roomchars[0];
				$type = 0 if ! $type;
				
				print OUTPUT "import $mc_schemroot/rooms/stair2x2-d-$type.schematic $xcoord $yfcoord $zcoord\n";
				print OUTPUT "import $mc_schemroot/rooms/stair2x2-u-$type.schematic $xcoord $ycoord $zcoord\n";
				if ( $ys > 2 ) {
					foreach my $ymc ( $yc + 1 .. $yfc - 1 ) {
						my $ymcoord = getycoord( $ymc );
						print OUTPUT "import $mc_schemroot/rooms/stair2x2-i-$type.schematic $xcoord $ymcoord $zcoord\n";
					};
					
				}
			};
			if ( $specialname eq "arena" ) {
				print OUTPUT "import $mc_schemroot/rooms/arena.schematic $xcoord $ycoord $zcoord noair\n";
			};
			if ( $specialname eq "closet" ) {
				my $rand = int(rand(5));
				print OUTPUT "import $mc_schemroot/rooms/closet$rand.schematic $xcoord $ycoord $zcoord\n";
			};
			if ( $specialname eq "village-level" ) {
				my $xalt = $xfcoord - 12;
				my $yalt = $ycoord + 12;
				my $zalt = $zfcoord - 12;
				print OUTPUT "import $mc_schemroot/rooms/village-access-nw.schematic $xcoord $ycoord $zcoord\n";
				print OUTPUT "import $mc_schemroot/rooms/village-access-ne.schematic $xalt $yalt $zcoord\n";
				print OUTPUT "import $mc_schemroot/rooms/village-access-sw.schematic $xcoord $yalt $zalt\n";
				print OUTPUT "import $mc_schemroot/rooms/village-access-se.schematic $xalt $ycoord $zalt\n";
			};
			if ( $specialname eq "hut" ) {
			    my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
					$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( "hut" );

				my $xname = ($xs - 1);
				my $zname = ($zs - 1);
				my ( $cdir, $dloc ) = ( 'X', 0 );
				if ( $ddir == 1 ) {
					$dloc = ( $xe - $xc );
					$cdir = 'w';
				} elsif ( $ddir == 2 ) {
					$dloc = ( $xe - $xc );
					$cdir = 'e';
				} elsif ( $ddir == 3 ) {
					$dloc = ( $ze - $zc );
					$cdir = 'n';
				} elsif ( $ddir == 4 ) {
					$dloc = ( $ze - $zc );
					$cdir = 's';
				} else {
					print "hut w/no door dir $ddir at $xc $yc $zc\n";
				};
				my ( $xoff, $yoff, $zoff, $xover, $yover, $zover ) = getdsoffset( "hut" );
				my $xstart = $xcoord + $xoff;
				my $ystart = $ycoord + $vco + $yoff;
				my $zstart = $zcoord + $zoff;

				# temporary placeholder until random schematic selection can be implemented
				my $randsel = 0;

				print OUTPUT "import $mc_schemroot/rooms/hut-$xname$zname$cdir$dloc-$randsel.schematic $xstart $ystart $zstart\n";
			};
			if ( $specialname eq "dynriver" ) {
				# determine whether the river should be dry or active
				my $rrand = int(rand(100));
				my $suffix = '';
				$suffix = "-dry" if ( $rrand > 80 );
				$suffix = "-lava" if ( $rrand < 10 );

				# look for cells specifying the custom room segment starts
				foreach my $yinc ( $yc .. $yfc ) {
	    			    # my $ycoord = ( $mc_yoffset - ( $yscale * ( $yinc + 1 )) + 1 );
				    my $ycoord = getycoord( $yinc );
				    foreach my $xinc ( $xc .. $xfc ) {
					my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );
					foreach my $zinc ( $zc .. $zfc ) {
						my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );
						# skip cells not belonging to this room
						my $ch_roomid = getroomid( $xinc, $yinc, $zinc );
						next if $room != $ch_roomid;

						# only process cells with a custom-room cell special field
						my $ch_cellspc = getcellspc( $xinc, $yinc, $zinc );
						next if ( $ch_cellspc < 16 || $ch_cellspc > 31 );

						# determine the type and direction from the cell special bits
						my $dir = ( $ch_cellspc & 3 ) + 1;
						my $type = (( $ch_cellspc >> 2 ) & 3 ) + 1;

						my ( $typename, $dirname, $typelen, $typehgt) = ( "", "", 1, 0 );

						# process the segment type
						if ( $type == 1 ) {
							$typename = "start";
							$typelen = 2;
						} elsif ( $type == 2 ) {
							$typename = "drop";
						} elsif ( $type == 3 ) {
							$typename = "ddrop";
							$typehgt = 1;
						} elsif ( $type == 4 ) {
							$typename = "end";
							$typelen = 2;
						};

						# adjust the Y coordinate if required
						my $oycoord = $ycoord;
						$ycoord = getycoord( $yinc + $typehgt );

						# process the direction type
						if ( $dir == 1 ) {
							$dirname = "w";
							$xcoord -= ( $mc_hscale * $typelen );
						} elsif ( $dir == 2 ) {
							$dirname = "e";
						} elsif ( $dir == 3 ) {
							$dirname = "n";
							$zcoord -= ( $mc_hscale * $typelen );
						} elsif ( $dir == 4 ) {
							$dirname = "s";
						};

						print OUTPUT "import $mc_schemroot/rooms/$specialname-$dirname$typename$suffix.schematic";
						print OUTPUT " $xcoord $ycoord $zcoord noair\n";
					}
				    }
				};
			};
		};
	};

	# render vertical hallway access
	foreach my $yinc (0 .. $ymazesize-1) {
	    my $yscale = getyscale( $yinc );
	    # my $ycoord = ( $mc_yoffset - ( $yscale * ( $yinc + 1 )) + 1 );
	    my $ycoord = getycoord( $yinc );
            foreach my $zinc (0 .. $zmazesize-1) {
		my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );
        	foreach my $xinc (0 .. $xmazesize-1) {
			my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );

			# get cell information
			my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
				getcellinfo( $xinc, $yinc, $zinc );

			next if ! $valid;

			# determine vertical wall segment info
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $dir5wall = (($paths & 16 )>> 4);
			my $dir6wall = (($paths & 32 )>> 5);
			my $dir5seg = (( $segment & 16 ) >> 4);
			my $dir6seg = (( $segment & 32 ) >> 5);
			my $uddir = 0;

			# ladders in rooms will be placed by door-adding routines
			next if $roomid;

			# dynamic stair paths will be added via schematics
			next if ( $cellspc >= 40 && $cellspc <= 63 );

			my $octr = int( ($mc_hscale - 1)/ 2 );
			my $osize = ($mc_hscale - ( $octr * 2 ));
			my $xcenter = ( $xcoord + $octr );
			my $zcenter = ( $zcoord + $octr );
			my ( $xfillstart, $zfillstart ) = ( $xcenter - 1, $zcenter - 1 );
			my $fillsize = $osize + 2;
			my $fillreq = 0;
			my $fillthick = 0;

			# check for an allowable vertical path
			if ( $vheflags == 0b000 && ( ( $cellspc < 8 ) || ( $cellspc > 11 ) )) {
				if ( $dir5wall == 0 && $dir6wall == 1 ) {
					$uddir = 1;
				} elsif ( $dir5wall == 1 && $dir6wall == 0 ) {
					$uddir = 2;
				} elsif ( $dir5wall == 0 && $dir6wall == 0 ) {
					$uddir = 3;
				};
			};

			print "uddir is set to $uddir for $xinc $yinc $zinc vhe $vheflags cellspc $cellspc\n" if ( $uddir && $debug3 );

			# get the dateset name from the room or hallway class data
			my ( $setname, $roomspc, $lookupsetname ) = ( $defaultset, 0, $defaultset );

			if ( $roomid ) {
				# get the dataset name
				$roomspc = getroomspc( $roomid );
				$lookupsetname = $roomclass[$roomspc][16];
				my $roomsetvalid;
				($setname, $roomsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = $defaultset if ( ! $setname || ! $roomsetvalid );
			} else {
				my $hall = gethallid( $xinc, $yinc, $zinc );
				my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $hallsetvalid;
				$lookupsetname = gethallinfo( $xinc, $yinc, $zinc, 1, 18);
				($setname, $hallsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = $defaultset if ( ! $setname || ! $hallsetvalid );
			};

			my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
				$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( $lookupsetname );

			if ( $uddir == 1 ) {
				# lower ladder segment

				my $height = ( $yscale - $ffs - $fss - $vco - $ulo );
				my $start = ( $ycoord + $ffs + $fss + $vco + $ulo);

				my $fstart = ( $ycoord + $yscale - $cfs - $css - $vco );
				my $fheight = ( $cfs + $css + $vco );

				print OUTPUT "fill $fst $xfillstart $fstart $zfillstart $fillsize $fheight $fillsize\n" if $fillreq;
				print OUTPUT "import $mc_schemroot/misc/ladder$height.schematic $xcenter $start $zcenter\n";

				my ( $up_v, $up_cu, $up_paths, $up_bdir, $up_seg, $up_rid ) = getcellinfo( $xinc, $yinc-1, $zinc );
				if ( $up_v ) {
					print "warning: up path mismatch at $xinc $yinc $zinc\n" if ( $up_paths & 32);
				};
			};
			if ( $uddir == 2 ) {
				# upper ladder segment

				my $height = ( $ffs + $fss + $vco );
				my $start = $ycoord;

				my $fstart = $start;
				my $fheight = $height;

				print OUTPUT "fill $fst $xfillstart $fstart $zfillstart $fillsize $fheight $fillsize\n" if $fillreq;
				print OUTPUT "import $mc_schemroot/misc/ladder$height.schematic $xcenter $start $zcenter\n";

				my ( $dn_v, $dn_cu, $dn_paths, $dn_bdir, $dn_seg, $dn_rid ) = getcellinfo( $xinc, $yinc+1, $zinc );
				if ( $dn_v ) {
					print "warning: down path mismatch at $xinc $yinc $zinc\n" if ( $dn_paths & 16 );
				}
			};
			if ( $uddir == 3 ) {
				# intermediate ladder segment

				my $height = $yscale;
				my $start = $ycoord;

				my $fstart = ( $ycoord + $yscale - $cfs - $css - $vco );
				my $fheight1 = ( $cfs + $css + $vco );
				my $fheight2 = ( $ffs + $fss + $vco );

				print OUTPUT "fill $fst $xfillstart $fstart $zfillstart $fillsize $fheight1 $fillsize\n" if $fillreq;
				print OUTPUT "fill $fst $xfillstart $start $zfillstart $fillsize $fheight2 $fillsize\n" if $fillreq;
				print OUTPUT "import $mc_schemroot/misc/ladder$height.schematic $xcenter $start $zcenter\n";

				my ( $up_v, $up_cu, $up_paths, $up_bdir, $up_seg, $up_rid ) = getcellinfo( $xinc, $yinc-1, $zinc );
				if ( $up_v ) {
					print "warning: up path mismatch at $xinc $yinc $zinc" if ( $up_paths & 32);
				};
				my ( $dn_v, $dn_cu, $dn_paths, $dn_bdir, $dn_seg, $dn_rid ) = getcellinfo( $xinc, $yinc+1, $zinc );
				if ( $dn_v ) {
					print "warning: down path mismatch at $xinc $yinc $zinc" if ( $dn_paths & 16 );
				}
			};
		}
	    }
	}

	# render the doors in the dungeon
	if ( $totaldoors > 0 ) {
		foreach my $door ( 1 .. $totaldoors ) {
			# get the door information
			my ($x, $y, $z, $roomnum, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );

			# skip this if it is marked as invalid
			next if ! $valid;

			print OUTPUT "# door $door\n";

			my ( $iroomclass, $ihallclass, $oroomclass, $ohallclass ) = ( 0,0,0,0 );
			my ( @iroomchars, @oroomchars );
			my ( $isetname, $osetname ) = ( $defaultset, $defaultset );
			my ( $ifev, $ofev ) = ( 0, 0 );
			my ( $ivalid_b27, $ovalid_b27, $ihallspc_b27, $ohallspc_b27 ) = ( 0, 0, 0, 0 );
			my ( $ivalid_b29, $ovalid_b29, $ihallspc_b29, $ohallspc_b29 ) = ( 0, 0, 0, 0 );
			my ( $iroomint, $oroomint, $irintspc_b6, $orintspc_b6 ) = ( 0, 0, 0, 0);
			my ( $irinterior, $orinterior ) = ( 0, 0 );
			my ( $irintname, $orintname, $irintvari, $orintvari ) = ( '', '', 0, 0 );

			# get the inside-door room/hall class and dataset name
			if ( $roomnum ) {
				$iroomclass = getroomspc( $roomnum );
				$isetname = $roomclass[$iroomclass][16];
				@iroomchars = getroomchars( $roomnum );
				my $intvalid_b6 = 0;
				$irinterior = $roominfo[$roomnum][17];
				$irintname = $interiorclass[$irinterior][2];
				my $gstyle = 0;
				( $gstyle, $irintvari ) = gethallstyle( $x, $y, $z );
				print OUTPUT "# irintvari for door $door at $x $y $z is $irintvari\n";
				( $intvalid_b6, $irintspc_b6 ) = getintspcflag( $irinterior, 6 );
			} else {
				my $hall = gethallid( $x, $y, $z );
				$ihallclass = gethallinfo( $x, $y, $z, 0, 0);
				$isetname = gethallinfo( $x, $y, $z, 1, 18);
	    			( $ivalid_b27, $ihallspc_b27 ) = gethallflag( $x, $y, $z, 27 );
	    			( $ivalid_b29, $ihallspc_b29 ) = gethallflag( $x, $y, $z, 29 );
			}

			# get the outside-door room/hall class and dataset name
			my ( $XI, $YI, $ZI ) = getmazedirection( $dir );

			# neutralize strange diagonal lookups for the outside of doors
			$YI = 0 if $dir >= 8;

			my $oroomnum = getroomid( $x + $XI, $y + $YI, $z + $ZI );
			if ( $oroomnum ) {
				$oroomclass = getroomspc( $oroomnum );
				$osetname = $roomclass[$oroomclass][16];
				@oroomchars = getroomchars( $oroomnum );
				my $intvalid_b6 = 0;
				$orinterior = $roominfo[$oroomnum][17];
				$orintname = $interiorclass[$orinterior][2];
				my $gstyle = 0;
				( $gstyle, $orintvari ) = gethallstyle( $x+$XI, $y+$YI, $z+$ZI );
				print OUTPUT "# orintvari for door $door at $x $y $z off $XI $YI $ZI is $orintvari\n";
				( $intvalid_b6, $orintspc_b6 ) = getintspcflag( $orinterior, 6 );
			} else {
				my $hall = gethallid( $x+$XI, $y+$YI, $z+$ZI );
				my $hclass = 0;
				$ohallclass = gethallinfo( $x+$XI, $y+$YI, $z+$ZI, 0, 0);
				$osetname = gethallinfo( $x+$XI, $y+$YI, $z+$ZI, 1, 18);
	    			( $ovalid_b27, $ohallspc_b27 ) = gethallflag( $x+$XI, $y+$YI, $z+$ZI, 27 );
	    			( $ovalid_b29, $ohallspc_b29 ) = gethallflag( $x+$XI, $y+$YI, $z+$ZI, 29 );
			}

			# check if we should add room style to door schematic path
			my ( $ivalid_b41, $iroomspc_b41) = getroomspcflag( $iroomclass, 41 ) if $iroomclass;
			my ( $ovalid_b41, $oroomspc_b41) = getroomspcflag( $oroomclass, 41 ) if $oroomclass;

			# skip door if room classes disallow door rendering
			my ( $irvalid_b29, $iroomspc_b29) = getroomspcflag( $iroomclass, 29 ) if $iroomclass;
			my ( $orvalid_b29, $oroomspc_b29) = getroomspcflag( $oroomclass, 29 ) if $oroomclass;

			next if ( $iroomspc_b29 || $oroomspc_b29 );

			my ( $idatasetname,$ivalid,$ifft,$iwft,$icft,$ifst,$iwst,$icst,$iffs,$iwfs,$icfs,$ifss,$iwss,$icss,$iswl,
				$iulo,$ioco,$ihco,$ivco,$icmt,$iomt,$ipmt,$ievt,$itfa,$ibfa,$itsa,$ibsa,$imfa,$imsa,$ihcs,$ihcf,$ihfs,$ihff) =
				getdatasetinfo( $isetname );
			my ( $odatasetname,$ovalid,$offt,$owft,$ocft,$ofst,$owst,$ocst,$offs,$owfs,$ocfs,$ofss,$owss,$ocss,$oswl,
				$oulo,$ooco,$ohco,$ovco,$ocmt,$oomt,$opmt,$oevt,$otfa,$obfa,$otsa,$obsa,$omfa,$omsa,$ohcs,$ohcf,$ohfs,$ohff) =
				getdatasetinfo( $osetname );

			$ifev = getfev( $x, $y, $z );
			$ofev = getfev( $x+$XI, $y+$YI, $z+$ZI );

			my $isegment = getsegment( $x, $y, $z );
			my $osegment = getsegment( $x+$XI, $y+$YI, $z+$ZI );

			# print "ifev $ifev ofev $ofev iroom $roomnum oroom $oroomnum\n";

			my $doorschtype = $doorclass[$doorclass][11];
			my $pdoorschtype = $doorclass[$doorclass][12];

			# get door type (doorway/archway/open segment) flags from door class
			my ( $dvalid_b15, $doorspc_b15) = getdoorspcflag( $doorclass, 15 );
			my ( $dvalid_b14, $doorspc_b14) = getdoorspcflag( $doorclass, 14 );
			my ( $dvalid_b20, $doorspc_b20) = getdoorspcflag( $doorclass, 20 );

			# determine inside wall/ceiling/floor thicknesses
			my $hiwthick = ( $iwfs + $iwss + $ihco );
			my $victhick = ( $icfs + $icss + $ihco );
			my $vifthick = ( $iffs + $ifss + $ihco );

			# determine outside wall/ceiling/floor thicknesses
			my $hewthick = ( $owfs + $owss + $ohco );
			my $vecthick = ( $ocfs + $ocss + $ohco );
			my $vefthick = ( $offs + $ofss + $ohco );

			# determine mc cell coordinates 
			my $xcoord = (( $mc_hscale * $x ) + $mc_xoffset );
	    		# my $ycoord = ( $mc_yoffset - ( $yscale * ( $y + 1 )) + 1 );
			my $ycoord = getycoord( $y );
			my $yscale = getyscale( $y );
			my $zcoord = (( $mc_hscale * $z ) + $mc_zoffset );

			# build the entryway if we have no doorway or archway type specified
			if (($doorspc_b15 == 0 && $doorspc_b14 == 0 && $doorspc_b20 == 0 ) || $dir == 0 ) {

				# determine doorway/opening sizes
				my $doorwidthinc = 1;
				# get door type (doorway/archway) flags from door class
				my ( $dvalid_b15, $doorspc_b15) = getdoorspcflag( $doorclass, 15 );
				my ( $dvalid_b14, $doorspc_b14) = getdoorspcflag( $doorclass, 14 );
				$doorwidthinc = 1 if $doorspc_b14;
				$doorwidthinc = 2 if $doorspc_b15;
				my $doorwayheight = ( $yscale - $iffs - $ifss - $icfs - $icss - ( $ivco * 2 ));
				my $doorheight = ( $doorwayheight - 2 );
				my $doorhstart = ( ceil($mc_hscale/2) - $doorwidthinc );
				my $doorwayhstart = ( ceil($mc_hscale/2) - $doorwidthinc - 1 );
				my $doorwaywidth = ( $mc_hscale - ( $doorwayhstart * 2 ));
				my $doorwidth = ( $mc_hscale - ( $doorhstart * 2 ));

				# determine doorway coordinates based on door direction
				my $ystart = ( $ycoord + $iffs + $ivco );
				my $yostart = ( $ycoord + $vifthick);
				my $ysize = $doorwayheight;
				my $yosize = $doorheight;
				my ( $xstart, $zstart ) = ( $xcoord + $doorwayhstart, $zcoord + $doorwayhstart );
				my ( $xostart, $zostart ) = ( $xcoord + $doorhstart, $zcoord + $doorhstart );
				my ( $xsize, $zsize ) = ( $doorwaywidth, $doorwaywidth );
				my ( $xosize, $zosize ) = ( $doorwidth, $doorwidth );
				if ( $dir == 1 ) {
					$xsize = ( $hiwthick + $hewthick );
					$xstart = ( $xcoord - $hewthick );
					$xostart = $xstart;
					$xosize = $xsize;
				} elsif ( $dir == 2 ) {
					$xstart = ( $xcoord + $mc_hscale - $hiwthick );
					$xostart = $xstart;
					$xsize = ( $hiwthick + $hewthick );
					$xosize = $xsize;
				} elsif ( $dir == 3 ) {
					$zsize = ( $hiwthick + $hewthick );
					$zstart = ( $zcoord - $hewthick );
					$zostart = $zstart;
					$zosize = $zsize;
				} elsif ( $dir == 4 ) {
					$zstart = ( $zcoord + $mc_hscale - $hiwthick );
					$zsize = ( $hiwthick + $hewthick );
					$zostart = $zstart;
					$zosize = $zsize;
				} elsif ( $dir == 5 ) {
					$ystart = $ycoord + $yscale - $victhick;
					$ysize = ( $victhick + $vefthick );
					$yostart = $ystart;
					$yosize = $ysize;
				} elsif ( $dir == 6 ) {
					$ystart = $ycoord - $vecthick;
					$ysize = ( $vecthick + $vifthick );
					$yostart = $ystart;
					$yosize = $ysize;
				} elsif ( $dir == 0 ) {
					if ( $invertlevels ) {
						$ystart = $ycoord - $vecthick;
						$ysize = ( $vecthick + $vifthick );
					} else {
						$ystart = $ycoord + $yscale - $victhick;
						$ysize = $victhick;
					}
					$yostart = $ystart;
					$yosize = $ysize;
				};

				# create the doorway or archway
				print OUTPUT "fill $iwst $xstart $ystart $zstart $xsize $ysize $zsize\n";
				print OUTPUT "fill 0 $xostart $yostart $zostart $xosize $yosize $zosize\n";
				print OUTPUT "fill $ifst $xostart $ystart $zostart $xosize 1 $zosize\n" if ( $dir > 0 && $dir < 5 );
			} else {
				# determine which door set we should use
				my ( $dwtype, $odwtype ) = ( '', '' );
				if ( $roomnum ) {
					$dwtype = "rdoor" if $doorspc_b14;
					$dwtype = "rarch" if $doorspc_b15;
					$dwtype = "rdoor" if $doorspc_b20;
				} else {
					$dwtype = "hdoor" if $doorspc_b14;
					$dwtype = "harch" if $doorspc_b15;
					$dwtype = "hdoor" if $doorspc_b20;
				}
				if ( $oroomnum ) {
					$odwtype = "rdoor" if $doorspc_b14;
					$odwtype = "rarch" if $doorspc_b15;
					$odwtype = "rdoor" if $doorspc_b20;
				} else {
					$odwtype = "hdoor" if $doorspc_b14;
					$odwtype = "harch" if $doorspc_b15;
					$odwtype = "hdoor" if $doorspc_b20;
				}

				# determine the size and placement of the opening if we are placing an open segment entryway
				my ( $owthick, $octhick, $ofthick ) = ( $hewthick, $vecthick - $ofev, $vefthick + $ofev );
				$owthick = $hiwthick if ( $hiwthick > $hewthick );
				$octhick = ( $victhick - $ifev ) if ( $victhick - $ifev > $octhick );
				$ofthick = ( $vifthick + $ifev ) if ( $vifthick + $ifev > $ofthick );
				my $hosize = $mc_hscale - ( $owthick * 2 );
				my $vosize = ( $yscale - $octhick - $ofthick );
				my $vostart = ( $ycoord + $ofthick );
				my $viofstart = ( $vostart - $iwss );
				my $voofstart = ( $vostart - $owss );
				my ( $xioc, $zioc ) = ( $xcoord + $owthick, $zcoord + $owthick );
				my ( $xooc, $zooc ) = ( $xioc, $zioc );
				my ( $xos, $zos ) = ( $hosize, $hosize );
				my ( $xis, $zis ) = ( $hosize, $hosize );

				my ( $xic, $xoc, $zic, $zoc ) = ( $xcoord + 1, $xcoord + 1, $zcoord + 1, $zcoord + 1 );
				my ( $xoextcoord, $zoextcoord ) = ( $xcoord, $zcoord );
				my $yc = ( $ycoord + 1 );
				my $rdir = 0;

				# position the doorway/archway depending on its specified direction
				if ( $dir == 1 || $dir == 8 || $dir == 12 || $dir == 16 || $dir == 20 || $dir == 24 || $dir == 28 ) {
					$xoc = ($xcoord - $hewthick );
					$xic = $xcoord;
					$xooc = $xoc;
					$xioc = $xic;
					$xoextcoord = ($xcoord - $mc_hscale);
					$rdir = 2;
					$dir = 1;
					$xos = $hewthick;
					$xis = $hiwthick;
					
				} elsif ( $dir == 2 || $dir == 9 || $dir == 13 || $dir == 17 || $dir == 21 || $dir == 25 || $dir == 29 ) {
					$xic = ( $xcoord + $mc_hscale - $hiwthick );
					$xoc = ( $xcoord + $mc_hscale );
					$xooc = $xoc;
					$xioc = $xic;
					$xoextcoord = ($xcoord + $mc_hscale);
					$rdir = 1;
					$dir = 2;
					$xos = $hewthick;
					$xis = $hiwthick;

				} elsif ( $dir == 3 || $dir == 10 || $dir == 14 || $dir == 18 || $dir == 22 || $dir == 26 || $dir == 30 ) {
					$zoc = ($zcoord - $hewthick );
					$zic = $zcoord;
					$zooc = $zoc;
					$zioc = $zic;
					$zoextcoord = ($zcoord - $mc_hscale);
					$rdir = 4;
					$dir = 3;
					$zos = $hewthick;
					$zis = $hiwthick;

				} elsif ( $dir == 4 || $dir == 11 || $dir == 15 || $dir == 19 || $dir == 23 || $dir == 27 || $dir == 31 ) {
					$zic = ( $zcoord + $mc_hscale - $hiwthick );
					$zoc = ( $zcoord + $mc_hscale );
					$zooc = $zoc;
					$zioc = $zic;
					$zoextcoord = ($zcoord + $mc_hscale);
					$rdir = 3;
					$dir = 4;
					$zos = $hewthick;
					$zis = $hiwthick;
				}

				print OUTPUT "# xic $xic xoc $xoc zic $zic zoc $zoc hiw $hiwthick hew $hewthick\n";

				# add the door style indicator to the schematic name if the room flag bit 41 is set.
				my ( $odoorstyle, $idoorstyle ) = ( '', '' );
				my $ostyle = $oroomchars[0];
				$ostyle = 0 if ( ! $ostyle );
				$odoorstyle = "/style$ostyle" if ( $oroomspc_b41 );
				my $istyle = $iroomchars[0];
				$istyle = 0 if ( ! $istyle );
				$idoorstyle = "/style$istyle" if ( $iroomspc_b41 );

				if ( ( ! $doorspc_b20 ) || ( $doorspc_b20 && $oroomnum ) ) {
					# render the outer door
					my $osch = "$mc_schemroot/$odatasetname$odoorstyle/$odwtype$pdoorschtype-$rdir";
					$osch = "$mc_schemroot/$odatasetname/fev$ofev$odoorstyle/$odwtype$pdoorschtype-$rdir" if $ofev;
					my $oext = "-ext";
					$oext = "-extf" if ( $osegment & 32 );

					# check if we need a special interior-specific doorway
					if ( $orintspc_b6 ) {
						my $osch = "$mc_schemroot/rooms/$orintname-v$orintvari-$odwtype$pdoorschtype-$rdir";
						print OUTPUT "import $osch.schematic $xcoord $ycoord $zcoord noair\n";
						print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
					} else {
						print OUTPUT "import $osch.schematic $xoc $yc $zoc\n";
					};

					if ( $ohallspc_b27 ) {
						print OUTPUT "import $osch$oext.schematic $xoextcoord $ycoord $zoextcoord noair\n";
						print OUTPUT "replace 62 with 0 $xoextcoord $ycoord $zoextcoord $mc_hscale $yscale $mc_hscale\n";
					};

					# render the opening if we are specifying an open segment entryway
					if ( $doorspc_b20 && $oroomnum ) {
						print OUTPUT "import $osch.schematic $xoc $yc $zoc\n";
						print OUTPUT "fill 0 $xooc $vostart $zooc $xos $vosize $zos\n";
						print OUTPUT "replace $owst with $ofst $xooc $voofstart $zooc $xos $ofss $zos\n";
					};
					# Add the hallway endpoint in the room if the hallway requires it
					if ( $ihallspc_b29 && $oroomnum && $doorspc_b20 ) {
						my ($fevsch, $flrsch ) = ( '', '' );
						$fevsch = "/fev$ifev" if ( $ifev );
						$flrsch = "-f" if ( $osegment & 32 );
						my $epsch = "$mc_schemroot/$idatasetname$fevsch/roomendpoint$flrsch-$dir.schematic";
						print OUTPUT "import $epsch $xcoord $ycoord $zcoord noair\n";
					};
				};

				if ( ( ! $doorspc_b20 ) || ( $doorspc_b20 && $roomnum ) ) {
					# render the inner door
					my $isch = "$mc_schemroot/$idatasetname$idoorstyle/$dwtype$doorschtype-$dir";
					$isch = "$mc_schemroot/$idatasetname/fev$ifev$idoorstyle/$dwtype$doorschtype-$dir" if $ifev;
					my $iext = "-ext";
					$iext = "-extf" if ( $isegment & 32 );

					# check if we need a special interior-specific doorway
					if ( $irintspc_b6 ) {
						my $isch = "$mc_schemroot/rooms/$irintname-v$irintvari-$dwtype$pdoorschtype-$dir";
						print OUTPUT "import $isch.schematic $xcoord $ycoord $zcoord noair\n";
						print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
					} else {
						print OUTPUT "import $isch.schematic $xic $yc $zic\n";
					};

					if ( $ihallspc_b27 ) {
						print OUTPUT "import $isch$iext.schematic $xcoord $ycoord $zcoord noair\n";
						print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
					};

					# render the opening if we are specifying an open segment entryway
					if ( $doorspc_b20 && $roomnum ) {
						print OUTPUT "import $isch.schematic $xic $yc $zic\n";
						print OUTPUT "fill 0 $xioc $vostart $zioc $xis $vosize $zis\n";
						print OUTPUT "replace $iwst with $ifst $xioc $viofstart $zioc $xis $ifss $zis\n";
					};
					# Add the hallway endpoint in the room if the hallway requires it
					if ( $ohallspc_b29 && $roomnum && $doorspc_b20 ) {
						my ($fevsch, $flrsch ) = ( '', '' );
						$fevsch = "/fev$ofev" if ( $ofev );
						$flrsch = "-f" if ( $isegment & 32 );
						my $epsch = "$mc_schemroot/$odatasetname$fevsch/roomendpoint$flrsch-$dir.schematic";
						print OUTPUT "import $epsch $xcoord $ycoord $zcoord noair\n";
					};
				};
			}
		}
	}

	# perform any room-specific actions
	if ( $totalrooms > 0 ) {
		foreach my $room ( 1 .. $totalrooms ) {
			my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $room );
			my ($feffectlvl, $feffecttype) = getfeffectlvl( $xe, $ye, $ze );
			my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xe, $ye, $ze );
			my $roomspc = getroomspc( $room );

			my $xfc=( $xc+$xs-1 );
			my $yfc=( $yc+$ys-1 );
			my $zfc=( $zc+$zs-1 );

			# add vertical ribbed effect if specified for room
			my ( $valid_b39, $roomspc_b39) = getroomspcflag( $roomspc, 39 );
			if ( $roomspc_b39 ) {
			    # create a consistent random pattern for the ribbed effect
			    my @materials = ( 0, 0, 1, 4, 4, 4, 7, 7, 7 );
			    my @randwalls;
			    for my $side ( 1 .. 4 ) {
				    for my $xzpos ( 0 .. (($mc_hscale * 4 )-1) ) {
					$randwalls[$side][$xzpos] = int( rand( @materials ) );
				    };
			    };
			    print OUTPUT "# bit39 for room $room\n";
			    my $lookupsetname = $roomclass[$roomspc][16];
			    my $roomsetvalid;
			    my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
				$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( $lookupsetname );
			    $wst = 4 if ( ! $wst );
			    for my $xinc ( $xc .. ($xc + $xs - 1 ) ) {
				my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );
				for my $zinc ( $zc .. ($zc + $zs - 1 ) ) {
				    my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );
				    for my $yinc ( $yc .. ( $yc + $ys - 1 ) ) {

					# skip this cell if it does not belong to the target room
					my $room2 = getroomid( $xinc, $yinc, $zinc );
					next if ( $room2 != $room );

					print OUTPUT "# cell $xinc $yinc $zinc\n";

					my $xstart = ( $xcoord + $hco + $wfs );
					my $zstart = ( $zcoord + $hco + $wfs );
					my $xend = ( $xcoord + $mc_hscale - $hco - $wfs - 1 );
					my $zend = ( $zcoord + $mc_hscale - $hco - $wfs - 1 );
					my $segment = getsegment( $xinc, $yinc, $zinc );
					my $ycoord = getycoord( $yinc );
					my $yscale = getyscale( $yinc );

					if ( $segment & 1 ) {
						for my $zpos ( $zstart .. $zend ) {
							my $randval = $randwalls[1][$zpos % ( $mc_hscale * 4 )];
							my $matval = $materials[$randval];
							next if $matval == $wst;
							print OUTPUT "replace $wst with $matval $xstart $ycoord $zpos 1 $yscale 1\n";
						};
					};
					if ( $segment & 2 ) {
						for my $zpos ( $zstart .. $zend ) {
							my $randval = $randwalls[2][$zpos % ( $mc_hscale * 4 )];
							my $matval = $materials[$randval];
							next if $matval == $wst;
							print OUTPUT "replace $wst with $matval $xend $ycoord $zpos 1 $yscale 1\n";
						};
					};
					if ( $segment & 4 ) {
						for my $xpos ( $xstart .. $xend ) {
							my $randval = $randwalls[3][$xpos % ( $mc_hscale * 4 )];
							my $matval = $materials[$randval];
							next if $matval == $wst;
							print OUTPUT "replace $wst with $matval $xpos $ycoord $zstart 1 $yscale 1\n";
						};
					};
					if ( $segment & 8 ) {
						for my $xpos ( $xstart .. $xend ) {
							my $randval = $randwalls[4][$xpos % ( $mc_hscale * 4 )];
							my $matval = $materials[$randval];
							next if $matval == $wst;
							print OUTPUT "replace $wst with $matval $xpos $ycoord $zend 1 $yscale 1\n";
						};
					};
				    };
				};
			    };
			};

			# determine if we are dealing with a submerged room
			my ( $valid_b5, $roomspc_b5) = getroomspcflag( $roomspc, 5 );

			# determine if room is a lava pit
			my ( $valid_b28, $roomspc_b28) = getroomspcflag( $roomspc, 28 );

			# update room cells
          		foreach my $yinc ($yc .. $yfc) {
          		    foreach my $xinc ($xc .. $xfc) {
            			foreach my $zinc ($zc .. $zfc) {
					next if ( $room != getroomid( $xinc, $yinc, $zinc ));

					my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );
	    				# my $ycoord = ( $mc_yoffset - ( $yscale * ( $yinc + 1 )) + 1 );
					my $ycoord = getycoord( $yinc );
					my $yscale = getyscale( $yinc );
					my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );

					# fill lowest level of room with lava if room is marked as a lava pit
					if ( $roomspc_b28 && $yinc == $yfc ) {
						my $half = int( $yscale / 2 );
						print OUTPUT "replace 50 with 11 $xcoord $ycoord $zcoord $mc_hscale $half $mc_hscale\n";
						print OUTPUT "replace 0 with 11 $xcoord $ycoord $zcoord $mc_hscale $half $mc_hscale\n";
					};
					# fill lower levels of room with water if room is marked as submerged
					if ( $roomspc_b5 && $yinc != $yc ) {
						print OUTPUT "replace 50 with 9 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
						print OUTPUT "replace 0 with 9 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
					};
				}
			    }
			}
		};
	};

	# place custom pillars and remove pillars
	foreach my $pillar ( 1 .. $pillarcount ) {
	    my $X = $pillarlist[$pillar][0];
	    my $Y = $pillarlist[$pillar][1];
	    my $Z = $pillarlist[$pillar][2];
	    my $hall = gethallid( $X, $Y, $Z );
	    my $vheflags = $pillarlist[$pillar][3];
	    my $hclass = $pillarlist[$pillar][4];
	    my $height = $pillarlist[$pillar][10];
	    my $opattern = $pillarlist[$pillar][6];
	    my $pfeffecttype = $pillarlist[$pillar][7];

	    my $levelyscale = getyscale( $Y );

	    my $lookupsetname = gethallinfo( $X, $Y, $Z, 1, 18);
	    my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
		$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( $lookupsetname );

	    my ( $valid_b20, $hallspc_b20 ) = gethallflag( $X, $Y, $Z, 20 );
	    my ( $valid_b28, $hallspc_b28 ) = gethallflag( $X, $Y, $Z, 28 );

	    my $ycoord = getycoord( $Y );
	    my $yccoord = getycoord( $Y - $height + 1 );
	    my $eycoord = $ycoord + 1;
	    my $pxcoord = (( $mc_hscale * ( $X + 1 ) ) + $mc_xoffset - $wfs - $wss - $hco );
	    my $pzcoord = (( $mc_hscale * ( $Z + 1 ) ) + $mc_zoffset - $wfs - $wss - $hco );
	    my $hsize = (( $wfs + $wss + $hco ) * 2 );
	    my $harea = ( $mc_hscale * 2 );
	    my $vesize = $levelyscale * $height - 2;
	    my $vmcsize = $levelyscale * $height;
	    

	    if ( $height >= 2 && ! $hallspc_b28 ) {

		# replace pillar

		my $xcoord = (( $mc_hscale * $X ) + $mc_xoffset + int( $mc_hscale / 2 ));
		my $zcoord = (( $mc_hscale * $Z ) + $mc_zoffset + int( $mc_hscale / 2 ));

		my $pillarodds = gethallinfo( $X, $Y, $Z, 1, 22 );
		my $pillarsel = gethallinfo( $X, $Y, $Z, 1, 23 );

		next if ( ! $pillarodds );
		next if ( ! $pillarsel );

		next if ( $pillarodds < int(rand(100)) );

		my $pillarsch = int(rand( $pillarsel ));

		print OUTPUT "fill 0 $pxcoord $eycoord $pzcoord $hsize $vesize $hsize\n";
		print OUTPUT "import $mc_schemroot/$dsname/pillar-h$height-$pillarsch.schematic $xcoord $ycoord $zcoord noair\n";

	    } elsif (( $height == 1 && $hallspc_b20 ) || ( $height >= 2 && $hallspc_b28 )) {

		# remove pillar

		# selectively perform a material replacement based on the vhe edge enhancement flag state
		my ( $hfound_b11, $hflag_b11 ) = gethallflag( $X, $Y, $Z, 11 );
		my ( $hfound_b10, $hflag_b10 ) = gethallflag( $X, $Y + $height - 1, $Z, 10 );

		my $xcoord = (( $mc_hscale * $X ) + $mc_xoffset );
		my $zcoord = (( $mc_hscale * $Z ) + $mc_zoffset );
		my $cpattern = ( $opattern & 0x0f );
		my $fpattern = (( $opattern >> 4 ) & 0x0f );

		# remove the top and bottom parts of the pillar
		print OUTPUT "import $mc_schemroot/$dsname/rem-pillar-c$cpattern.schematic $xcoord $yccoord $zcoord noair\n";
		print OUTPUT "import $mc_schemroot/$dsname/rem-pillar-f$fpattern.schematic $xcoord $ycoord $zcoord noair\n";

		# remove the middle segments of the pillar
		for my $ym ( 2 .. $height ) {
			my $ymcoord = getycoord( $Y - $ym + 2 );
			print OUTPUT "import $mc_schemroot/$dsname/rem-pillar-mid.schematic $xcoord $ymcoord $zcoord noair\n";
		};

		# perform vhe edge enhancement, if requested
		print OUTPUT "import $mc_schemroot/$dsname/vhe-edge-pf$fpattern.schematic $xcoord $ycoord $zcoord noair\n" if ( $hflag_b11 && $fpattern );
		print OUTPUT "import $mc_schemroot/$dsname/vhe-edge-pc$cpattern.schematic $xcoord $yccoord $zcoord noair\n" if ( $hflag_b10 && $cpattern );

		# perform material conversion
		print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $harea $vmcsize $harea\n";
	    };
	};

	# Add any passthru segments after rooms have rendered but before floor/ceiling effects.
	foreach my $yincr (1 .. $ymazesize ) {
	    my $yinc = $ymazesize - $yincr;
		
	    my $yscale = getyscale( $yinc );
	    my $ycoord = ( $mc_yoffset - ( $yscale * ( $yinc + 1 )) + 1 );

       	    foreach my $zinc (0 .. $zmazesize-1) {
		my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );

        	foreach my $xinc (0 .. $xmazesize-1) {
			my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );

			# skip this cell if it is not a passthru segment
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );
			next if ( $cellspc < 32 || $cellspc > 39 );

			# get cell information
			my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
				getcellinfo( $xinc, $yinc, $zinc );

			# get hallway information
			my $hall = gethallid( $xinc, $yinc, $zinc );
			my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
			my $hallsetvalid;
			my $lookupsetname = gethallinfo( $xinc, $yinc, $zinc, 1, 18);
			my $setname = '';
			($setname, $hallsetvalid) = getdatasetinfo( $lookupsetname );
			$setname = '' if ( ! $setname || ! $hallsetvalid );

			# skip this cell if we do not have a valid dataset name.
			next if ! $setname;

			my $fev = 0;
			$fev = getfev( $xinc+1, $yinc, $zinc ) if ( $cellspc == 36 );
			$fev = getfev( $xinc-1, $yinc, $zinc ) if ( $cellspc == 37 );
			$fev = getfev( $xinc, $yinc, $zinc+1 ) if ( $cellspc == 38 );
			$fev = getfev( $xinc, $yinc, $zinc-1 ) if ( $cellspc == 39 );

			# floor elevation schematic path adjustment
			my $fevpath = '';
			$fevpath = "/fev$fev" if ( $fev );

			# check for special room interior requirements
			my $addfloor = 0;
			my $interior = $roominfo[$roomid][17];
			if ( $interior ) {
				my ( $intvalid_b11, $intspc_b11 ) = getintspcflag( $interior, 11 );

				# a special floor layer was added with the interior, so passthru type should be adjusted.
				$addfloor = 1 if ( $intspc_b11 );
			};

			# ceiling present schematic path adjustment
			my $cflag = 'nc';
			$cflag='c' if ( $segment & 16 );

			# floor present schematic path adjustment
			my $fflag = 'nf';
			$fflag='f' if (( $segment & 32 ) || $addfloor );

			# cellspc schematic path adjustment
			my $dflag = '';
			$dflag = 'we' if ( $cellspc == 34 );
			$dflag = 'ns' if ( $cellspc == 35 );
			$dflag = 'e' if ( $cellspc == 36 );
			$dflag = 'w' if ( $cellspc == 37 );
			$dflag = 's' if ( $cellspc == 38 );
			$dflag = 'n' if ( $cellspc == 39 );

			# cellspc 32-33 are single-span and are treated specially
			if ( $cellspc == 32 ) {
				my $wfev = getfev( $xinc-1, $yinc, $zinc );
				my $efev = getfev( $xinc+1, $yinc, $zinc );
				$dflag = "sswe$wfev$efev";
				$fevpath = '';
			} elsif ( $cellspc == 33 ) {
				my $nfev = getfev( $xinc, $yinc, $zinc-1 );
				my $sfev = getfev( $xinc, $yinc, $zinc+1 );
				$dflag = "ssns$nfev$sfev";
				$fevpath = '';
			};

			my $setpath = "$mc_schemroot/$setname$fevpath/passthru-$fflag-$cflag-$dflag.schematic";
			print OUTPUT "import $setpath $xcoord $ycoord $zcoord noair\n";
			print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
		};
	    };
	};

	# place floor/ceiling effects, custom floors, and crossover spans
	foreach my $yinc (0 .. $ymazesize-1) {
	    my $ycoord = getycoord( $yinc );
	    # my $ycoord = ( $mc_yoffset - ( $yscale * ( $yinc + 1 )) + 1 );
	    my $yscale = getyscale( $yinc );
            foreach my $zinc (0 .. $zmazesize-1) {
		my $zcoord = (( $mc_hscale * $zinc ) + $mc_zoffset );
        	foreach my $xinc (0 .. $xmazesize-1) {
			my $xcoord = (( $mc_hscale * $xinc ) + $mc_xoffset );
			my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
				getcellinfo( $xinc, $yinc, $zinc );
			next if ! $valid;
			my ( $uvalid, $ucelluse, $upaths, $ubackdir, $usegment, $uroomid, $udist, $ufeffectlvl, $ufeffecttype, $uceffectlvl, $uceffecttype ) =
				getcellinfo( $xinc, $yinc-1, $zinc );
			my $pillarflag = getpillarflag( $xinc, $yinc, $zinc );
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );

			print OUTPUT "# feffect $xinc $yinc $zinc coord $xcoord $ycoord $zcoord\n";

			# get floor effect flags
			my ( $fvalid_b0, $fflag_b0) = getfeffectspcflag( $feffecttype, 0 );
			my ( $fvalid_b1, $fflag_b1) = getfeffectspcflag( $feffecttype, 1 );
			my ( $fvalid_b2, $fflag_b2) = getfeffectspcflag( $feffecttype, 2 );
			my ( $fvalid_b3, $fflag_b3) = getfeffectspcflag( $feffecttype, 3 );
			my ( $fvalid_b5, $fflag_b5) = getfeffectspcflag( $feffecttype, 5 );
			my ( $fvalid_b6, $fflag_b6) = getfeffectspcflag( $feffecttype, 6 );
			my ( $fvalid_b9, $fflag_b9) = getfeffectspcflag( $feffecttype, 9 );
			my ( $fvalid_b10, $fflag_b10) = getfeffectspcflag( $feffecttype, 10 );
			my ( $fvalid_b11, $fflag_b11) = getfeffectspcflag( $feffecttype, 11 );

			# get ceiling effect flags
			my ( $cvalid_b0, $cflag_b0) = getceffectspcflag( $ceffecttype, 0 );
			my ( $cvalid_b1, $cflag_b1) = getceffectspcflag( $ceffecttype, 1 );
			my ( $cvalid_b2, $cflag_b2) = getceffectspcflag( $ceffecttype, 2 );
			my ( $cvalid_b3, $cflag_b3) = getceffectspcflag( $ceffecttype, 3 );
			my ( $cvalid_b5, $cflag_b5) = getceffectspcflag( $ceffecttype, 5 );
			my ( $cvalid_b6, $cflag_b6) = getceffectspcflag( $ceffecttype, 6 );
			my ( $cvalid_b9, $cflag_b9) = getceffectspcflag( $ceffecttype, 9 );
			my ( $cvalid_b10, $cflag_b10) = getceffectspcflag( $ceffecttype, 10 );
			my ( $cvalid_b11, $cflag_b11) = getceffectspcflag( $ceffecttype, 11 );

			# set flags based on whether we have floor or ceiling segments
			my ( $floor, $ceiling )  = ( 1, 1 );
			$floor = 0 if (( $segment & 32 ) == 0 );
			$ceiling = 0 if (( $segment & 16 ) == 0 );

			my $hseg = ($segment & 15 );
			my $vseg = ($segment & 48 );

			# get the dateset name from the room or hallway class data
			my ( $setname, $roomspc, $lookupsetname ) = ( $defaultset, $defaultset, 0 );

			if ( $roomid ) {
				# get the dataset name
				$roomspc = getroomspc( $roomid );
				$lookupsetname = $roomclass[$roomspc][16];
				my $roomsetvalid;
				($setname, $roomsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = $defaultset if ( ! $setname || ! $roomsetvalid );
			} else {
				my $hall = gethallid( $xinc, $yinc, $zinc );
				my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);
				my $hallsetvalid;
				$lookupsetname = gethallinfo( $xinc, $yinc, $zinc, 1, 18);
				($setname, $hallsetvalid) = getdatasetinfo( $lookupsetname );
				$setname = $defaultset if ( ! $setname || ! $hallsetvalid );
			};

			# get the information for the particular dataset we are referencing
			my ( $dsname,$dsvalid,$fft,$wft,$cft,$fst,$wst,$cst,$ffs,$wfs,$cfs,$fss,$wss,$css,$swl,
				$ulo,$oco,$hco,$vco,$cmt,$omt,$pmt,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff) = getdatasetinfo( $lookupsetname );
			my ( $cfvalid, $cfflag) = getdatasetflag( $dsname, 0 );
			my $vheflags = getvhe( $xinc, $yinc, $zinc );
			my $fev = getfev( $xinc, $yinc, $zinc );
			my $setpath = "$mc_schemroot/$setname";

			# if we are dealing with a passthru, grab certain info about the hallway dataset type
			my ( $ptswl, $ptwlvl ) = (0, 0);
			if ( $cellspc >= 32 && $cellspc <= 39 ) {
			    my $hallsetname = gethallinfo( $xinc, $yinc, $zinc, 1, 18);
			    my ( $hdsname,$hdsvalid,$x0,$x1,$x2,$x3,$x4,$x5,$xffs,$xc,$xd,$xfss,$xe,$xf,$xswl,
				$x6,$x7,$hhco,$xvco,$x8,$x9,$xa,$xb,$xg,$xh,$xi,$xj) = getdatasetinfo( $hallsetname );
			    $ptswl = $xswl if $xswl;
			    $ptwlvl = $xvco + $xffs + $xfss + $xswl + $fev;
			};

			# determine if we have any transitional VHE walls
			my ( $lssegid, $ussegid, $ssegid ) = getvhesseg( $xinc, $yinc, $zinc );

			# get the 'hallway submerged' bit from the hall class info
	    		my ( $valid_b24, $hallspc_b24 ) = gethallflag( $xinc, $yinc, $zinc, 24 );

			my ( $pfxseg, $pfzseg, $pfwidth ) = ( 0, 0, 0 );

			# get floor/ceiling effect information
			my $flevel = $feffectlvl;
			my $clevel = $ceffectlvl;
			my $fleveloffset = $feffectclass[$feffecttype][4];
			my $cleveloffset = $ceffectclass[$ceffecttype][4];
			$fleveloffset = 0 if ( ! $fleveloffset );
			$cleveloffset = 0 if ( ! $cleveloffset );
			my $mc_fset = $feffectclass[$feffecttype][5];
			my $mc_cset = $ceffectclass[$ceffecttype][5];
			$mc_fset = $feffectclass[$feffecttype][6] if ( ! $roomid );
			$mc_cset = $ceffectclass[$ceffecttype][6] if ( ! $roomid );
			my $fceffectdir = "$mc_schemroot/fceffect";
			my $feffectset = "$fceffectdir/$mc_fset";
			my $ceffectset = "$fceffectdir/$mc_cset";
			my $feffectrand = $feffectclass[$feffecttype][19];
			my $ceffectrand = $ceffectclass[$ceffecttype][19];

			# clear the custom floor flag if this is the pit of a pit trap.
			if ( $cellspc == 11 ) {
				$cfflag = 0;
			};

			# clear the floor effect flags if floor effects are not allowed
			if ( ! $feffectlvl || ! $allowfeffects || ! $floor ) {
				$fflag_b0 = 0;
				$fflag_b1 = 0;
				$fflag_b2 = 0;
				$fflag_b3 = 0;
				$fflag_b5 = 0;
				$fflag_b6 = 0;
			};

			# clear the ceiling effect flags if ceiling effects are not allowed
			if ( ! $ceffectlvl || ! $allowceffects || ! $ceiling ) {
				$cflag_b0 = 0;
				$cflag_b1 = 0;
				$cflag_b2 = 0;
				$cflag_b3 = 0;
				$cflag_b5 = 0;
				$cflag_b6 = 0;
			};

			for my $festep ( "CFL", "SWL", "PTSWL", "FB0", "FB2", "FB1", "FB3", "FB6", "FB5", "CB0", "CB2", "CB1", "CB3", "CB6", "CB5", "XOS" ) {

			    next if ( $festep eq "CFL" && ! $cfflag );
			    next if ( $festep eq "SWL" && ! $swl && ! $hallspc_b24 );
			    next if ( $festep eq "PTSWL" && ( $cellspc < 32 || $cellspc > 39 ) );
			    next if ( $festep eq "FB0" && ! $fflag_b0 );
			    next if ( $festep eq "FB1" && ! $fflag_b1 );
			    next if ( $festep eq "FB2" && ! $fflag_b2 );
			    next if ( $festep eq "FB3" && ! $fflag_b3 );
			    next if ( $festep eq "FB5" && ! $fflag_b5 );
			    next if ( $festep eq "FB6" && ! $fflag_b6 );
			    next if ( $festep eq "CB0" && ! $cflag_b0 );
			    next if ( $festep eq "CB1" && ! $cflag_b1 );
			    next if ( $festep eq "CB2" && ! $cflag_b2 );
			    next if ( $festep eq "CB3" && ! $cflag_b3 );
			    next if ( $festep eq "CB5" && ! $cflag_b5 );
			    next if ( $festep eq "CB6" && ! $cflag_b6 );

			    # add a custom floor if required
			    if ( $festep eq "CFL" ) {
				if ( $floor ) {
				    if ( $cfflag && ( $segment & 32 ) ) {
					if ( $roomid ) {
						my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $roomid );
						my ( $xstart, $zstart) = ( $xc, $zc);
						$xstart += ( $hco + $wfs + $wss ) if ( $segment & 1 );
						$zstart += ( $hco + $wfs + $wss ) if ( $segment & 4 );
						if ( $ys == 1 && $vseg == 48 ) {
							print OUTPUT "import $setpath/rcustfloor0.$hseg.schematic $xstart $ycoord $zstart\n";
						} elsif ( $ys == 2 && $ycoord == $yc && $vseg == 32 ) {
							print OUTPUT "import $setpath/rcustfloor1.$hseg.schematic $xstart $ycoord $zstart\n";
						}
					} else {
						my $vheflags = getvhe( $xinc, $yinc, $zinc );
						my $rand = int(rand(16));
						my $wallthick = ( $hco + $wfs + $wss );
						my $endpos = ( $mc_hscale - $wallthick );
						my $xhall = ( $xcoord + $wallthick );
						my $zhall = ( $zcoord + $wallthick );
						my $xend = ( $xcoord + $endpos );
						my $zend = ( $zcoord + $endpos );
						my $group = 0;

						# set the group variable to 1 if we have a 2-high vhe hallway.
						if ( ( $vheflags == 4 || $vheflags == 5 ) && $vseg == 32 ) {
							my $segment2 = getsegment( $xinc, $yinc - 1, $zinc ) & 48;
							$group = 1 if ( $segment2 == 16 );
						};
						my $continue = 1;
	
						# skip this cell if it is a vhe segment we haven't designed a custom floor for
						$continue = 0 if ( $group == 0 && $vheflags );
	
						# skip a non-vhe cell if it has a vertical path into it
						$continue = 0 if ( ( ( $paths & 48 ) != 48 ) && ( $vheflags == 0 ) );
						print "vpath skip for $xinc $yinc $zinc\n" if ( ( ( $paths & 48 ) != 48 ) && ( $vheflags == 0 ) );
	
						if ( $continue ) {
					    	    print OUTPUT "import $setpath/hcustfloor$group.$rand.schematic $xhall $ycoord $zhall noair\n";
	
					    	    if ( ! ( $segment & 1 ) ) {
							$rand = int(rand(16));
							print OUTPUT "import $setpath/hcustfloorx$group.$rand.schematic $xcoord $ycoord $zhall noair\n";
					    	    }
					    	    if ( ! ( $segment & 2 ) ) {
							$rand = int(rand(16));
							print OUTPUT "import $setpath/hcustfloorx$group.$rand.schematic $xend $ycoord $zhall noair\n";
					    	    }
					    	    if ( ! ( $segment & 4 ) ) {
							$rand = int(rand(16));
							print OUTPUT "import $setpath/hcustfloorz$group.$rand.schematic $xhall $ycoord $zcoord noair\n";
					    	    }
					    	    if ( ! ( $segment & 8 ) ) {
							$rand = int(rand(16));
							print OUTPUT "import $setpath/hcustfloorz$group.$rand.schematic $xhall $ycoord $zend noair\n";
					    	    }
						    if ( $pillarflag ) {
							my $match = 0;
							my ( $X, $Y, $Z, $vheflags, $hclass, $action, $opattern, $pfeffecttype );
							foreach my $pillar ( 1 .. $pillarcount ) {
							    $X = $pillarlist[$pillar][0];
							    $Y = $pillarlist[$pillar][1];
							    $Z = $pillarlist[$pillar][2];
							    $action = $pillarlist[$pillar][5];
							    next if ( $X != $xinc || $Y != $yinc || $Z != $zinc );
							    next if ( $action != 1 && $action != 2 );
							    $match = 1;
							    last;
							};
							if ( $match ) {
							    print OUTPUT "import $setpath/hcustfloorp$group.$rand.schematic $xend $ycoord $zend noair\n";
							};
						    };
						    # replace the snow block placeholder with air
						    my $yhiscale = $yscale + ( $yscale * $group );
						    print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yhiscale $mc_hscale\n";
		
					    	    my $leaksrc = ($ycoord + $yscale + ( $yscale * $group ) - $vco - 1 );
					    	    my $openlen = ( $vco + $cfs + $css );
					    	    my $opensrc = ($ycoord + $yscale - $openlen - 1 );
					    	    my $leakrand = int(rand(10));
					    	    my $xleak = $xhall + int(rand( $mc_hscale - (( $wallthick ) * 2 ) + 1));
					    	    my $zleak = $zhall + int(rand( $mc_hscale - (( $wallthick ) * 2 ) + 1));
					    	    if ( $leakrand == 0 ) {
							print OUTPUT "fill $omt $xleak $opensrc $zleak 1 $openlen 1\n";
							print OUTPUT "fill 8 $xleak $leaksrc $zleak 1 1 1\n";
					    	    } elsif ( $leakrand == 1 ) {
							print OUTPUT "fill $omt $xleak $opensrc $zleak 1 $openlen 1\n";
							print OUTPUT "fill 10 $xleak $leaksrc $zleak 1 1 1\n";
					    	    }

						    # update lava-covering or waterline on downward VHE segments if required
						    my ( $hfound_b16, $hflag_b16 ) = gethallflag( $xinc, $yinc, $zinc, 16 );
						    if ( ($vheflags >= 0b101) && (($segment & 32 ) == 32 ) && ! $swl && ! $hflag_b16 ) {
							my $floor = $ffs + $fss + $vco + $fev;
							my $stair = $ffs + $fss + $vco + $fev + 1;
							print OUTPUT "replace $fst with 11 $xcoord $ycoord $zcoord $mc_hscale $floor $mc_hscale\n";
							print OUTPUT "replace 67 with 10 $xcoord $ycoord $zcoord $mc_hscale $stair $mc_hscale\n";
						    } elsif ( ($vheflags >= 0b101) && (($segment & 32 ) == 32 ) && $swl ) {
							my $xfcoord = ( $xcoord + $mc_hscale - 1 );
							my $zfcoord = ( $zcoord + $mc_hscale - 1 );
			
							print OUTPUT "replace 4 with 48 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
						    };
						}
					}
				    }
				}
			    };

			    # perform a special static water level conversion for a passthru if required.
			    if ( $festep eq "PTSWL" ) {
				if ( $ptswl ) {
					# passthrus have a special placeholder for the static water level instead of air
					print OUTPUT "replace 21 with 9 $xcoord $ycoord $zcoord $mc_hscale $ptwlvl $mc_hscale\n";
				};
				# clear out any remaining SWL placeholders from the passthru cell
				print OUTPUT "replace 21 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
			    };

			    # establish static water level and mossy cobblestone, if specified in hall class entry
			    if ( $festep eq "SWL" ) {
				my $waterlevel = $vco + $ffs + $fss + $swl + $fev;
				if ( $swl && $dsvalid && ( $cellspc < 32 || $cellspc > 39 ) && ( $cellspc < 48 || $cellspc > 63 ) ) {
					my $waterlevel = $vco + $ffs + $fss + $swl + $fev;
					my $waterline = $waterlevel + 1;
					if ( ( $segment & 32 ) ) {
						# establish a static water level if the floor is solid
						print OUTPUT "replace 0 with 9 $xcoord $ycoord $zcoord $mc_hscale $waterlevel $mc_hscale\n";
						print OUTPUT "replace 4 with 48 $xcoord $ycoord $zcoord $mc_hscale $waterline $mc_hscale\n";
					} else {
						# if the floor does not exist for the static water level, establish a waterfall
						my $wallthick = ( $hco + $wfs + $wss );
						my ( $xstart, $zstart, $xsize, $zsize ) = ( $xcoord, $zcoord, $mc_hscale, $mc_hscale );
						my ( $xostart, $zostart ) = ( $xstart + $wallthick, $zstart + $wallthick );
						my ( $xmstart, $zmstart ) = ( $xostart - 1, $zostart - 1 );
						my $opensize = ( $mc_hscale - ( $wallthick * 2 ) );
						my $mwatersize = $opensize + 2;
						if ( ! ( $lssegid & 1 ) ) {
							$xstart += $wallthick;
							$xsize -= $wallthick;
						};
						if ( ! ( $lssegid & 2 ) ) {
							$xsize -= $wallthick;
						};
						if ( ! ( $lssegid & 4 ) ) {
							$zstart += $wallthick;
							$zsize -= $wallthick;
						};
						if ( ! ( $lssegid & 8 ) ) {
							$zsize -= $wallthick;
						};

						print OUTPUT "replace 4 with 48 $xstart $ycoord $zstart $xsize $waterline $zsize\n";
						print OUTPUT "replace 0 with 9 $xstart $ycoord $zstart $xsize $waterlevel $zsize\n";
						print OUTPUT "replace 9 with 8 $xmstart $ycoord $zmstart $mwatersize $waterlevel $mwatersize\n";
						print OUTPUT "replace 8 with 0 $xostart $ycoord $zostart $opensize $waterlevel $opensize\n";
					};
				} elsif ( $hallspc_b24 && ! $roomid ) {
					print OUTPUT "replace 0 with 9 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
				};
			    };

			    # floor-level air-to-object conversion
			    if ( $festep eq "FB0" ) {

				$flevel = $feffectlvl + $fss + $ffs + $vco + $fev;

				# adjust the floor effect level if it would eliminate a minimum airspace requirement.
				my $alevel = $yscale - ( $css + $cfs + $vco ) - $feffectclass[$feffecttype][9];
				$flevel = $alevel if ( $flevel > $alevel );

				my $mc_rfeffectblock = $feffectclass[$feffecttype][10];
				my $mc_hfeffectblock = $feffectclass[$feffecttype][11];

				print OUTPUT "replace 0 with $mc_rfeffectblock $xcoord $ycoord $zcoord $mc_hscale $flevel $mc_hscale\n" if ( $roomid );
				print OUTPUT "replace 0 with $mc_hfeffectblock $xcoord $ycoord $zcoord $mc_hscale $flevel $mc_hscale\n" if ( ! $roomid );
			    };

			    # ceiling-level air-to-object conversion
			    if ( $festep eq "CB0" ) {
				$clevel = $yscale - ($css + $cfs + $vco ) - $ceffectlvl + $fev;

				# adjust the ceiling effect level if it would eliminate a minimum airspace requirement.
				my $alevel = ( $fss + $ffs + $vco + $fev ) - $ceffectclass[$ceffecttype][9];;
				$clevel = $alevel if ( $clevel > $alevel );

				my $mc_rceffectblock = $ceffectclass[$ceffecttype][10];
				my $mc_hceffectblock = $ceffectclass[$ceffecttype][11];

				print OUTPUT "replace 0 with $mc_rceffectblock $xcoord $ycoord $zcoord $mc_hscale $clevel $mc_hscale\n" if ( $roomid );
				print OUTPUT "replace 0 with $mc_hceffectblock $xcoord $ycoord $zcoord $mc_hscale $clevel $mc_hscale\n" if ( ! $roomid );

			    };

			    # segmented schematic import for floor effects
			    if ( $festep eq "FB1" ) {

				    $flevel = ( $ycoord + $fss + $ffs + $vco + $fev - $fleveloffset );
				    my $schlevel = ( $flevel + $feffectlvl - 1 );
				    my $cnvlvl = ( $feffectlvl - 1 );
				    my $lvl1 = $flevel;
				    my $lvl2 = $flevel + 1;
				    my $lvl3 = $flevel + 2;
				    my $xpos = ( $xinc % 4 );
				    my $zpos = ( $zinc % 4 );
				    my ( $xibox,$zibox,$boxsize ) = ( $xcoord + 1, $zcoord + 1, $mc_hscale - 2 );

				    my $randstr = '';
				    if ( $feffectrand ) {
					my $randval = 1 + int( rand( $feffectrand ) );
					$randstr = ".r$randval";
				    }

				    # my $mc_fset = $feffectclass[$feffecttype][5];
				    # $mc_fset = $feffectclass[$feffecttype][6] if ( ! $roomid );
				    my $mc_rfblock = $feffectclass[$feffecttype][10];
				    my $mc_hfblock = $feffectclass[$feffecttype][11];
				    my $xctr = $xcoord + int( $mc_hscale / 2 );
				    my $zctr = $zcoord + int( $mc_hscale / 2 );

				    if ( $roomid ) {
				        my ( $xstart, $zstart) = ( $xcoord, $zcoord );
				        $xstart += ( $hco + $wfs + $wss ) if ( $segment & 1 );
				        $zstart += ( $hco + $wfs + $wss ) if ( $segment & 4 );
				        my $hseg = ( $segment & 15 );
				        my $wallthick = ( $hco + $wfs + $wss );
				        my $width = ( $mc_hscale - ( $wallthick * 2 ) );

				        if ( $fflag_b6 ) {
					    # special cobweb layout used if floor effect flag bit 6 is set
					    if ( $feffectlvl == 1) {
						print OUTPUT "import $feffectset$randstr.w$width.b1.$hseg.schematic $xstart $lvl1 $zstart noair\n";
					    } elsif ( $feffectlvl == 2 ) {
						print OUTPUT "import $feffectset$randstr.w$width.b2.$hseg.schematic $xstart $lvl1 $zstart noair\n";
					    } elsif ( $feffectlvl == 3 ) {
						print OUTPUT "import $feffectset$randstr.w$width.b1.$hseg.schematic $xstart $lvl1 $zstart noair\n";
						print OUTPUT "import $feffectset$randstr.w$width.b2.$hseg.schematic $xstart $lvl1 $zstart noair\n";
						print OUTPUT "import $feffectset$randstr.w$width.b1.$hseg.schematic $xstart $lvl2 $zstart noair\n";
						print OUTPUT "import $feffectset$randstr.w$width.b2.$hseg.schematic $xstart $lvl3 $zstart noair\n";
						print OUTPUT "import $feffectset$randstr.w$width.b4.$hseg.schematic $xstart $lvl3 $zstart noair\n";
					    } elsif ( $feffectlvl == 4 ) {
						print OUTPUT "replace 0 with $mc_rfblock $xcoord $lvl2 $zcoord $mc_hscale 3 $mc_hscale\n";
						print OUTPUT "replace $mc_rfblock with 0 $xibox $lvl2 $zibox $boxsize 2 $boxsize\n";
						print OUTPUT "import $mc_schemroot/misc/spawn-spider.schematic $xctr $lvl1 $zctr\n";
					    }
				        } elsif ( $fflag_b10 ) {
				        } elsif ( $mc_rfblock ) {
					    # generic layout used if floor effect flag bit 6 is not set.
					    print OUTPUT "replace 0 with $mc_rfblock $xcoord $flevel $zcoord $mc_hscale $cnvlvl $mc_hscale\n" if $cnvlvl;
					    print OUTPUT "import $feffectset$randstr.w$width.l1.$hseg.schematic $xstart $schlevel $zstart noair\n";
				        } else {
					    if ($feffectlvl&1) {
					    	print OUTPUT "import $feffectset$randstr.wt$wallthick.b1.s$hseg.schematic $xstart $lvl1 $zstart noair\n";
					    };
					    if ($feffectlvl&2) {
					    	print OUTPUT "import $feffectset$randstr.wt$wallthick.b2.s$hseg.schematic $xstart $lvl1 $zstart noair\n";
					    };
					    if ($feffectlvl&4) {
					    	print OUTPUT "import $feffectset$randstr.wt$wallthick.b4.s$hseg.schematic $xstart $lvl1 $zstart noair\n";
					    };
				        };
				    } else {
					# check to see if we have to include the area of a removed pillar in the floor effect
					my ( $pillarmatch, $quadmatch ) = ( 0, 0, 0 );
					if ( $pillarflag ) {
					    my ( $X, $Y, $Z, $vheflags, $hclass, $pheight, $opattern, $pfeffecttype, $pfproc, $pfquad );
					    foreach my $pillar ( 1 .. $pillarcount ) {
						$X = $pillarlist[$pillar][0];
						$Y = $pillarlist[$pillar][1];
						$Z = $pillarlist[$pillar][2];
	    					$pfeffecttype = $pillarlist[$pillar][7];
	    					$pfquad = $pillarlist[$pillar][8];
	    					$pfproc = $pillarlist[$pillar][9];
						$pheight = $pillarlist[$pillar][10];

						next if ( $pheight > 1 );
						next if ( $pfeffecttype == -1 );
						next if ( $pfproc & 0x01 );
						for my $quad ( 1, 2, 4, 8 ) {
							next if ( ! ( $pfquad & $quad ));
							$X += 1 if ( $quad == 2 || $quad == 8 );
							$Z += 1 if ( $quad == 4 || $quad == 8 );
							if ( $X == $xinc && $Y == $yinc && $Z == $zinc ) {
								$quadmatch = $quad;
								last;
							};
						};
						next if ( $X != $xinc || $Y != $yinc || $Z != $zinc );
						$pillarmatch = 1;

						# mark this pillar as processed
	    					$pillarlist[$pillar][9] = $pillarlist[$pillar][9] | 0x01;

						last;
					    };
					};

					my $wallthick = ( $hco + $wfs + $wss );
					my $endpos = ( $mc_hscale - $wallthick );
					my $xhall = ( $xcoord + $wallthick );
					my $zhall = ( $zcoord + $wallthick );
					my $xend = ( $xcoord + $endpos );
					my $zend = ( $zcoord + $endpos );
					my $width = ( $mc_hscale - ( $wallthick * 2 ) );
					my $lvl = $feffectlvl;

					if ( $fflag_b6 && $feffectlvl == 4 ) {
					    # insert a spider nest
					    print OUTPUT "replace 0 with $mc_rfblock $xcoord $lvl2 $zcoord $mc_hscale 3 $mc_hscale\n";
					    print OUTPUT "replace $mc_rfblock with 0 $xibox $lvl2 $zibox $boxsize 2 $boxsize\n";
					    print OUTPUT "import $mc_schemroot/misc/spawn-spider.schematic $xctr $lvl1 $zctr\n";
					}

					foreach my $seg ( 0, 1, 2, 4, 8, -1 ) {
					    next if ( $seg > 0 && ( $segment & $seg ));
					    next if ( $seg == -1 && ! $pillarmatch );

					    my $rand = int(rand(16));
					    my ( $xseg, $zseg, $ext, $wd ) = ( $xhall, $zhall, '', $width );

					    $xseg = $xcoord if ( $seg == 1 );
					    $xseg = $xend if ($seg == 2 || $seg == -1 );
					    $zseg = $zcoord if ($seg == 4 );
					    $zseg = $zend if ($seg == 8 || $seg == -1 );
					    if ( $fflag_b9 ) {
					    	$ext = 'w' if ( $seg == 1 );
					    	$ext = 'e' if ( $seg == 2 );
					    	$ext = 'n' if ( $seg == 4 );
					    	$ext = 's' if ( $seg == 8 );
					    } else {
					    	$ext = 'x' if ( $seg == 1 || $seg == 2 );
					    	$ext = 'z' if ( $seg == 4 || $seg == 8 );
					    };

					    if ( $seg == -1 ) {
						$wd = ( $mc_hscale - $width );
						$xseg -= $mc_hscale if ( $quadmatch == 2 || $quadmatch == 8 );
						$zseg -= $mc_hscale if ( $quadmatch == 4 || $quadmatch == 8 );
						print OUTPUT "# pillarfeffect at $xinc $yinc $zinc quad $quadmatch seg $xseg $zseg\n";

						# record the X and Z coordinates of the removed pillar, just in case we need to
						# perform a material conversion
						( $pfxseg, $pfzseg, $pfwidth ) = ( $xseg, $zseg, $width );
					    };

					    if ( $fflag_b6 ) {
						if ( $feffectlvl == 1) {
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b1.$rand.schematic $xseg $lvl1 $zseg noair\n";
						} elsif ( $feffectlvl == 2 ) {
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b2.$rand.schematic $xseg $lvl1 $zseg noair\n";
						} elsif ( $feffectlvl == 3 ) {
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b1.$rand.schematic $xseg $lvl1 $zseg noair\n";
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b2.$rand.schematic $xseg $lvl1 $zseg noair\n";
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b1.$rand.schematic $xseg $lvl2 $zseg noair\n";
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b2.$rand.schematic $xseg $lvl3 $zseg noair\n";
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b4.$rand.schematic $xseg $lvl3 $zseg noair\n";
						};
				    	    } elsif ( $fflag_b10 ) {
					    } elsif ( $mc_hfblock ) {
						print OUTPUT "replace 0 with $mc_hfblock $xcoord $flevel $zcoord $mc_hscale $cnvlvl $mc_hscale\n" if $cnvlvl;
						print OUTPUT "import $feffectset$ext$randstr.w$wd.l1.$rand.schematic $xseg $schlevel $zseg noair\n";
					    } else {
						if ($feffectlvl&1) {
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b1.$xpos$zpos.schematic $xseg $lvl1 $zseg noair\n";
						};
						if ($feffectlvl&2) {
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b2.$xpos$zpos.schematic $xseg $lvl1 $zseg noair\n";
						};
						if ($feffectlvl&4) {
						    print OUTPUT "import $feffectset$ext$randstr.w$wd.b4.$xpos$zpos.schematic $xseg $lvl1 $zseg noair\n";
						};

					    };
					};
				    }
			    };

			    # segmented schematic import for ceiling effects
			    if ( $festep eq "CB1" ) {

				$clevel = ( $ycoord + $yscale - ( $css + $cfs + $vco ) + $fev - $cleveloffset );
				$flevel = ( $ycoord + $fss + $ffs + $vco + $fev );
				my $schlevel = ( $clevel - $ceffectlvl + 1 );
				my $cnvlvl = ( $ceffectlvl - 1 );
				my $lvl1 = $clevel;
				my $lvl2 = $clevel - 1;
				my $lvl3 = $clevel - 2;

				# invert layer levels if ceiling effect flag bit 11 is specified
				if ( $cflag_b11 ) {
					$lvl1 = $clevel;
					$lvl2 = $clevel + 1;
					$lvl3 = $clevel + 2;
				};

				my $xpos = ( $xinc % 4 );
				my $zpos = ( $zinc % 4 );
				my ( $xibox,$zibox,$boxsize ) = ( $xcoord + 1, $zcoord + 1, $mc_hscale - 2 );

				# my $mc_cset = $ceffectclass[$ceffecttype][5];
				# $mc_cset = $ceffectclass[$ceffecttype][6] if ( ! $roomid );
				my $mc_rfblock = $ceffectclass[$ceffecttype][10];
				my $mc_hfblock = $ceffectclass[$ceffecttype][11];
				my $xctr = $xcoord + int( $mc_hscale / 2 );
				my $zctr = $zcoord + int( $mc_hscale / 2 );

				my $randstr = '';
				if ( $ceffectrand ) {
					my $randval = 1 + int( rand( $ceffectrand ) );
					$randstr = ".r$randval";
				}

				if ( $roomid ) {
				    my ( $xstart, $zstart) = ( $xcoord, $zcoord );
				    $xstart += ( $hco + $wfs + $wss ) if ( $segment & 1 );
				    $zstart += ( $hco + $wfs + $wss ) if ( $segment & 4 );
				    my $hseg = ( $segment & 15 );
				    my $wallthick = ( $hco + $wfs + $wss );
				    my $width = ( $mc_hscale - ( $wallthick * 2 ) );

				    if ( $mc_rfblock ) {
					# generic layout used if ceiling effect flag bit 6 is not set.
					print OUTPUT "replace 0 with $mc_rfblock $xcoord $clevel $zcoord $mc_hscale $cnvlvl $mc_hscale\n" if $cnvlvl;
					print OUTPUT "import $ceffectset$randstr.w$width.l1.$hseg.schematic $xstart $schlevel $zstart noair\n";
				    } else {
					if ($ceffectlvl&1) {
					    print OUTPUT "import $ceffectset$randstr.wt$wallthick.b1.s$hseg.schematic $xstart $lvl1 $zstart noair\n";
					};
					if ($ceffectlvl&2) {
					    print OUTPUT "import $ceffectset$randstr.wt$wallthick.b2.s$hseg.schematic $xstart $lvl1 $zstart noair\n";
					};
					if ($ceffectlvl&4) {
					    print OUTPUT "import $ceffectset$randstr.wt$wallthick.b4.s$hseg.schematic $xstart $lvl1 $zstart noair\n";
					};
				    };
				} else {
					# check to see if we have to include the area of a removed pillar in the ceiling effect
					my ( $pillarmatch, $quadmatch ) = ( 0, 0, 0 );
					if ( $pillarflag ) {
					    my ( $X, $Y, $Z, $vheflags, $hclass, $pheight, $opattern, $pceffecttype, $pfproc, $pfquad );
					    foreach my $pillar ( 1 .. $pillarcount ) {
						$X = $pillarlist[$pillar][0];
						$Y = $pillarlist[$pillar][1];
						$Z = $pillarlist[$pillar][2];
	    					$pceffecttype = $pillarlist[$pillar][7];
	    					$pfquad = $pillarlist[$pillar][8];
	    					$pfproc = $pillarlist[$pillar][9];
						$pheight = $pillarlist[$pillar][10];

						# for ceiling effects we are checking against the upper-most pillar cell
						$Y += ( $pheight - 1 );

						next if ( $pheight > 1 );
						next if ( $pceffecttype == -1 );
						next if ( $pfproc & 0x02 );
						for my $quad ( 1, 2, 4, 8 ) {
							next if ( ! ( $pfquad & $quad ));
							$X += 1 if ( $quad == 2 || $quad == 8 );
							$Z += 1 if ( $quad == 4 || $quad == 8 );
							if ( $X == $xinc && $Y == $yinc && $Z == $zinc ) {
								$quadmatch = $quad;
								last;
							};
						};
						next if ( $X != $xinc || $Y != $yinc || $Z != $zinc );
						$pillarmatch = 1;

						# mark this pillar as processed
	    					$pillarlist[$pillar][9] = $pillarlist[$pillar][9] | 0x02;

						last;
					    };
					};

					my $wallthick = ( $hco + $wfs + $wss );
					my $endpos = ( $mc_hscale - $wallthick );
					my $xhall = ( $xcoord + $wallthick );
					my $zhall = ( $zcoord + $wallthick );
					my $xend = ( $xcoord + $endpos );
					my $zend = ( $zcoord + $endpos );
					my $width = ( $mc_hscale - ( $wallthick * 2 ) );
					my $lvl = $ceffectlvl;

					foreach my $seg ( 0, 1, 2, 4, 8, -1 ) {
					    next if ( $seg > 0 && ( $segment & $seg ));
					    next if ( $seg == -1 && ! $pillarmatch );

					    my $rand = int(rand(16));
					    my ( $xseg, $zseg, $ext, $wd ) = ( $xhall, $zhall, '', $width );

					    $xseg = $xcoord if ( $seg == 1 );
					    $xseg = $xend if ($seg == 2 || $seg == -1 );
					    $zseg = $zcoord if ($seg == 4 );
					    $zseg = $zend if ($seg == 8 || $seg == -1 );
					    if ( $cflag_b9 ) {
					    	$ext = 'w' if ( $seg == 1 );
					    	$ext = 'e' if ( $seg == 2 );
					    	$ext = 'n' if ( $seg == 4 );
					    	$ext = 's' if ( $seg == 8 );
					    } else {
					    	$ext = 'x' if ( $seg == 1 || $seg == 2 );
					    	$ext = 'z' if ( $seg == 4 || $seg == 8 );
					    };

					    if ( $seg == -1 ) {
						$wd = ( $mc_hscale - $width );
						$xseg -= $mc_hscale if ( $quadmatch == 2 || $quadmatch == 8 );
						$zseg -= $mc_hscale if ( $quadmatch == 4 || $quadmatch == 8 );
						print OUTPUT "# pillarceffect at $xinc $yinc $zinc quad $quadmatch seg $xseg $zseg\n";

						# record the X and Z coordinates of the removed pillar, just in case we need to
						# perform a material conversion
						( $pfxseg, $pfzseg, $pfwidth ) = ( $xseg, $zseg, $width );
					    };

					    if ( $mc_hfblock ) {
						print OUTPUT "replace 0 with $mc_hfblock $xcoord $clevel $zcoord $mc_hscale $cnvlvl $mc_hscale\n" if $cnvlvl;
						print OUTPUT "import $ceffectset$ext$randstr.w$wd.l1.$rand.schematic $xseg $schlevel $zseg noair\n";
					    } else {
						if ($ceffectlvl&1) {
							print OUTPUT "import $ceffectset$ext$randstr.w$wd.b1.$xpos$zpos.schematic $xseg $lvl1 $zseg noair\n";
						};
						if ($ceffectlvl&2) {
						print OUTPUT "import $ceffectset$ext$randstr.w$wd.b2.$xpos$zpos.schematic $xseg $lvl1 $zseg noair\n";
						};
						if ($ceffectlvl&4) {
						print OUTPUT "import $ceffectset$ext$randstr.w$wd.b4.$xpos$zpos.schematic $xseg $lvl1 $zseg noair\n";
						};
					    };
					};

					# make sure we allow advanced ceiling effects for the particular location
					my ( $valid_b35, $hallspc_b35) = gethallflag( $xinc, $yinc, $zinc, 35 );
					if ( ! $hallspc_b35 ) {
					    #
					    # customizations for ceiling erosion
					    #
					    # if the ceiling effect name is "erosion" and effect level is at least 4, add cribbing.
					    if ( $mc_cset eq "erosion" && $ceffectlvl>=4 ) {

						if ( $floor ) {
						    print OUTPUT "import $fceffectdir/cribbing-w$width-s$hseg.schematic $xcoord $flevel $zcoord noair\n";
						} else {
						    print OUTPUT "import $fceffectdir/cribbing-w$width-s$hseg-nf.schematic $xcoord $ycoord $zcoord noair\n";
						};

						my ( $valid_b20, $hallspc_b20 ) = gethallflag( $xinc, $yinc, $zinc, 20 );
						if ( $pillarmatch && $floor && $hallspc_b20 ) {
							my ( $pxpos, $pzpos ) = ( $xcoord, $zcoord);
							$pxpos -= $mc_hscale if ( $quadmatch == 2 || $quadmatch == 8 );
							$pzpos -= $mc_hscale if ( $quadmatch == 4 || $quadmatch == 8 );
	
							print OUTPUT "import $fceffectdir/cribbing-w$width-p.schematic $pxpos $flevel $pzpos noair\n";
						};
					    };
					};
				};
			    };

			    # single-unit schematic import for floor effects
			    if ( $festep eq "FB2" ) {

				    $flevel = ( $ycoord + $fss + $ffs + $vco + $fev - $fleveloffset );

				    my $randstr = '';
				    if ( $feffectrand ) {
					my $randval = 1 + int( rand( $feffectrand ) );
					$randstr = ".r$randval";
				    }

				    # my $mc_fset = $feffectclass[$feffecttype][5];
				    # $mc_fset = $feffectclass[$feffecttype][6] if ( ! $roomid );

				    my $xpos = ( $xinc % 4 );
				    my $zpos = ( $zinc % 4 );
				    print OUTPUT "import $feffectset$randstr.b1.$xpos$zpos.schematic $xcoord $flevel $zcoord noair\n" if ( $feffectlvl & 1 );
				    print OUTPUT "import $feffectset$randstr.b2.$xpos$zpos.schematic $xcoord $flevel $zcoord noair\n" if ( $feffectlvl & 2 );
				    print OUTPUT "import $feffectset$randstr.b4.$xpos$zpos.schematic $xcoord $flevel $zcoord noair\n" if ( $feffectlvl & 4 );
			    };

			    # single-unit schematic import for ceiling effects
			    if ( $festep eq "CB2" ) {

				$clevel = ( $ycoord + $fss + $ffs + $vco + $fev - $cleveloffset );

				my $randstr = '';
				if ( $ceffectrand ) {
					my $randval = 1 + int( rand( $ceffectrand ) );
					$randstr = ".r$randval";
				}

				# my $mc_cset = $ceffectclass[$ceffecttype][5];
				# $mc_cset = $ceffectclass[$ceffecttype][6] if ( ! $roomid );

				my $xpos = ( $xinc % 4 );
				my $zpos = ( $zinc % 4 );
				print OUTPUT "import $ceffectset$randstr.b1.$xpos$zpos.schematic $xcoord $clevel $zcoord noair\n" if ( $ceffectlvl & 1 );
				print OUTPUT "import $ceffectset$randstr.b2.$xpos$zpos.schematic $xcoord $clevel $zcoord noair\n" if ( $ceffectlvl & 2 );
				print OUTPUT "import $ceffectset$randstr.b4.$xpos$zpos.schematic $xcoord $clevel $zcoord noair\n" if ( $ceffectlvl & 4 );

			    };

			    # random schematic placement for floor effects
			    if ( $festep eq "FB3" ) {

				    $flevel = ( $ycoord + $fss + $ffs + $vco + $fev - $fleveloffset );

				    # my $mc_fset = $feffectclass[$feffecttype][5];
				    # $mc_fset = $feffectclass[$feffecttype][6] if ( ! $roomid );

				    my $mincount = $feffectclass[$feffecttype][14];
				    my $maxcount = $feffectclass[$feffecttype][15];
				    my $mc_hsize = $feffectclass[$feffecttype][16];
				    my $mc_vsize = $feffectclass[$feffecttype][17];

				    my $count = $mincount + int( rand( $maxcount - $mincount + 1 ) );
				    my ( $OK, $xpos, $zpos );

				    # my $wthick = ( $vco + $wfs + $wss );
				    my $wthick = ( $vco + $wfs );
				    foreach my $inst ( 1 .. $count ) {
					foreach my $attempt ( 1 .. 10 ) {

					    # pick a random position for floor effect object
					    $xpos = int( rand( $mc_hscale ) );
					    $zpos = int( rand( $mc_hscale ) );
					    # $xpos = int( rand( $mc_hscale - ( $wthick * 2 ) ) );
					    # $zpos = int( rand( $mc_hscale - ( $wthick * 2 ) ) );
					    $OK = 1;

					    # determine if random position will interfere with walls
					    # $OK = 0 if (($segment & 1) == 1) && ( $xpos < $wthick );
					    # $OK = 0 if (($segment & 2) == 2) && ( $xpos >= $mc_hscale - $wthick );
					    # $OK = 0 if (($segment & 4) == 4) && ( $zpos < $wthick );
					    # $OK = 0 if (($segment & 8) == 8) && ( $zpos >= $mc_hscale - $wthick );

					    # determine if random position will interfere with walls

					    my ( $XB, $ZB ) = ( 0, 0 );
					    my $S1 = ($segment & 1);
					    my $S2 = ($segment & 2);
					    my $S4 = ($segment & 4);
					    my $S8 = ($segment & 8);
					    $XB = -1 if ( $xpos < $wthick );
					    $XB = 1 if ( $xpos >= ($mc_hscale - $wthick ));
					    $ZB = -1 if ( $zpos < $wthick );
					    $ZB = 1 if ( $zpos >= ($mc_hscale - $wthick ));

					    if ( $XB == 0 ) {
						$OK = 0 if ( $ZB < 0 && $S4 == 4 );
						$OK = 0 if ( $ZB > 0 && $S8 == 8 );
					    }
					    if ( $ZB == 0 ) {
						$OK = 0 if ( $XB < 0 && $S1 == 1 );
						$OK = 0 if ( $XB > 0 && $S2 == 2 );
					    }
					    $OK = 0 if ( $XB != 0 && $ZB != 0 );

					    last if $OK;
					};
					next if ! $OK;

					my $randstr = '';
					if ( $feffectrand ) {
					    my $randval = 1 + int( rand( $feffectrand ) );
					    $randstr = ".r$randval";
					}

					my $xloc = $xcoord + $xpos;
					my $zloc = $zcoord + $zpos;
					print OUTPUT "import $feffectset$randstr.schematic $xloc $flevel $zloc\n";
				    };
			    };

			    # random schematic placement for ceiling effects
			    if ( $festep eq "CB3" ) {

				# ceiling schematic is considered full-height, minus any offset specified
				$clevel = ( $ycoord + $cleveloffset );
				# $clevel = ( $ycoord + $fss + $ffs + $vco + $fev - $cleveloffset );

				# my $mc_cset = $ceffectclass[$ceffecttype][5];
				# $mc_cset = $ceffectclass[$ceffecttype][6] if ( ! $roomid );

				my $mincount = $ceffectclass[$ceffecttype][14];
				my $maxcount = $ceffectclass[$ceffecttype][15];
				my $mc_hsize = $ceffectclass[$ceffecttype][16];
				my $mc_vsize = $ceffectclass[$ceffecttype][17];

				my $count = $mincount + int( rand( $maxcount - $mincount + 1 ) );
				my ( $OK, $xpos, $zpos );

				my $wthick = ( $vco + $wfs + $wss );
				# my $wthick = ( $vco + $wfs );
				foreach my $inst ( 1 .. $count ) {
				    foreach my $attempt ( 1 .. 10 ) {

					# pick a random position for floor effect object
					$xpos = int( rand( $mc_hscale ) );
					$zpos = int( rand( $mc_hscale ) );
					# $xpos = int( rand( $mc_hscale - ( $wthick * 2 ) ) );
					# $zpos = int( rand( $mc_hscale - ( $wthick * 2 ) ) );
					$OK = 1;

					# determine if random position will interfere with walls

					my ( $XB, $ZB ) = ( 0, 0 );
					my $S1 = ($segment & 1);
					my $S2 = ($segment & 2);
					my $S4 = ($segment & 4);
					my $S8 = ($segment & 8);
					$XB = -1 if ( $xpos < $wthick );
					$XB = 1 if ( $xpos >= ($mc_hscale - $wthick ));
					$ZB = -1 if ( $zpos < $wthick );
					$ZB = 1 if ( $zpos >= ($mc_hscale - $wthick ));

					if ( $XB == 0 ) {
						$OK = 0 if ( $ZB < 0 && $S4 == 4 );
						$OK = 0 if ( $ZB > 0 && $S8 == 8 );
					}
					if ( $ZB == 0 ) {
						$OK = 0 if ( $XB < 0 && $S1 == 1 );
						$OK = 0 if ( $XB > 0 && $S2 == 2 );
					}
					$OK = 0 if ( $XB != 0 && $ZB != 0 );

					# require X/Z to either be even/even or odd/odd
					$OK = 0 if ((( $xpos ^ $zpos ) & 1 ) == 1 );

					last if $OK;
				    };
				    next if ! $OK;

				    my $randstr = '';
				    if ( $ceffectrand ) {
					my $randval = 1 + int( rand( $ceffectrand ) );
					$randstr = ".r$randval";
				    }

				    my $xloc = $xcoord + $xpos;
				    my $zloc = $zcoord + $zpos;
				    print OUTPUT "import $ceffectset$randstr.schematic $xloc $clevel $zloc noair\n";
				};
			    };

			    # material conversion floor effect flag specified.
			    if ( $festep eq "FB5" || $festep eq "CB5" ) {
				    print OUTPUT "replace 62 with 0 $xcoord $ycoord $zcoord $mc_hscale $yscale $mc_hscale\n";
				    print OUTPUT "replace 62 with 0 $pfxseg $ycoord $pfzseg $pfwidth $yscale $pfwidth\n" if $pfwidth;
			    };

			    if ( $festep eq "XOS" ) {
				my ( $coheight, $cowidth ) = ( 4, 4 );
				my $xstart = $xcoord + floor(( $mc_hscale - $cowidth ) / 2 );
				my $ystart = ( $ycoord + $yscale - $coheight );
				my $zstart = $zcoord + floor(( $mc_hscale - $cowidth ) / 2 );
				print OUTPUT "import $mc_schemroot/$setname/crossover2.schematic $xcoord $ystart $zstart\n" if ( $cellspc == 2 );
				print OUTPUT "import $mc_schemroot/$setname/crossover3.schematic $xstart $ystart $zcoord\n" if ( $cellspc == 3 );
			    };
			};
		};
	    };
	};
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# printmceroomtemp - print mce room template for specified room number

sub printmceroomtemp {
	my $room = $_[0];

	open(OUTPUT, ">$fileprefix-room$room.mce");

	print OUTPUT "dimension $mc_dim_rtemplate\n";
	print OUTPUT "log $mc_log_rtemplate\n";

	my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $room );

	my $xsize = ( $xs * $mc_hscale );
	my $ysize = ( $ys * $mc_vscale );
	my $zsize = ( $zs * $mc_hscale );

	my $xgsize = $xsize + 4;
	my $ygsize = $ysize + 2;
	my $zgsize = $zsize + 4;

	my $ystart = $mc_yrtoffset + $ysize;

	my $xosize = $xsize + 2;
	my $zosize = $zsize + 2;

	my $xostart = $mc_xrtoffset + 1;
	my $yostart = $ystart + 1;
	my $zostart = $mc_zrtoffset + 1;

	# create glass block to build template out of.
	print OUTPUT "fill 20 $mc_xrtoffset $mc_yrtoffset $mc_zrtoffset $xgsize $ygsize $zgsize\n";
	print OUTPUT "fill 0 $xostart $yostart $zostart $xosize 2 $zosize\n";

	my $xfc=( $xc+$xs-1 );
	my $yfc=( $yc+$ys-1 );
	my $zfc=( $zc+$zs-1 );

	foreach my $xinc (1 .. $xs) {
	    my $xcoord = (( $mc_hscale * ($xinc - 1 ) ) + $mc_xrtoffset + 2);
	    foreach my $zinc (1 .. $zs) {
		my $zcoord = (( $mc_hscale * ($zinc - 1) ) + $mc_zrtoffset + 2);
		foreach my $yinc (0 .. $ys-1) {
			my $ycoord = ( $ystart - ( $mc_vscale * ( $yinc + 1 )) + 1 );
			my $yfcoord = ( $ycoord + $mc_vscale - 1 );
			my $xocoord = $xcoord + 1;
			my $yocoord = $ycoord + 1;
			my $zocoord = $zcoord + 1;

			next if ( $room != getroomid( $xc+$xinc-1, $yc+$yinc, $zc+$zinc-1 ));

			my $segid = 0;
			$segid += 1 if ( $room != getroomid( $xc+$xinc-1-1, $yc+$yinc, $zc+$zinc-1 ));
			$segid += 2 if ( $room != getroomid( $xc+$xinc-1+1, $yc+$yinc, $zc+$zinc-1 ));
			$segid += 4 if ( $room != getroomid( $xc+$xinc-1, $yc+$yinc, $zc+$zinc-1-1 ));
			$segid += 8 if ( $room != getroomid( $xc+$xinc-1, $yc+$yinc, $zc+$zinc-1+1 ));
			my $isegid = 15 - $segid;

			print OUTPUT "import $mc_schemroot/$defaultset/vi$segid.$isegid.schematic $xcoord $ycoord $zcoord\n";
			if ( $room != getroomid( $xc+$xinc-1, $yc+$yinc+1, $zc+$zinc-1 )) {
				print OUTPUT "replace 1 with 22 $xcoord $ycoord $zcoord 12 1 12\n";
			};
			if ( $room != getroomid( $xc+$xinc-1, $yc+$yinc-1, $zc+$zinc-1 )) {
				print OUTPUT "replace 1 with 22 $xcoord $yfcoord $zcoord 12 1 12\n";
			};

			# print OUTPUT "fill 1 $xcoord $ycoord $zcoord 12 12 12\n";
			# print OUTPUT "fill 0 $xocoord $yocoord $zocoord 10 10 10\n";
		}
	    }
	};
	close(OUTPUT);
};

#------------------------------------------------------------------------------
# parsesetroomopt - parse argument string for placeroom

sub parsesetroomopt {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $X, $Y, $Z, $XS, $YS, $ZS, $roomspc ) = @args;

	$X = ( $xmazesize + $X - $XS ) if ( "$X" eq "-0" || $X < 0 );
	$Y = ( $ymazesize + $Y - $YS ) if ( "$Y" eq "-0" || $Y < 0 );
	$Z = ( $zmazesize + $Z - $ZS ) if ( "$Z" eq "-0" || $Z < 0 );

	die if ( $X < 0 || $X > $xmazesize );
	die if ( $Y < 0 || $Y > $ymazesize );
	die if ( $Z < 0 || $Z > $zmazesize );
	die if ( ($X+$XS) <= 0 || ($X+$XS) > $xmazesize );
	die if ( ($Y+$YS) <= 0 || ($Y+$YS) > $ymazesize );
	die if ( ($Z+$ZS) <= 0 || ($Z+$ZS) > $zmazesize );
	die if ( $roomspc < 0 || $roomspc > 2**8 );

	$setroomcount += 1;
	$setrooms[ $setroomcount ][0] = $X;
	$setrooms[ $setroomcount ][1] = $Y;
	$setrooms[ $setroomcount ][2] = $Z;
	$setrooms[ $setroomcount ][3] = $XS;
	$setrooms[ $setroomcount ][4] = $YS;
	$setrooms[ $setroomcount ][5] = $ZS;
	$setrooms[ $setroomcount ][6] = $roomspc;
}


#------------------------------------------------------------------------------
# parsenoroomopt - parse argument string for noroomblock

sub parsenoroomopt {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $X, $Y, $Z, $XS, $YS, $ZS ) = @args;
	die if ( $X < 0 || $X > $xmazesize );
	die if ( $Y < 0 || $Y > $ymazesize );
	die if ( $Z < 0 || $Z > $zmazesize );
	die if ( ($X+$XS) <= 0 || ($X+$XS) > $xmazesize );
	die if ( ($Y+$YS) <= 0 || ($Y+$YS) > $ymazesize );
	die if ( ($Z+$ZS) <= 0 || ($Z+$ZS) > $zmazesize );

	$noroomcount += 1;
	$norooms[ $noroomcount ][0] = $X;
	$norooms[ $noroomcount ][1] = $Y;
	$norooms[ $noroomcount ][2] = $Z;
	$norooms[ $noroomcount ][3] = $XS;
	$norooms[ $noroomcount ][4] = $YS;
	$norooms[ $noroomcount ][5] = $ZS;
}

#------------------------------------------------------------------------------
# parselevelclassopt - parse argument string for levelclass

sub parselevelclassopt {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $Y, $levelclassnum ) = @args;

	return 1 if ( $Y < 0 || $Y > 255 );

	$levelclassnum = 0 if (! $levelclassnum);

	$levelinfo[$Y][0] = $levelclassnum;

	my $ylevelscale = $levelclass[$levelclassnum][ 2 ];
	$levelinfo[$Y][1] = $ylevelscale;
};

#------------------------------------------------------------------------------
# parsesetlevelopt - parse argument string for placelevel

sub parsesetlevelopt {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $Y, $roomspc ) = @args;
	die if ( $Y < 0 || $Y > $ymazesize );
	die if ( $roomspc < 0 || $roomspc > 2**8 );

	# get the sizing information for the room class
	my ( $xmns, $ymns, $zmns, $xmxs, $ymxs, $zmxs ) = getroomclasssizes( $roomspc );

	# determine the Y placement based on the stored room class size and room special b23/b26 values.
	my ( $valid_b23, $roomspc_b23) = getroomspcflag( $roomspc, 23 );
	my ( $valid_b26, $roomspc_b26) = getroomspcflag( $roomspc, 26 );
	my $level = (($Y - $ymns) +1);
	$level += 1 if ($roomspc_b23 || $roomspc_b26);

	$setroomcount += 1;
	$setrooms[ $setroomcount ][0] = 0;
	$setrooms[ $setroomcount ][1] = $level;
	$setrooms[ $setroomcount ][2] = 0;
	$setrooms[ $setroomcount ][3] = $xmazesize;
	$setrooms[ $setroomcount ][4] = $ymns;
	$setrooms[ $setroomcount ][5] = $zmazesize;
	$setrooms[ $setroomcount ][6] = $roomspc;
}

#------------------------------------------------------------------------------
# parsebmroomopt - parse argument string for bitmaproom

sub parsebmroomopt {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $X, $Y, $Z, $bmnum, $roomclass ) = @args;
	die if ( $X < 0 || $X > $xmazesize );
	die if ( $Y < 0 || $Y > $ymazesize );
	die if ( $Z < 0 || $Z > $zmazesize );
	$roomclass = "" if ( !$roomclass );

	my $swap = (($bmxswap&1) | (($bmyswap&1)<<1) | (($bmzswap&1)<<2) | (($bmhrotate&3)<<3));

	$bmroomcount += 1;
	$bmrooms[ $bmroomcount ][0] = $X;
	$bmrooms[ $bmroomcount ][1] = $Y;
	$bmrooms[ $bmroomcount ][2] = $Z;
	$bmrooms[ $bmroomcount ][3] = $bmnum;
	$bmrooms[ $bmroomcount ][4] = $swap;
	$bmrooms[ $bmroomcount ][5] = $roomclass;
}

#------------------------------------------------------------------------------
# parsesizeopt - parse XYZ dimensions or position from a text entry

sub parsesizeopt {
	my $opt_val = $_[0];
	my @args = split(',', $opt_val );

	my ( $X, $Y, $Z ) = @args;
	die if ( $X < 0 || $X > $xmazesize );
	die if ( $Y < 0 || $Y > $ymazesize );
	die if ( $Z < 0 || $Z > $zmazesize );

	return( $X, $Y, $Z );
}

#------------------------------------------------------------------------------
# stagebmroom - load and translate bitmap room into staging array

sub stagebmroom {
	my ( $bmnum, $xswap, $yswap, $zswap, $hrotate ) = @_;
	my ( $success, $subrooms ) = ( 1, -1 );
	my ( $xsize, $ysize, $zsize ) = parsesizeopt( $roombitmaps[$bmnum][0][2] );
	my $bmflags = $roombitmaps[$bmnum][0][0];

	my $drbit = ( $bmflags & 0x00000002 );
	my $dgbit = ( $bmflags & 0x00000004 );
	my $vhebit = ( $bmflags & 0x00000008 );
	my $ptbit = ( $bmflags & 0x00000010 );

	# set the translated size to be the same as the original bitmap size
	my ( $transxsize, $transysize, $transzsize ) = ( $xsize, $ysize, $zsize );

	# swap X and Z dimensions if we are going to do a 90 or 270 degree rotation
	( $transxsize, $transzsize ) = ( $transzsize, $transxsize ) if ( $hrotate == 1 || $hrotate == 3 );

	# clear the staging grid
	for my $xinc ( 0 .. ( $transxsize - 1 )) {
	    for my $yinc ( 0 .. ( $transysize - 1 )) {
		for my $zinc ( 0 .. ( $transzsize - 1 )) {
			$bmstagegrid[$xinc][$yinc][$zinc] = 255;
		};
	    };
	};

	my $last = 0;
	do {
		# get the character identifier for the next subroom
		my $subchar = substr( $roombitmaps[$bmnum][0][3], $subrooms + 1, 1 );

		# abort adding subrooms if no more characters remain
		$last = 1 if ( "X$subchar" eq "X" );

		# scan the bitmap for the subroom ID char.
		$subrooms += 1 if ! $last;
		for my $zinc ( 0 .. ( $zsize - 1 )) {
		    last if $last;
		    my $bmline = $roombitmaps[$bmnum][2][$zinc];
		    my $drline = $roombitmaps[$bmnum][3][$zinc] if $drbit;
		    my $dgline = $roombitmaps[$bmnum][4][$zinc] if $dgbit;
		    my $vfline = $roombitmaps[$bmnum][5][$zinc] if $vhebit;
		    my $ptline = $roombitmaps[$bmnum][6][$zinc] if $ptbit;
		    for my $yinc ( 0 .. ( $ysize - 1 )) {
	
			my @ybgroups = split( ' ', $bmline );
			my $ybgroup = $ybgroups[$yinc];
			my @ydgroups = split( ' ', $drline ) if $drbit;
			my $ydgroup = $ydgroups[$yinc] if $drbit;
			my @yggroups = split( ' ', $dgline ) if $dgbit;
			my $yggroup = $yggroups[$yinc] if $dgbit;
			my @yvgroups = split( ' ', $vfline ) if $vhebit;
			my $yvgroup = $yvgroups[$yinc] if $vhebit;
			my @ypgroups = split( ' ', $ptline ) if $ptbit;
			my $ypgroup = $ypgroups[$yinc] if $ptbit;
	
			for my $xinc ( 0 .. ( $xsize - 1 )) {
				my $xchar = substr( $ybgroup, $xinc, 1 );
				next if ( $xchar ne $subchar );
				my $dchar = substr( $ydgroup, $xinc, 1 ) if $drbit;
				my $gchar = substr( $yggroup, $xinc, 1 ) if $dgbit;
				my $vchar = substr( $yvgroup, $xinc, 1 ) if $vhebit;
				my $pchar = substr( $ypgroup, $xinc, 1 ) if $ptbit;
				
				# perform any requested coordinate translations
				my ( $xloc, $yloc, $zloc ) = ( $xinc, $yinc, $zinc );

				$xloc = $xsize - $xinc - 1 if ( $xswap );
				$yloc = $ysize - $yinc - 1 if ( $yswap );
				$zloc = $zsize - $zinc - 1 if ( $zswap );

				if ( $hrotate == 1 ) {
					( $zloc, $xloc ) = ( $xloc, $transxsize - $zloc - 1 );
				} elsif ( $hrotate == 2 ) {
					( $zloc, $xloc ) = ( $transzsize - $zloc - 1, $transxsize - $xloc - 1 );
				} elsif ( $hrotate == 3 ) {
					( $zloc, $xloc ) = ( $transzsize - $xloc - 1, $zloc );
				};

				my $door = 0;

				if ( $drbit ) {
					$door = ( $door | 0x0100 ) if ( $dchar eq "f" );
					$door = ( $door | 0x0200 ) if ( $dchar eq "p" );
					$door = ( $door | 0x1000 ) if ( $dchar eq "w" );
					$door = ( $door | 0x2000 ) if ( $dchar eq "e" );
					$door = ( $door | 0x3000 ) if ( $dchar eq "n" );
					$door = ( $door | 0x4000 ) if ( $dchar eq "s" );
					$door = ( $door | 0x5000 ) if ( $dchar eq "u" );
					$door = ( $door | 0x6000 ) if ( $dchar eq "d" );
				};

				my $dgroup = 0;

				if ( $dgbit ) {
					$dgroup = ( $dgroup | 0x10000 ) if ( $gchar eq "1" );
					$dgroup = ( $dgroup | 0x20000 ) if ( $gchar eq "2" );
					$dgroup = ( $dgroup | 0x30000 ) if ( $gchar eq "3" );
					$dgroup = ( $dgroup | 0x40000 ) if ( $gchar eq "4" );
					$dgroup = ( $dgroup | 0x50000 ) if ( $gchar eq "5" );
					$dgroup = ( $dgroup | 0x60000 ) if ( $gchar eq "6" );
					$dgroup = ( $dgroup | 0x70000 ) if ( $gchar eq "7" );
					$dgroup = ( $dgroup | 0x80000 ) if ( $gchar eq "8" );
					$dgroup = ( $dgroup | 0x90000 ) if ( $gchar eq "9" );
					$dgroup = ( $dgroup | 0xa0000 ) if ( $gchar eq "a" );
					$dgroup = ( $dgroup | 0xb0000 ) if ( $gchar eq "b" );
					$dgroup = ( $dgroup | 0xc0000 ) if ( $gchar eq "c" );
					$dgroup = ( $dgroup | 0xd0000 ) if ( $gchar eq "d" );
					$dgroup = ( $dgroup | 0xe0000 ) if ( $gchar eq "e" );
					$dgroup = ( $dgroup | 0xf0000 ) if ( $gchar eq "f" );
				};

				my $vheval = 0;
			
				if ( $vhebit ) {
					$vheval = ( $vheval | 0x100000 ) if ( $vchar eq "1" );
					$vheval = ( $vheval | 0x200000 ) if ( $vchar eq "2" );
					$vheval = ( $vheval | 0x300000 ) if ( $vchar eq "3" );
					$vheval = ( $vheval | 0x400000 ) if ( $vchar eq "4" );
					$vheval = ( $vheval | 0x500000 ) if ( $vchar eq "5" );
					$vheval = ( $vheval | 0x600000 ) if ( $vchar eq "6" );
					$vheval = ( $vheval | 0x700000 ) if ( $vchar eq "7" );
				};

				if ( $ptbit ) {
					$door = ( $door | 0x0400 ) if ( $pchar eq "p" );
				};
				
				$bmstagegrid[$xloc][$yloc][$zloc] = ( $subrooms & 0xff ) | ( $door & 0xff00 ) | ( $dgroup & 0xf0000 ) |
					( $vheval & 0xf00000 );
			};
		    };
		};
	} while ( $last == 0 );

	print "stagebmroom: source $xsize $ysize $zsize translated to $transxsize $transysize $transzsize\n" if ( $debug3 );

	return ( $success, $transxsize, $transysize, $transzsize, $subrooms );
};

#------------------------------------------------------------------------------
# parsedsmaterials - parse dataset material list

sub parsedsmaterials {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	for my $arg ( @args ) {
		my ( $blockid, $data ) = split( ':', $arg );
		die "parsedsmaterials: invalid blockid $blockid" if ( $blockid < 0 || $blockid > 255 );
		$data = 0 if ( ! $data );
		die "parsedsmaterials: invalid dataid $data" if ( $data < 0 || $data > 255 );
	}

	my ( $fft,$wft,$cft,$fst,$wst,$cst,$cmt,$omt,$pmt ) = @args;

	return( $fft,$wft,$cft,$fst,$wst,$cst,$cmt,$omt,$pmt );
}
#------------------------------------------------------------------------------
# parsedsthickness - parse dataset thickness list

sub parsedsthickness {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $ffs,$wfs,$cfs,$fss,$wss,$css,$hco,$vco,$swl,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff ) = @args;
	die "ffs $ffs" if ( $ffs < 0 || $ffs > 8 );
	die "wfs $wfs" if ( $wfs < 0 || $wfs > 8 );
	die "cfs $cfs" if ( $cfs < 0 || $cfs > 8 );
	die "fss $fss" if ( $fss < 0 || $fss > 8 );
	die "wss $wss" if ( $wss < 0 || $wss > 8 );
	die "css $css" if ( $css < 0 || $css > 8 );
	die "hco $hco" if ( $hco < 0 || $hco > 8 );
	die "vco $vco" if ( $vco < 0 || $vco > 8 );
	die "swl $swl" if ( $swl < 0 || $swl > 8 );
	die "evt $evt" if ( $swl < 0 || $swl > 8 );
	die "tfa $tfa" if ( $tfa < 0 || $tfa > 8 );
	die "bfa $bfa" if ( $bfa < 0 || $bfa > 8 );
	die "tsa $tsa" if ( $tsa < 0 || $tsa > 8 );
	die "bsa $bsa" if ( $bsa < 0 || $bsa > 8 );
	die "mfa $mfa" if ( $mfa < 0 || $mfa > 8 );
	die "msa $msa" if ( $msa < 0 || $msa > 8 );
	die "hcs $hcs" if ( $hcs < 0 || $hcs > 8 );
	die "hcf $hcf" if ( $hcf < 0 || $hcf > 8 );
	die "hfs $hfs" if ( $hfs < 0 || $hfs > 8 );
	die "hff $hff" if ( $hff < 0 || $hff > 8 );
	$ffs = 0 if ! $ffs;
	$wfs = 0 if ! $wfs;
	$cfs = 0 if ! $cfs;
	$fss = 0 if ! $fss;
	$wss = 0 if ! $wss;
	$css = 0 if ! $css;
	$hco = 0 if ! $hco;
	$vco = 0 if ! $vco;
	$swl = 0 if ! $swl;
	$evt = 0 if ! $evt;
	$tfa = 0 if ! $tfa;
	$bfa = 0 if ! $bfa;
	$tsa = 0 if ! $tsa;
	$bsa = 0 if ! $bsa;
	$mfa = 0 if ! $mfa;
	$msa = 0 if ! $msa;
	$hcs = 0 if ! $hcs;
	$hcf = 0 if ! $hcf;
	$hfs = 0 if ! $hfs;
	$hff = 0 if ! $hff;

	return( $ffs,$wfs,$cfs,$fss,$wss,$css,$hco,$vco,$swl,$evt,$tfa,$bfa,$tsa,$bsa,$mfa,$msa,$hcs,$hcf,$hfs,$hff );
}

#------------------------------------------------------------------------------
# parsedsoffset - parse dataset offset list

sub parsedsoffset {
	my ( $opt_name, $opt_val ) = @_;

	my @args = split(',', $opt_val );

	my ( $xoff,$yoff,$zoff,$xover,$yover,$zover ) = @args;
	$xoff = 0 if ! $xoff;
	$yoff = 0 if ! $yoff;
	$zoff = 0 if ! $zoff;
	$xover = 0 if ! $xover;
	$yover = 0 if ! $yover;
	$zover = 0 if ! $zover;

	return( $xoff,$yoff,$zoff,$xover,$yover,$zover );
}

#------------------------------------------------------------------------------
# updateroomdist - update zero distance fields in a room

sub updateroomdist {
	my ( $room, $dist, $thread ) = @_;
	my ($xc, $yc, $zc, $xs, $ys, $zs) = getroompos( $room );

	print "updateroomdist room $room dist $dist\n" if $debug2;

	# scan the room for zero-value cells
	foreach my $yinc ($yc .. $yc+$ys-1) {
            foreach my $xinc ($xc .. $xc+$xs-1) {
        	foreach my $zinc ($zc .. $zc+$zs-1) {
		    next if ( getroomid( $xinc, $yinc, $zinc ) != $room );
		    # setcelldist ( $xinc, $yinc, $zinc, $dist, $thread) if ! getcelldist( $xinc, $yinc, $zinc );
		    setcelldist ( $xinc, $yinc, $zinc, $dist, $thread);
		}
	    }
	}
};

#------------------------------------------------------------------------------
# convstdir - convert rotational directions into standard directions for vhe stairs

sub convstdir {
	my ( $stdir, $rdir, $rcnt ) = @_;

	# determine lower placement direction for stair
	my $lrdir = (( $stdir + $rdir ) & 0x03 );
	my $ldir = 0;
	$ldir = 1 if ( $lrdir == 0 );
	$ldir = 2 if ( $lrdir == 2 );
	$ldir = 3 if ( $lrdir == 1 );
	$ldir = 4 if ( $lrdir == 3 );

	# determine upper placement direction for stair
	my $urdir = (( $lrdir + $rcnt + 1 ) & 0x03 );
	my $udir = 0;
	$udir = 1 if ( $urdir == 0 );
	$udir = 2 if ( $urdir == 2 );
	$udir = 3 if ( $urdir == 1 );
	$udir = 4 if ( $urdir == 3 );

	my $ldmask = $ldir;
	$ldmask = 4 if ($ldir == 3 );
	$ldmask = 8 if ($ldir == 4 );

	my $udmask = $udir;
	$udmask = 4 if ($udir == 3 );
	$udmask = 8 if ($udir == 4 );

	print "convstdir input stdir $stdir rdir $rdir rcnt $rcnt output udir $udir ldir $ldir udmask $udmask ldmask $ldmask\n" if ( $debug2 );

	return( $udir, $ldir, $udmask, $ldmask );
};

#------------------------------------------------------------------------------
# lockroom - enable cell use flags for all cells in the room

sub lockroom {
	my ( $room, $dist, $thread ) = @_;
	my ($xc, $yc, $zc, $xs, $ys, $zs) = getroompos( $room );

	print "lockroom room $room dist $dist\n" if $debug2;

	# build the room in the array
	foreach my $yinc ($yc .. $yc+$ys-1) {
            foreach my $xinc ($xc .. $xc+$xs-1) {
        	foreach my $zinc ($zc .. $zc+$zs-1) {
		    next if ( getroomid( $xinc, $yinc, $zinc ) != $room );
		    setuseflag( $xinc, $yinc, $zinc);
		    setcelldist ( $xinc, $yinc, $zinc, $dist, $thread);
		}
	    }
	}
};

#------------------------------------------------------------------------------
# addthread - add a new concurrent path to the thread list

sub addthread {
	my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST ) = @_;

	return ( 0 ) if $totalthreads > 32;

	$totalthreads += 1;

	my $endthread = 0;

	# negative coordinates are relative to the opposite side
	# if "-0" is specified as a coordinate, it must be in quotes
	$X = ( $xmazesize + $X - 1 ) if ( "$X" eq "-0" || $X < 0 );
	$Y = ( $ymazesize + $Y - 1 ) if ( "$Y" eq "-0" || $Y < 0 );
	$Z = ( $zmazesize + $Z - 1 ) if ( "$Z" eq "-0" || $Z < 0 );
	$STX = ( $xmazesize + $STX - 1 ) if ( "$STX" eq "-0" || $STX < 0 );
	$STY = ( $ymazesize + $STY - 1 ) if ( "$STY" eq "-0" || $STY < 0 );
	$STZ = ( $zmazesize + $STZ - 1 ) if ( "$STZ" eq "-0" || $STZ < 0 );

	# move thread to the room of the same number if we request it.
	if ( $startinroom && $totalrooms >= $totalthreads ) {
		my ( $xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze ) = getroompos( $totalthreads );
		my $cb1valid = checkbounds( $xc, $yc, $zc );
		my $cb2valid = checkbounds( $xc+$xs, $yc+$ys, $zc+$zs );
		if ( $cb1valid && $cb2valid ) {
 			$X= ( $xc + int( $xs/2 ));
			$Y=$yc+$ys-1;
			$Z=( $zc + int( $zs/2 ));
 			$STX=$X;
			$STY=$Y;
			$STZ=$Z;
		};
	};

	$threadinfo[$totalthreads][ 0] = $name;
	$threadinfo[$totalthreads][ 1] = $X;
	$threadinfo[$totalthreads][ 2] = $Y;
	$threadinfo[$totalthreads][ 3] = $Z;
	$threadinfo[$totalthreads][ 4] = $dist;
	$threadinfo[$totalthreads][ 5] = $STX;
	$threadinfo[$totalthreads][ 6] = $STY;
	$threadinfo[$totalthreads][ 7] = $STZ;
	$threadinfo[$totalthreads][ 8] = $HDX;
	$threadinfo[$totalthreads][ 9] = $HDY;
	$threadinfo[$totalthreads][10] = $HDZ;
	$threadinfo[$totalthreads][11] = $HDST;
	$threadinfo[$totalthreads][12] = $endthread;
	$threadinfo[$totalthreads][13] = $STX;
	$threadinfo[$totalthreads][14] = $STY;
	$threadinfo[$totalthreads][15] = $STZ;
	$threadinfo[$totalthreads][16] = 0;

	# mark cell as a maze beginning.
	setcellspc( $X, $Y, $Z, 1 );

	# lookup and add initial hallway identifier and style
	my $levelclass = $levelinfo[$Y][0];
	my $sthallclass = $levelclass[$levelclass][10];
	$sthallclass = 0 if ! $sthallclass;
	my $hallid = addtohalllist( $sthallclass, $X, $Y, $Z );
	sethallid( $X, $Y, $Z, $hallid, 0, 0 );
	my $hallgstyle = genhallstyle( $X, $Y, $Z, 0, 0 );
	sethallgstyle( $X, $Y, $Z, $hallgstyle );

	print "thread added at $X $Y $Z, hall class $sthallclass\n" if ( $debug );
};

#------------------------------------------------------------------------------
# setthreadhighdist - update thread high-distance coordinates and distance

sub setthreadhighdist {
	my ( $thread, $X, $Y, $Z, $dist ) = @_;

	$threadinfo[$thread][8] = $X;
	$threadinfo[$thread][9] = $Y;
	$threadinfo[$thread][10] = $Z;
	$threadinfo[$thread][11] = $dist;
};

#------------------------------------------------------------------------------
# setthread - update thread coordinates and distance

sub setthread {
	my ( $thread, $X, $Y, $Z, $dist, $end, $dend ) = @_;

	$threadinfo[$thread][1] = $X;
	$threadinfo[$thread][2] = $Y;
	$threadinfo[$thread][3] = $Z;
	$threadinfo[$thread][4] = $dist;
	$threadinfo[$thread][12] = $end;
	$dend = 0 if ( ! $dend );
	print "thread end for $thread\n" if $dend;

	if ( ! $threadinfo[$thread][16] ) {
		$threadinfo[$thread][16] = $dend;
	};
};

#------------------------------------------------------------------------------
# getthreadhighdist - get thread high-distance coordinates and distance

sub getthreadhighdist {
	my $thread = $_[0];

	my $X		= $threadinfo[$thread][8];
	my $Y		= $threadinfo[$thread][9];
	my $Z		= $threadinfo[$thread][10];
	my $dist	= $threadinfo[$thread][11];

	$X = 0 if ! $X;
	$Y = 0 if ! $Y;
	$Z = 0 if ! $Z;
	$dist = 0 if ! $dist;

	return( $dist, $X, $Y, $Z );
};

#------------------------------------------------------------------------------
# getthread - get thread coordinates and distance

sub getthread {
	my $thread = $_[0];

	my $X		= $threadinfo[$thread][1];
	my $Y		= $threadinfo[$thread][2];
	my $Z		= $threadinfo[$thread][3];
	my $dist	= $threadinfo[$thread][4];
	my $end		= $threadinfo[$thread][12];
	my $dend	= $threadinfo[$thread][16];

	$X = 0 if ! $X;
	$Y = 0 if ! $Y;
	$Z = 0 if ! $Z;
	$dist = 0 if ! $dist;
	$end = 0 if ! $end;

	return( $X, $Y, $Z, $dist, $end, $dend );
};
#------------------------------------------------------------------------------
# getthreadinfo - get thread information for a particular path

sub getthreadinfo {
	my $thread = $_[0];

	my $name	= $threadinfo[$thread][ 0];
	my $X		= $threadinfo[$thread][ 1];
	my $Y		= $threadinfo[$thread][ 2];
	my $Z		= $threadinfo[$thread][ 3];
	my $dist	= $threadinfo[$thread][ 4];
	my $STX		= $threadinfo[$thread][ 5];
	my $STY		= $threadinfo[$thread][ 6];
	my $STZ		= $threadinfo[$thread][ 7];
	my $HDX		= $threadinfo[$thread][ 8];
	my $HDY		= $threadinfo[$thread][ 9];
	my $HDZ		= $threadinfo[$thread][10];
	my $HDST	= $threadinfo[$thread][11];
	my $END		= $threadinfo[$thread][12];
	my $OSTX	= $threadinfo[$thread][13];
	my $OSTY	= $threadinfo[$thread][14];
	my $OSTZ	= $threadinfo[$thread][15];
	my $DEND	= $threadinfo[$thread][16];

	return( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND );
};

#------------------------------------------------------------------------------
# setasciipoint - set character/color on ascii cell

sub setasciipoint {
	my ( $X, $Y, $Z, $char, $color, $checkpoint ) = @_;
	$checkpoint="none" if (! $checkpoint);
	print "setasciipoint $checkpoint setting char $char color $color at $X $Y $Z\n" if $debug3;

	$asciigrid[$X][$Y][$Z] = $char;
	$colorgrid[$X][$Y][$Z] = $color;
}

#------------------------------------------------------------------------------
# buildasciigrid - build ascii maze map

sub buildasciigrid {
	# prefill ascii maze with hash characters
	foreach my $yinc (0..$ymazesize) {
	  foreach my $xinc (0..($xmazesize * 2 )) {
	    foreach my $zinc (0..($zmazesize * 2 )) {
		setasciipoint( $xinc, $yinc, $zinc, "#", 7, 1);
	    }
	  }
	}

	foreach my $pass ( 1..3 ) {
	    foreach my $yinc (0 .. $ymazesize-1) {
        	foreach my $xinc (0 .. $xmazesize-1) {
        	    foreach my $zinc (0 .. $zmazesize-1) {
			print "buildascii pass $pass for $xinc $yinc $zinc starting\n" if $debug3;
			my $ax = ( $xinc * 2) + 1;
			my $ay = $yinc;
			my $az = ( $zinc * 2) + 1;

			# get cell attributes
			my ( $valid, $celluse, $paths, $backdir, $segment, $roomid, $dist, $feffectlvl, $feffecttype, $ceffectlvl, $ceffecttype ) =
				getcellinfo( $xinc, $yinc, $zinc );

			# skip this cell if it is out-of-bounds.
			next if (! $valid);

			# skip this cell if it is marked as unused
			next if (! $celluse);

			# get cell special flags
			my $cellspc = getcellspc( $xinc, $yinc, $zinc );

			# skip updating room cells in this pass unless they are passthru cells
			next if ( $roomid && ( $cellspc < 32 || $cellspc > 39 ) );

			# add the floor bit if we are dealing with a passthru cell
			if ( $cellspc >= 32 && $cellspc <= 39 ) {
				$segment = ( $segment | 32 );
				$paths = ( $paths | 48 );
			};

			# get hall ID and class
			my $hall = gethallid( $xinc, $yinc, $zinc );
			my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);

			# get unmined flag
			my $umflag = getumflag( $xinc, $yinc, $zinc );

			if ( $pass == 2 ) {
			    if ( $cellspc == 2 ) {
				setasciipoint( $ax-1, $ay, $az, '#', 7, 6);
				setasciipoint( $ax+1, $ay, $az, '#', 7, 6);
			    } elsif ( $cellspc == 3 ) {
				setasciipoint( $ax, $ay, $az-1, '#', 7, 6);
				setasciipoint( $ax, $ay, $az+1, '#', 7, 6);
			    };
			};
				
			# get vertical-hallway-expansion flags
			my $vheflags = getvhe( $xinc, $yinc, $zinc );

			# get diagonal path flag
			my $diagpath = getdiagpath( $xinc, $yinc, $zinc );

			foreach my $direction ( 0..4 ) {
				last if ( $pass > 2 );
				# get the wall flag for the direction we are examining
				my $wall = 0;
				$wall = ($paths >> ($direction - 1) & 1 ) if ($direction != 0);

				# skip this direction if the wall is not open.
				next if $wall;

				my ($xinc2, $yinc2, $zinc2) = ($xinc, $yinc, $zinc);
				$xinc2 -= 1 if ( $direction == 1 );
				$xinc2 += 1 if ( $direction == 2 );
				$zinc2 -= 1 if ( $direction == 3 );
				$zinc2 += 1 if ( $direction == 4 );

				my ($ax2, $ay2, $az2) = ( $ax, $ay, $az);
				$ax2 -=1 if ( $direction == 1 );
				$ax2 +=1 if ( $direction == 2 );
				$az2 -=1 if ( $direction == 3 );
				$az2 +=1 if ( $direction == 4 );

				# get vertical-hallway-expansion flags
				my $vhe2flags = getvhe( $xinc2, $yinc2, $zinc2 );
				my $segment2 = getsegment( $xinc2, $yinc2, $zinc2 );

				my $cellspc2 = getcellspc( $xinc2, $yinc2, $zinc2 );

				# add the floor bit if we are dealing with a passthru cell
				$segment2 = ( $segment2 | 32 ) if ( $cellspc2 >= 32 && $cellspc2 <= 39 );

				my ($feffectlvl2, $feffecttype2) = getfeffectlvl( $xinc2, $yinc2, $zinc2 );
				my ($ceffectlvl2, $ceffecttype2) = getceffectlvl( $xinc2, $yinc2, $zinc2 );

				my $umflag2 = getumflag( $xinc2, $yinc2, $zinc2 );

				if ($pass == 1) {
				    # populate the floor characters during pass 1
				    if ( $cellspc == 53 ) {
					last;
				    } elsif ( ( $cellspc >= 48 && $cellspc <= 63 ) ) {
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 39);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 40);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 46);
				    } elsif ( ( $cellspc2 >= 48 && $cellspc2 <= 63 ) ) {
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 39);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 40);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 46);
				    } elsif ( $umflag && ! $direction ) {
					setasciipoint( $ax2, $ay2, $az2, 'u', 7, 41);
				    } elsif ( $umflag && $umflag2 && $direction ) {
					setasciipoint( $ax2, $ay2, $az2, 'u', 7, 44);
				    } elsif ( ( $umflag2 || $umflag ) && ( $direction == 1 || $direction == 2 )) {
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 26);
					# my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 29);
					setasciipoint( $ax2, $ay2, $az2, $char, 7, 42);
				    } elsif ( ( $umflag2 || $umflag ) && ( $direction == 3 || $direction == 4 )) {
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 27);
					# my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 29);
					setasciipoint( $ax2, $ay2, $az2, $char, 7, 43);
				    } elsif ( $vheflags >= 0b101 && $vhe2flags >= 0b101 && ( $segment & $segment2 & 32 ) ) {
					# downward expansion bottom - bottom
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 12);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 15);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 2);
				    } elsif (( $vheflags & 0b011 ) && ( $vhe2flags & 0b011 ) && ( $segment & $segment2 & 16 )) {
					# upward expansion top - top
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 10);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 13);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 3);
				    } elsif ( $vheflags && $vhe2flags && (($segment & 32) == 0) && (($segment2 & 32 ) == 0)) {
					# vhe w/open floor
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 11);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 14);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 4);
				    } elsif ((($segment & 32) == 0) && (($segment2 & 32 ) == 0)) {
					# misc open floor
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 11);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 14);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 6);
				    } elsif ((($segment & 32) != ($segment2 & 32 )) && ( $hallinfo[$hall][1][26] )) {
					# VHE ledge
					if ( $direction == 1 || $direction == 2 ) {
					    my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 26);
					    my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 29);
					    setasciipoint( $ax2, $ay2, $az2, $char, $color, 32);
					} else {
					    my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 27);
					    my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 29);
					    setasciipoint( $ax2, $ay2, $az2, $char, $color, 32);
					};
				    } else {
					# floor
					my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 5);
					my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 9);
					setasciipoint( $ax2, $ay2, $az2, $char, $color, 5);
				    };
				};

				if ( $pass == 2) {
				    # populate crossover indicators during pass 2
				    if ( $cellspc2 == 5 && $direction == 1) {
					setasciipoint( $ax2, $ay2, $az2, ']', 7, 7);
				    } elsif ( $cellspc2 == 4 && $direction == 2 ) {
					setasciipoint( $ax2, $ay2, $az2, '[', 7, 7);
				    } elsif ( $cellspc2 == 7 && $direction == 3) {
					setasciipoint( $ax2, $ay2, $az2, '=', 7, 7);
				    } elsif ( $cellspc2 == 6 && $direction == 4 ) {
					setasciipoint( $ax2, $ay2, $az2, '=', 7, 7);
				    }
				}
		    	}

			next if ( $pass != 3 );

			# indicate floor/ceiling effects on the map if requested
			if ( $showfceffect ) {
			    my ($feffectlvl, $feffecttype) = getfeffectlvl( $xinc, $yinc, $zinc );
			    my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xinc, $yinc, $zinc );
			    foreach my $XI ( -1, 0, 1 ) {
				foreach my $ZI ( -1, 0, 1 ) {
				    my $opos = $asciigrid[$ax+$XI][$ay][$az+$ZI];

				    # get the 'floor' character for the hallway class of this cell
				    my $hall = gethallid( $xinc, $yinc, $zinc );
				    my $hclass = gethallinfo( $xinc, $yinc, $zinc, 0, 0);

				    if ( $feffectlvl && $opos eq gethallinfo( $xinc, $yinc, $zinc, 1, 5 )) {
					my $feffectchar = $feffectclass[$feffecttype][2];
					my $feffectcolor = $feffectclass[$feffecttype][3];
					setasciipoint( $ax+$XI, $ay, $az+$ZI, $feffectchar, $feffectcolor, 8 );
				    } elsif ( $ceffectlvl && $opos eq gethallinfo( $xinc, $yinc, $zinc, 1, 5 )) {
					my $ceffectchar = $ceffectclass[$ceffecttype][2];
					my $ceffectcolor = $ceffectclass[$ceffecttype][3];
					setasciipoint( $ax+$XI, $ay, $az+$ZI, $ceffectchar, $ceffectcolor, 8 );
				    };
				}
			    }
			}

			# cleanup pillar characters in unmined areas
			my $umflag_nw = getumflag( $xinc, $yinc, $zinc );
			my $umflag_ne = getumflag( $xinc+1, $yinc, $zinc );
			my $umflag_sw = getumflag( $xinc, $yinc, $zinc+1 );
			my $umflag_se = getumflag( $xinc+1, $yinc, $zinc+1 );
			if ( $umflag_nw && $umflag_ne && $umflag_sw && $umflag_se ) {
				setasciipoint( $ax + 1, $ay, $az + 1 , "u", 7, 45 );
			};
			
			# indicate traps on the map if requested
			if (($cellspc == 8 || $cellspc == 9) && $showtraps) {
				setasciipoint( $ax, $ay, $az, '^', 1, 9 );
			}
			if ( $cellspc == 11 ) {
				setasciipoint( $ax, $ay, $az, '_', 1, 10 );
			}

			# determine vertical wall segment info
			my $dir5wall = (($paths & 16 )>> 4);
			my $dir6wall = (($paths & 32 )>> 5);

			my $udicolor = 7;
			$udicolor = 3 if ( $cellspc >= 40 && $cellspc <= 63 );

			if ( $vheflags == 0b000 && $cellspc < 8 || $cellspc > 11 ) {
				if ( $dir5wall == 0 && $dir6wall == 1 ) {
					setasciipoint( $ax, $ay, $az, 'u', $udicolor, 11 );
				} elsif ( $dir5wall == 1 && $dir6wall == 0 ) {
					setasciipoint( $ax, $ay, $az, 'd', $udicolor, 12 );
				} elsif ( $dir5wall == 0 && $dir6wall == 0 ) {
					setasciipoint( $ax, $ay, $az, 'i', $udicolor, 13 );
				};
			} elsif ( $dir5wall == 0 && $dir6wall == 0 ) {
				if ( $vheflags == 0b100 && ($segment & 16 )) {
					# path up from a vhe down extension
					setasciipoint( $ax, $ay, $az, 'u', 1, 14 );
				} elsif ( $vheflags == 0b100 && ($segment & 32 )) {
					# path down from a vhe up extension
					setasciipoint( $ax, $ay, $az, 'd', 1, 15 );
				}
			}

			# indicate diagonal paths on the map
			if ( $diagpath && $hallinfo[$hall][1][24] ) {
				my $char = gethallinfo( $xinc, $yinc, $zinc, 1, 24);
				my $color = gethallinfo( $xinc, $yinc, $zinc, 1, 25);
				setasciipoint( $ax, $ay, $az, $char, $color, 30);
			};
		    }
		}
	    }
	}

	# indicate replaced or removed pillars
	foreach my $pillar ( 1 .. $pillarcount ) {
		my $X = $pillarlist[$pillar][0];
		my $Y = $pillarlist[$pillar][1];
		my $Z = $pillarlist[$pillar][2];
		my $hall = gethallid( $X, $Y, $Z );
		my $vheflags = $pillarlist[$pillar][3];
		my $hclass = $pillarlist[$pillar][4];
		my $height = $pillarlist[$pillar][10];
		my $opattern = $pillarlist[$pillar][6];
		my $pfeffecttype = $pillarlist[$pillar][7];
		my $ax = ( $X * 2) + 1;
		my $ay = $Y;
		my $az = ( $Z * 2) + 1;
		my $ax2 = $ax + 1;
		my $az2 = $az + 1;
		my ( $feffectchar, $feffectcolor ) = ( '', 0 );
		my ( $valid_b20, $hallspc_b20 ) = gethallflag( $X, $Y, $Z, 20 );
		my ( $valid_b28, $hallspc_b28 ) = gethallflag( $X, $Y, $Z, 28 );
		my $pillarodds = gethallinfo( $X, $Y, $Z, 1, 22 );
		my $pillarsel = gethallinfo( $X, $Y, $Z, 1, 23 );

		# indicate floor effects on the map if requested
		if ( $showfceffect ) {
			my $opos = $asciigrid[$ax2][$ay][$az2];

			if ( $pfeffecttype != -1 && $opos eq '#' ) {
				$feffectchar = $feffectclass[$pfeffecttype][2];
				$feffectcolor = $feffectclass[$pfeffecttype][3];
			}
		};

		if ( $height >= 2 && ! $hallspc_b28 ) {
			next if ( ! $pillarodds || ! $pillarsel );
			for my $yinc ( ( $Y - $height + 1 ) .. $Y ) {
				setasciipoint( $ax2, $yinc, $az2, '#', 3, 34);
			};
		} elsif ( ( $height == 1 && $hallspc_b20 ) || ( $height >= 2 && $hallspc_b28 ) ) {
			# determine what replacement char/color to use for pillar base
			my $char = gethallinfo( $X, $Y, $Z, 1, 5);
			my $color = gethallinfo( $X, $Y, $Z, 1, 9);
			my $allowfeffect = 1;
			if ( $opattern & 0xf0 ) {
				$char = gethallinfo( $X, $Y, $Z, 1, 28);
				$color = gethallinfo( $X, $Y, $Z, 1, 29);
				$allowfeffect = 0;
			};
			if ( ( $opattern & 0xf0 ) == 0x30 || ( $opattern & 0xf0 ) == 0xc0 ) {
				$char = gethallinfo( $X, $Y, $Z, 1, 27);
				$allowfeffect = 0;
			};
			if ( ( $opattern & 0xf0 ) == 0x50 || ( $opattern & 0xf0 ) == 0xa0 ) {
				$char = gethallinfo( $X, $Y, $Z, 1, 26);
				$allowfeffect = 0;
			};
			if (( $opattern & 0xf0 ) == 0xf0 ) {
				$char = gethallinfo( $X, $Y, $Z, 1, 5);
				$color = gethallinfo( $X, $Y, $Z, 1, 9);
				$allowfeffect = 1;
			};
	
			( $char, $color ) = ( $feffectchar, $feffectcolor ) if ( $feffectchar && $allowfeffect );
	
			setasciipoint( $ax2, $ay, $az2, $char, $color, 39 );

			# replace upper pillar sections with empty space
			for my $yinc ( ( $Y - $height + 1 ) .. ( $Y - 1 ) ) {
				$char = gethallinfo( $X, $yinc, $Z, 1, 10);
				$color = gethallinfo( $X, $yinc, $Z, 1, 13);
				setasciipoint( $ax2, $yinc, $az2, $char, $color, 40 );
			};
		};
	};

	# clear out tower level(s)
	foreach my $ycoord ( 0 .. $ymazesize - 1 ) {

		# Only perform this action on tower levels
		my $levelclass = getlevelspc( $ycoord );
		my ( $levelcnum, $levelname ) = getlevelident( "Towers" );

		next if ( $levelclass != $levelcnum );

		my $char = ' ';
		my $color = 0;
		# my $fchar = '.';
		# my $fcolor = 7;

		foreach my $zcoord ( 0..($zmazesize-1)) {
			foreach my $xcoord ( 0..($xmazesize-1)) {

				# skip this location if it belongs to a room
				my $roomid = getroomid( $xcoord, $ycoord, $zcoord );
				next if ( $roomid );

				# mark this cell as a blank space on ascii map
				setasciipoint( ($xcoord*2)+1,$ycoord,($zcoord*2)+1,$char, $color, 16);

				# add walls back based on room cell adjacency
				my $path = 0;
				foreach my $dir ( 1..4 ) {
					my ($xdir, $ydir, $zdir) = getmazedirection( $dir );
					my $xcheck = $xcoord + $xdir;
					my $ycheck = $ycoord + $ydir;
					my $zcheck = $zcoord + $zdir;

					my $roomid = 0;

					# get adjacent room id, if the cell is within the array
					my $valid = checkbounds( $xcheck, $ycheck, $zcheck );
					$roomid = getroomid( $xcheck, $ycheck, $zcheck ) if $valid;
					my $adjpath = getpathflags( $xcheck, $ycheck, $zcheck ) if $valid;
					$adjpath = 0 if ( ! $adjpath );

					if ( ! $roomid ) {
						# clear the ascii wall element if the adjacent cell does not belong to a room
						setasciipoint(($xcoord*2)+$xdir+1, $ycoord+$ydir, ($zcoord*2)+$zdir+1, $char, $color, 17);
					};
				}

				# cleanup diagonal ascii points
				my $valid = checkbounds(($xcoord+1),$ycoord,($zcoord+1));
				if ( $valid ) {

					# check the validity of the 4 adjacent cells
					my $Q1I = checkbounds( $xcoord, $ycoord, $zcoord );
					my $Q2I = checkbounds( $xcoord+1, $ycoord, $zcoord );
					my $Q3I = checkbounds( $xcoord, $ycoord, $zcoord+1 );
					my $Q4I = checkbounds( $xcoord+1, $ycoord, $zcoord+1 );

					# grab the room ids of four adjacent cells
					$Q1I = getroomid( $xcoord, $ycoord, $zcoord ) if $Q1I;
					$Q2I = getroomid( $xcoord+1, $ycoord, $zcoord ) if $Q2I;
					$Q3I = getroomid( $xcoord, $ycoord, $zcoord+1 ) if $Q3I;
					$Q4I = getroomid( $xcoord+1, $ycoord, $zcoord+1 ) if $Q4I;

					# open up the center point between them if all four are assigned to this room
					if ( ! $Q1I && ! $Q2I && ! $Q3I && ! $Q4I ) {
						my $xdcoord = (($xcoord*2)+2);
						my $zdcoord = (($zcoord*2)+2);

						setasciipoint($xdcoord, $ycoord, $zdcoord, $char, $color, 18);
					}
				}

				my $zdcoord = (($zcoord*2)+1);
				my $xdcoord = (($xcoord*2)+1);

				# cleanup left/right borders
				setasciipoint($xdcoord-1, $ycoord, $zdcoord-1, $char, $color, 18) if ($xcoord == 0 );
				setasciipoint($xdcoord-1, $ycoord, $zdcoord+1, $char, $color, 18) if ($xcoord == 0 );
				setasciipoint($xdcoord+1, $ycoord, $zdcoord-1, $char, $color, 18) if ($xcoord == $xmazesize-1 );
				setasciipoint($xdcoord+1, $ycoord, $zdcoord+1, $char, $color, 18) if ($xcoord == $xmazesize-1 );

				# cleanup top/bottom borders
				setasciipoint($xdcoord-1, $ycoord, $zdcoord-1, $char, $color, 18) if ($zcoord == 0 );
				setasciipoint($xdcoord+1, $ycoord, $zdcoord-1, $char, $color, 18) if ($zcoord == 0 );
				setasciipoint($xdcoord-1, $ycoord, $zdcoord+1, $char, $color, 18) if ($zcoord == $zmazesize-1 );
				setasciipoint($xdcoord+1, $ycoord, $zdcoord+1, $char, $color, 18) if ($zcoord == $zmazesize-1 );
			}
		}
	}

	# build rooms in ascii grid

	foreach my $room ( 1 .. $totalrooms ) {

		# get the room class and coordinates
		my $roomspc = getroomspc( $room );
		my ($xc, $yc, $zc, $xs, $ys, $zs, $xe, $ye, $ze) = getroompos( $room );
		my $xf = $xc + $xs - 1;
		my $yf = $yc + $ys - 1;
		my $zf = $zc + $zs - 1;

		# get the floor effect level for the room
		my ($feffectlvl, $feffecttype) = getfeffectlvl( $xe, $ye, $ze );
		my ($ceffectlvl, $ceffecttype) = getceffectlvl( $xe, $ye, $ze );

		# we do not show room floor effects if room special flag bit 13 is set
		my ( $valid_b13, $roomspc_b13) = getroomspcflag( $roomspc, 13 );

		# build room in ascii array
		foreach my $YI ( 0..($ys-1)) {
		    foreach my $ZI ( 0..($zs-1)) {
			foreach my $XI ( 0..($xs-1)) {

				my $xcoord = ( $xc + $XI );
				my $ycoord = ( $yc + $YI );
				my $zcoord = ( $zc + $ZI );

				# skip this location if it does not belong to this room
				my $roomid = getroomid( $xcoord, $ycoord, $zcoord );
				next if ( $roomid != $room );

				my $pathvar = getpathflags( $xcoord, $ycoord, $zcoord );

				# get the floor and openspace character for the room cell
				my $char = $roomclass[$roomspc][8];
				my $color = $roomclass[$roomspc][14];
		    		my $fchar = $roomclass[$roomspc][9];
		        	my $fcolor = $roomclass[$roomspc][15];
				if ( $pathvar & 32 ) {
				    if ( $feffectlvl && ! $roomspc_b13 ) {
					$char = $feffectclass[$feffecttype][2];
					$color = $feffectclass[$feffecttype][3];
				    } else {
		    			$char = $roomclass[$roomspc][9];
		        		$color = $roomclass[$roomspc][15];
				    }
				    $fchar = $char;
				    $fcolor = $color;
				}

				my $cellspc = getcellspc( $xcoord, $ycoord, $zcoord );

				# mark this cell as a room space on ascii map if it isn't used by a passthru.
				setasciipoint( ($xcoord*2)+1,$ycoord,($zcoord*2)+1,$char, $color, 16) if ( $cellspc < 32 || $cellspc > 39 );


				# add walls back based on room cell adjacency
				my $path = 0;
				foreach my $dir ( 1..6 ) {
					my ($xdir, $ydir, $zdir) = getmazedirection( $dir );
					my $xcheck = $xcoord + $xdir;
					my $ycheck = $ycoord + $ydir;
					my $zcheck = $zcoord + $zdir;

					my $roomid = 0;

					# get adjacent room id, if the cell is within the array
					my $valid = checkbounds( $xcheck, $ycheck, $zcheck );
					$roomid = getroomid( $xcheck, $ycheck, $zcheck ) if $valid;
					my $adjpath = getpathflags( $xcheck, $ycheck, $zcheck ) if $valid;

					my $adjcellspc = getcellspc( $xcheck, $ycheck, $zcheck ) if $valid;
					$adjcellspc = 0 if ! $adjcellspc;
					next if ( ( $adjcellspc >= 32 && $adjcellspc <= 39 ) && $dir < 5 );

					if ( $roomid != $room ) {
						my $pathval = getpathflags( $xcoord, $ycoord, $zcoord );
					} elsif ( $cellspc >= 32 && $cellspc <= 39 ) {

						# indicate the side of a passthru span
						my $color = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 29);
						my $char = '';
						$char = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 26) if ( $dir == 1 || $dir == 2 );
						$char = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 27) if ( $dir == 3 || $dir == 4 );

						setasciipoint(($xcoord*2)+$xdir+1, $ycoord+$ydir, ($zcoord*2)+$zdir+1, $char, $color, 17) if $char;
					} else {
						# clear the ascii wall element if the adjacent cell belongs to this room
						if ( $dir < 5 ) {
							if ( $adjpath & 32 ) {
								setasciipoint(($xcoord*2)+$xdir+1, $ycoord+$ydir, ($zcoord*2)+$zdir+1, $fchar, $fcolor, 17);
							} else {
								setasciipoint(($xcoord*2)+$xdir+1, $ycoord+$ydir, ($zcoord*2)+$zdir+1, $char, $color, 17);
							};
						}
					};
				}

				# cleanup diagonal ascii points
				my $valid = checkbounds(($xcoord+1),$ycoord,($zcoord+1));
				if ( $valid ) {
					# grab the room ids of four adjacent cells
					my $Q1I = getroomid( $xcoord, $ycoord, $zcoord );
					my $Q2I = getroomid( $xcoord+1, $ycoord, $zcoord );
					my $Q3I = getroomid( $xcoord, $ycoord, $zcoord+1 );
					my $Q4I = getroomid( $xcoord+1, $ycoord, $zcoord+1 );

					# get the floor state of the four adjacent cells
					my $Q1F = (( getpathflags( $xcoord, $ycoord, $zcoord ) & 32 ) >> 5);
					my $Q2F = (( getpathflags( $xcoord+1, $ycoord, $zcoord ) & 32 ) >> 5);
					my $Q3F = (( getpathflags( $xcoord, $ycoord, $zcoord+1 ) & 32 ) >> 5);
					my $Q4F = (( getpathflags( $xcoord+1, $ycoord, $zcoord+1 ) & 32 ) >> 5);

					# get the cellspc value of the four adjacent cells
					my $Q1C = ( getcellspc( $xcoord, $ycoord, $zcoord ));
					my $Q2C = ( getcellspc( $xcoord+1, $ycoord, $zcoord ));
					my $Q3C = ( getcellspc( $xcoord, $ycoord, $zcoord+1 ));
					my $Q4C = ( getcellspc( $xcoord+1, $ycoord, $zcoord+1 ));

					# simplify the cellspc values for passthru ranges
					if ( $Q1C >= 34 && $Q1C <= 39 ) {
						$Q1C = 1;
					} else {
						$Q1C = 0;
					};
					if ( $Q2C >= 34 && $Q2C <= 39 ) {
						$Q2C = 1;
					} else {
						$Q2C = 0;
					};
					if ( $Q3C >= 34 && $Q3C <= 39 ) {
						$Q3C = 1;
					} else {
						$Q3C = 0;
					};
					if ( $Q4C >= 34 && $Q4C <= 39 ) {
						$Q4C = 1;
					} else {
						$Q4C = 0;
					};

					my $QTF = ( $Q1F + $Q2F + $Q3F + $Q4F );

					# open up the center point between them if all four are assigned to this room
					if ( $Q1I == $room && $Q2I == $room && $Q3I == $room && $Q4I == $room ) {
						my $xdcoord = (($xcoord*2)+2);
						my $zdcoord = (($zcoord*2)+2);

						if ( $Q1C && $Q2C ) {
							my $ptcolor = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 29);
							my $ptchar = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 27);
							setasciipoint($xdcoord, $ycoord, $zdcoord, $ptchar, $ptcolor, 18);
						} elsif ( $Q3C && $Q4C ) {
							my $ptcolor = gethallinfo( $xcoord, $ycoord, $zcoord+1, 1, 29);
							my $ptchar = gethallinfo( $xcoord, $ycoord, $zcoord+1, 1, 27);
							setasciipoint($xdcoord, $ycoord, $zdcoord, $ptchar, $ptcolor, 18);
						} elsif ( $Q1C && $Q3C ) {
							my $ptcolor = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 29);
							my $ptchar = gethallinfo( $xcoord, $ycoord, $zcoord, 1, 26);
							setasciipoint($xdcoord, $ycoord, $zdcoord, $ptchar, $ptcolor, 18);
						} elsif ( $Q2C && $Q4C ) {
							my $ptcolor = gethallinfo( $xcoord+1, $ycoord, $zcoord, 1, 29);
							my $ptchar = gethallinfo( $xcoord+1, $ycoord, $zcoord, 1, 26);
							setasciipoint($xdcoord, $ycoord, $zdcoord, $ptchar, $ptcolor, 18);
						} elsif ( $Q2C && $Q4C ) {
							setasciipoint($xdcoord, $ycoord, $zdcoord, '|', $fcolor, 18);
						} elsif ( $QTF != 0 ) {
							setasciipoint($xdcoord, $ycoord, $zdcoord, $fchar, $fcolor, 18);
						} else {
							setasciipoint($xdcoord, $ycoord, $zdcoord, $char, $color, 18);
						}
					}
				}
			    }
			}
		}
		# indicate up/intermediate/down dir in room center if room special flag bit 3 is set
		my ( $valid_b3, $roomspc_b3) = getroomspcflag( $roomspc, 3 );

		if ( $roomspc_b3 ) {

			my $xctr = ((($xc*2+1) + ($xf*2+1))/2);
			my $zctr = ((($zc*2+1) + ($zf*2+1))/2);
			foreach my $yinc ( $yc..$yf ) {
				my $color = $colorgrid[$xctr][$yinc][$zctr];
				setasciipoint($xctr, $yinc, $zctr, "i", $color, 19);
				if (($yinc == $yc && ! $invertlevels) || ( $yinc == $yf && $invertlevels)) {
					setasciipoint($xctr, $yinc, $zctr, "d", $color, 20);
				}
				if (($yinc == $yf && ! $invertlevels) || ( $yinc == $yc && $invertlevels)) {
					setasciipoint($xctr, $yinc, $zctr, "u", $color, 21);
				}
			}
		}

		# skip adding room number if room special flag bit 1 is set.
		my ( $valid_b1, $roomspc_b1) = getroomspcflag( $roomspc, 1 );
		next if ( $roomspc_b1 );

		# skip adding room number if room is not suitable for it.
		next if ( $xs < 2 );

		my $roomdig1 = $room % 10;
		my $roomdig2 = int($room /10) % 10;
		my $roomdig3 = int($room /100) % 10;

		# on each level, search for a suitable location for the room number
		foreach my $yinc ( $yc..$yf ) {
			my ( $found, $xloc, $zloc ) = ( 0,0,0 );
			foreach my $zinc ( $zc..$zf ) {
				foreach my $xinc ( $xc..$xf ) {
					my ( $roomnum, $roomnum2 ) = ( 0, 0);
					$roomnum = getroomid( $xinc, $yinc, $zinc );
					my $valid = checkbounds( $xinc+1, $yinc, $zinc );
					$roomnum2 = getroomid( $xinc+1, $yinc, $zinc ) if $valid;
					if ( $roomnum == $room && $roomnum2 == $room ) {
						$found = 1;
						$xloc = $xinc;
						$zloc = $zinc;
						last
					}
				}
				last if $found;
			}
			next if ! $found;

			# add the room number
			if ( $roomdig3 != 0 ) {
				setasciipoint($xloc*2+1, $yinc, $zloc*2+1, "$roomdig3", 7, 22 );
				setasciipoint($xloc*2+2, $yinc, $zloc*2+1, "$roomdig2", 7, 23 );
				setasciipoint($xloc*2+3, $yinc, $zloc*2+1, "$roomdig1", 7, 24 );
			} elsif ( $roomdig2 != 0 ) {
				setasciipoint($xloc*2+1, $yinc, $zloc*2+1, "$roomdig2", 7, 25 );
				setasciipoint($xloc*2+2, $yinc, $zloc*2+1, "$roomdig1", 7, 26 );
			} else {
				setasciipoint($xloc*2+1, $yinc, $zloc*2+1, "$roomdig1", 7, 27 );
			}
		}
	}

	# Add doors to ascii grid

	foreach my $door ( 1 .. $totaldoors ) {
		my ($x, $y, $z, $room, $doornum, $dir, $from, $did, $valid, $doorclass ) = getdoorinfo( $door );

		# skip this door if it is not marked as valid
		next if ! $valid;

		next if ( ! $dir );

		# skip this door if it is at the maze start of any of the threads
		my $skip = 0;
		foreach my $thread ( 1 .. $totalthreads ) {
			my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) = getthreadinfo( $thread );
			$skip = 1 if ( $x == $STX && $y == $STY && $z == $STZ );
		}
		next if $skip;

		my $dhallid = gethallid( $x, $y, $z );
		my ( $XI, $YI, $ZI ) = getmazedirection( $dir );

		$dir -= 27 if ( $dir >= 28 );
		$dir -= 23 if ( $dir >= 24 );
		$dir -= 19 if ( $dir >= 20 );
		$dir -= 15 if ( $dir >= 16 );
		$dir -= 11 if ( $dir >= 12 );
		$dir -= 7  if ( $dir >= 8 );

		my $doorchr = $doorclass[$doorclass][$dir + 1 ];
		my $doorcol = $doorclass[$doorclass][10];

		setasciipoint($x*2+1+$XI, $y, $z*2+1+$ZI, $doorchr, $doorcol, 28 );
	}
	
	# add starting locations to ascii grid
	foreach my $thread ( 1 .. $totalthreads ) {
		my ( $name, $X, $Y, $Z, $dist, $STX, $STY, $STZ, $HDX, $HDY, $HDZ, $HDST, $END, $OSTX, $OSTY, $OSTZ, $DEND ) = getthreadinfo( $thread );

		my $thrdig1 = ( $thread - 1 ) % 8;
		my $thrdig2 = int(($thread - 1) /8) % 8;
		setasciipoint($OSTX*2+1, $OSTY, $OSTZ*2+1, "$thrdig1", $thrdig2 + 1, 29 );
	};
}

#------------------------------------------------------------------------------
# initgrid - initialize maze grids

sub initgrid {

	$debug1 = 1 if $debug >= 1;
	$debug2 = 1 if $debug >= 2;
	$debug3 = 1 if $debug >= 3;

	# check if we are requesting a labyrinth
	if ( $labyrinth == 0 ) {
		my ( $levelcnum, $levelname ) = getlevelident( "Labyrinth" );
		$levelinfo[$labyrinth][0] = $levelcnum;

		my $ylevelscale = $levelclass[$levelcnum][ 2 ];
		$levelinfo[$labyrinth][1] = $ylevelscale;
	} elsif ( $labyrinth >= 1 ) {
		my ( $levelcnum, $levelname ) = getlevelident( "Labyrinth" );
		my ( $towercnum, $towername ) = getlevelident( "Towers" );

		$levelinfo[$labyrinth][0] = $levelcnum;
		my $ylevelscale = $levelclass[$levelcnum][ 2 ];
		$levelinfo[$labyrinth][1] = $ylevelscale;

		for my $tlevel ( 0 .. $labyrinth - 1 ) {
			$levelinfo[$tlevel][0] = $towercnum;

			my $ylevelscale = $levelclass[$towercnum][ 2 ];
			$levelinfo[$tlevel][1] = $ylevelscale;
		};
	};

	# initialize random grid
	foreach my $pass ( 0 .. 1 ) {
	    foreach my $yinc (0 .. $ymazesize) {
        	foreach my $xinc (0 .. $xmazesize) {
        	    foreach my $zinc (0 .. $zmazesize) {
			if ( $pass == 0 ) {
				$randgrid[$xinc][$yinc][$zinc] = int(rand(1 << 16));
			} else {
				$randgrid[$xinc][$yinc][$zinc] =
					( $randgrid[$xinc][$yinc][$zinc] << 16 ) | int(rand(1 << 16));
			};
		    };
		};
	    };
	};

	foreach my $yinc (0 .. $ymazesize-1) {
          foreach my $xinc (0 .. $xmazesize-1) {
            foreach my $zinc (0 .. $zmazesize-1) {
		# preset each maze point with all available paths and segments
		$mazegrid[$xinc][$yinc][$zinc] = $pathmask;
		$auxmazegrid[$xinc][$yinc][$zinc] = $segmentmask;
		$distmazegrid[$xinc][$yinc][$zinc] = 0;
		# zero thrmazegrid, objmazegrid, and adjmazegrid arrays
		$objmazegrid[$xinc][$yinc][$zinc] = 0;
		$thrmazegrid[$xinc][$yinc][$zinc] = 0;
		$adjmazegrid[$xinc][$yinc][$zinc] = 0;
	    }
	  }

	  # pre-fill in the level style name and Y scale
	  if (! $levelinfo[$yinc][0]) {

		$levelinfo[$yinc][0] = 0;
	  	$levelinfo[$yinc][1] = $levelclass[0][2];

	  } elsif ($dungeonmode && ! $levelinfo[$yinc][0]) {

		$levelinfo[$yinc][0] = 1;
	  	$levelinfo[$yinc][1] = $levelclass[1][2];
	  }
        }

	print "seeding random generator with $seed\n" if ( $debug );
	srand $seed if ( $seed );

	$doorinfo[0][0]=0;
        $doorinfo[0][1]=0;
	
	# look for the first starting level
	for my $inc ( 0 .. ($ymazesize-1) ) {

		# get the level class special flag bit 9 for the starting level
		my $leveltype = $levelinfo[$inc][0];
		my $nostartflag = getlevelflag( $inc, 9 );

		next if $nostartflag;

		$ystartlevel = $inc;
		print "ystartlevel adjusted to $ystartlevel\n" if ( $debug );
		last;
	}
};
#------------------------------------------------------------------------------
# initfile - zero output file
sub initfile {
	my $filetype = $_[0];
	open(OUTPUT, ">$fileprefix.$filetype");
	close(OUTPUT);
};

#==============================================================================
# main routine

if ( $buildtempl ) {
	buildschtemp;
	exit;
};

initgrid;

if ( ! $dungeonmode ) {
	addrooms( 0, $ymazesize - 1 );;
 	addthread( '', 0, $ystartlevel, 0, 0, 0, $ystartlevel, 0, 0, 0, 0, 0 );

	# pre-build the labyrinth if specified
	if ( $levelinfo[$ystartlevel][0] == 4 ) {
 		buildlabyrinth;
	} else {
		buildmaze;
	};

 	addloops if $mazeloops;
	addxoloops if $mazexoloops;
 	removedeadends( 0, 0, 0 );
	addinteriors;
 	mazecleanup;
 	buildasciigrid;
} else {
	# override settings which would mess up dungeon building
	$updowndirs = 0;
	$verticaldoors = 0;
	# $invertlevels = 0;
	$ymaxroom = 1;
	# $ymazestart = 0;
	$vhe_enabled = 0;

	addthread( '',   0,  $ystartlevel,   0,  0,   0,  $ystartlevel,   0, 0, 0, 0, 0 );
	addthread( '', '-0', $ystartlevel, '-0', 0, '-0', $ystartlevel, '-0', 0, 0, 0, 0 );
	addthread( '',   0,  $ystartlevel, '-0', 0,   0,  $ystartlevel, '-0', 0, 0, 0, 0 );
	addthread( '', '-0', $ystartlevel,   0,  0, '-0', $ystartlevel,   0, 0, 0, 0, 0 );
	builddungeon();
	addloops if $mazeloops;
	addxoloops if $mazexoloops;
	removedeadends( 0, 0, 0 );
	addinteriors;
	mazecleanup;
	buildasciigrid;
};

# output to .mce file
# if ( $mceout ) {
# 	$debug = 0;
# 	printmcesch;
# };

# output to .txt file
if ( $txtout ) {
	$debug = 0;
	printasciimaze;
	printroominfo;
	printdoorinfo;
	printhallinfo;
	printansimaze;
};

# output to .mce file
if ( $mceout ) {
	$debug = 0;
	printmcesch;
};

# output to .raw file
if ( $rawout ) {
	$debug = 0;
	printrawdata;
};

# create bitmap room template file
if ( $roomtemplate ) {
	printmceroomtemp( $roomtemplate );
};

# output to .diag file
if ( $diagout ) {
	$debug = 0;
	initfile( "diag" );
	printseed;
	printobjidxmap;
	printobjcountmap;
	printobjtthrmap;
	printobjathrmap;
	printthreadmap;
	printvhemap;
	printfevmap;
	printfeffecttype;
	printfeffectlvl;
	printceffecttype;
	printceffectlvl;
	# printroomspc;
	printcellspc;
	printpridoorflags;
	printbackdirmap;
	printroomidmap;
	printhallidmap;
	printhallgstylemap;
	printhalllstylemap;
	printhallclassmap;
	printsegmentmap;
	printpathmap;
	printdistmap;
	printdoorflags;
	printdoorgroups;
	printodoorflags;
	printthruflags;
	printothruflags;
	printuseflags;
	printledgeflags;
	printdiagpathflags;
};

#==============================================================================
# end of file

